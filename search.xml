<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>剑指offer-V2-03-数组中重复的数字</title>
    <url>/2022/10/27/%E5%89%91%E6%8C%87offer-v2-03-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/?favorite=xb9nqhhg">原题点这里</a></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202210270948039.png" alt=""><br><span id="more"></span></p>
<h2 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h2><p>直接采用HashMap的思想：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findRepeatNumber</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	exists := <span class="built_in">make</span>([]<span class="type">bool</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">	<span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">		<span class="keyword">if</span> exists[num] &#123;</span><br><span class="line">			<span class="keyword">return</span> num</span><br><span class="line">		&#125;</span><br><span class="line">		exists[num] = <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h2><p>因为n个数字的的大小范围都在0～n-1之间，那么就可以把数字num1放到数组中下标为num1的地方。这样假设数字num1出现了重复，那么可以根据数组下标nums1位置上的数字是否等于数字num1来判断。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findRepeatNumber</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums); &#123;</span><br><span class="line">		<span class="keyword">if</span> nums[i] == i &#123;</span><br><span class="line">			i++</span><br><span class="line">			<span class="keyword">continue</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> nums[nums[i]] == nums[i] &#123;</span><br><span class="line">			<span class="keyword">return</span> nums[i]</span><br><span class="line">		&#125;</span><br><span class="line">		nums[nums[i]], nums[i] = nums[i], nums[nums[i]]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>offer</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-V2-04-二维数组中的查找</title>
    <url>/2022/10/27/%E5%89%91%E6%8C%87offer-v2-04-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/?favorite=xb9nqhhg">原题点这里</a></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202210271229492.png" alt=""><br><span id="more"></span></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>从左下角开始搜索，如果当前元素小于target，向上移动，大于target向右移动。</p>
<p>为什么要从左下角开始搜索？因为如果从原点（0，0）开始搜索，那么可走的路线就只能向右或者向下，都是往大的方向走，想回退的话比较麻烦，所以从左下角开始搜索，既有一条大的方向，又有一条小的方向。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findNumberIn2DArray</span><span class="params">(matrix [][]<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(matrix) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(matrix[<span class="number">0</span>]) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">    i, j := <span class="built_in">len</span>(matrix)<span class="number">-1</span>, <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i &gt;= <span class="number">0</span> &amp;&amp; j &lt; <span class="built_in">len</span>(matrix[<span class="number">0</span>]) &#123;</span><br><span class="line">		<span class="keyword">if</span> matrix[i][j] == target &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> matrix[i][j] &gt; target &#123;</span><br><span class="line">			i--</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			j++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>offer</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-V2-05-替换空格</title>
    <url>/2022/10/27/%E5%89%91%E6%8C%87offer-v2-05-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/ti-huan-kong-ge-lcof/">原题点这里</a></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202210271237724.png" alt=""><br><span id="more"></span></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>在golang中，字符串不能直接修改，所以直接遍历拼接。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">replaceSpace</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">    ret := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> s[i] == <span class="string">&#x27; &#x27;</span> &#123;</span><br><span class="line">			ret = <span class="built_in">append</span>(ret, []<span class="type">byte</span>(<span class="string">&quot;%20&quot;</span>)...)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			ret = <span class="built_in">append</span>(ret, s[i])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="type">string</span>(ret)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>offer</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-V2-06-从头到尾打印链表</title>
    <url>/2022/10/27/%E5%89%91%E6%8C%87offer-V2-06-%E4%BB%8E%E5%A4%B4%E5%88%B0%E5%B0%BE%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p><a href="https://leetcode.cn/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof/">原题点这里</a></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202210271306232.png" /></p>
<span id="more"></span>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>相当于逆转链表，直接递归。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reversePrint</span><span class="params">(head *ListNode)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">append</span>(reversePrint(head.Next), []<span class="type">int</span>&#123;head.Val&#125;...)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>offer</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>offer</tag>
      </tags>
  </entry>
  <entry>
    <title>6.Mechanism: Limited Direct Execution</title>
    <url>/2022/10/27/6-Mechanism-Limited-Direct-Execution/</url>
    <content><![CDATA[<h2 id="6-Mechanism-Limited-Direct-Execution"><a href="#6-Mechanism-Limited-Direct-Execution" class="headerlink" title="6.Mechanism: Limited Direct Execution"></a>6.Mechanism: Limited Direct Execution</h2><ul>
<li>受限制的直接执行。</li>
<li>虚拟化CPU的基本思想：让一个线程上CPU运行一会，下来再让另一个上CPU运行，通过<strong>time sharing</strong>的方法来实现。</li>
<li>两个问题：<ul>
<li>第一是性能：实现虚拟化时如何能让系统不用额外的开销？</li>
<li>第二是控制：如何在高效运行线程时OS可以重新获得对CPU的控制？</li>
</ul>
</li>
</ul>
<span id="more"></span>
<h3 id="6-1-Limited-Direct-Execution"><a href="#6-1-Limited-Direct-Execution" class="headerlink" title="6.1 Limited Direct Execution"></a>6.1 Limited Direct Execution</h3><ul>
<li>为了解决上述两个问题可采用Limited Direct Execution的方法。</li>
<li>先看什么是Direct Execution：单纯地让程序直接运行在CPU上。按照第四章的说法，OS需要在process list中创建进程入口，分配内存，加载代码到内存中，定位程序入口（main函数之类的），然后开始运行，流程如如下：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220325091511.png" style="zoom:67%;" /></p>
<ul>
<li>这种方法的问题来了：<ul>
<li>第一，如果像这样仅仅运行程序，OS怎么能够确保程序不做一些OS不想让程序做的事？</li>
<li>第二，在运行程序时，OS如何停止当前进程，让另外一个进程上CPU运行，从而实现<strong>time sharing</strong>来虚拟化CPU呢？</li>
</ul>
</li>
<li>所以我们应该再谈谈”limited”。</li>
</ul>
<h3 id="6-2-Problem-1-Restricted-Operations"><a href="#6-2-Problem-1-Restricted-Operations" class="headerlink" title="6.2  Problem #1: Restricted Operations"></a>6.2  Problem #1: Restricted Operations</h3><ul>
<li><p>Direct Execution是很快没错，但是有个问题：如果进程想执行一些受限制的操作该怎么办？例如提出I/O请求来读写磁盘或者进程想使用更多的系统资源如CPU或内存？也就是说如何能够让进程去执行这些操作，但是又不把整个系统的控制权交给该进程？</p>
</li>
<li><p>先看看一种可行但是不安全实际也不会使用的方法：当进程运行时，让该进程可以执行它想执行的相关操作。明白人都知道，这种做法很不安全。因为这样该进程就可以读写整个磁盘，还谈何保护呢？</p>
</li>
<li>所以我们来看一种实际可行的方法。将处理器也就是CPU分成两种模式，<strong>user mode</strong>和<strong>kernel mode</strong>。<ul>
<li><strong>user mode</strong>：运行在user mode的代码的操作是受限的。比如在user mode的时候，进程是不能发起I/O请求的，如果它这么做了，就会导致异常，OS就会杀死该进程。</li>
<li><strong>kernel mode</strong>：OS运行在kernel mode下，在这个模式下的代码可以执行他们想执行的任何操作，包括一些特权操作，比如发起I/O请求操作等。</li>
</ul>
</li>
<li>问题又来了，在这种设定模式下，用户的线程想执行特权操作的时候，比如读写磁盘，那应该怎么办呢？<ul>
<li>解决方法：实际上现代硬件，都给用户的程序提供了执行<strong>system call</strong>的能力。</li>
<li><strong>system call</strong>实际上给user mode的进程提供了一种方法，用于访问只有在Kernel mode才能访问的资源。</li>
</ul>
</li>
<li>执行system call，程序必须执行一条叫<strong>trap</strong>的指令。这条指令用于转换到Kernel mode，这样系统就可以执行该程序想做的特权操作了。完成之后，OS调用一条叫<strong>return-from-trap</strong>的指令，返回到该程序，并且返回user mode。</li>
<li>执行trap的时候，硬件要做一些事情来确保保存好进程的寄存器，这样当OS调用return-from-trap的时候，才能恢复该进程的信息。例如在X86中，处理器会将程序的寄存器、flags、PC保存到每个程序的<strong>kernel stack</strong>中，当return-from-trap指令返回时，再从栈中pop出保存的值用于回复进程信息。其他系统做法不同，但核心思想相同。</li>
</ul>
<hr>
<ul>
<li>现在我们解决了和权限有关的问题，但是新的风暴已经出现，那就是trap指令如何知道，在换到kernel mode的时候OS要运行什么代码呢？明白人又知道了，那肯定不能由发起trap指令的进程说了算，因为这不安全。</li>
<li>解决办法就是<strong>trap table</strong>。<strong>trap table</strong>在启动时就设置好了。机器在启动时，在kernel mode下设置，因此可以根据硬件需要来配置机器。<strong>trap  table</strong>里设置了当一些trap指令被调用时，应该运行什么代码来处理。比如当键盘输入或者有磁盘终端时应该做些什么。那么OS就让硬件记住了这些<strong>trap handlers</strong>的位置，硬件会记住这些<strong>trap handlers</strong>的位置直到下次重启。这就回答了上一个问题，当系统调用和其他的异常时间发生时硬件应该去执行什么代码。</li>
<li>系统调用千千万，如何直到当前进程想发起哪个系统调用呢？答案是<strong>system-call number</strong>，用于指定系统调用。</li>
<li><strong>trap table</strong> 有了，硬件也可以去记住他，但是怎么告诉硬件trap table在哪里呢？不能说让用户来告诉硬件吧？所以明白人又懂了，这也是一个特权操作。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220326161917.png" style="zoom:80%;" /></p>
<ul>
<li>图6.2表明了整个工作流程。在Limited direct execution（<strong>LDE</strong>）中有两个阶段。<ul>
<li>第一阶段，kernel初始化trap table，CPU记住它的位置，以便后续使用 。</li>
<li>第二阶段，kernel做些设置以便准备让程序上CPU运行，然后执行<strong>return-from-trap</strong>，转换到user mode，程序开始运行。如果程序想执行特权操作，那么就要发起system call，然后执行trap指令，保存当前进程状态，然后把CPU还给OS，进入kernel mode，执行特权操作。然后就是返回，恢复进程，进程正常结束，OS释放内存。</li>
</ul>
</li>
</ul>
<h3 id="6-3-Problem-2-Switching-Between-Processes"><a href="#6-3-Problem-2-Switching-Between-Processes" class="headerlink" title="6.3 Problem #2: Switching Between Processes"></a>6.3 Problem #2: Switching Between Processes</h3><ul>
<li>我们已经直到了如何保护整个系统，程序在CPU上运行的流程应该时怎么样的，现在就该考虑下另一个问题了。我们想要虚拟化CPU，那就要在不同进程之间切换上CPU，那么如何做呢？</li>
<li>想想好像很简单，先让一个下去再让另一个上来呗。当一个进程在CPU上运行时，OS是没有在CPU上运行的。但是要让一个进程上CPU又必须是由OS指定的，但是OS不在运行，这怎么办呢？</li>
<li>所以要解决的问题就是，要想让别的进程上CPU就要让OS重获对CPU的控制。</li>
</ul>
<h4 id="6-3-1-A-Cooperative-Approach-Wait-For-System-Calls"><a href="#6-3-1-A-Cooperative-Approach-Wait-For-System-Calls" class="headerlink" title="6.3.1 A Cooperative Approach: Wait For System Calls"></a>6.3.1 A Cooperative Approach: Wait For System Calls</h4><ul>
<li>要想解决上述问题，一种过去的OS采用的做法是cooperative的方法。这种方法下，OS是信任进程的，OS相信进程可以规范他们的行为。也就是说运行太长的进程会定期地放弃CPU，通过系统调用；或者当程序出错的时候，会执行trap指令，这样CPU就重获了对CPU的控制。但是如果程序死循环呢？如果程序永远也不愿意下来呢？</li>
</ul>
<h4 id="6-3-2-A-Non-Cooperative-Approach-The-OS-Takes-Control"><a href="#6-3-2-A-Non-Cooperative-Approach-The-OS-Takes-Control" class="headerlink" title="6.3.2 A Non-Cooperative Approach: The OS Takes Control"></a>6.3.2 A Non-Cooperative Approach: The OS Takes Control</h4><ul>
<li>靠进程自觉不行，那就强制要求呗。如果不强制要求，进程陷入死循环永远不下CPU你就只能重启机器了。</li>
<li>这里我们就采用<strong>timer interrupt</strong>的方法。也就是说一个进程没运行一段时间就必须中断，这样它就下CPU了。当该中断发起时，就代表你该下了，另外一个进程该上了。</li>
<li>也就是说像之前讨论的那样，机器启动时，OS就告诉了硬件当timer interrupt的时候应该执行什么代码。在启动时，OS就起一个timer，这样OS才能重获对CPU的控制。</li>
<li>当timer interrupt的时候，应该保存当前进程的信息，比如寄存器信息等，这样下次该进程才能被恢复重新上CPU。</li>
</ul>
<h4 id="6-3-3-Saving-and-Restoring-Context"><a href="#6-3-3-Saving-and-Restoring-Context" class="headerlink" title="6.3.3 Saving and Restoring Context"></a>6.3.3 Saving and Restoring Context</h4><ul>
<li>当timer interrupt时，通过scheduler（会在之后讲）来决定是当前进程继续上还是换一个上。如果是换一个进程上的话，那么也就是执行<strong>context switch</strong>操作，这是由低层的代码实现的。</li>
<li>context swich的本质就是保存信息并且恢复信息，即保存当前进程的一些信息，恢复即将上CPU的另一个进程的信息。首先将当前进程的寄存器信息保存到进程自己的kernel stack中，然后再恢复下一个进程的kernel stack信息。</li>
<li>当然OS还要保存下别的信息，保存当前进程的通用寄存器、PC以及该进程的kernel stack指针，然后恢复下一个进程的这些信息。</li>
<li>流程如下：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220326165400.png" style="zoom:80%;" /></p>
<h3 id="6-4-有关并发"><a href="#6-4-有关并发" class="headerlink" title="6.4 有关并发"></a>6.4 有关并发</h3><ul>
<li>聪明的你可能会问了，如果在处理中断的时候另一个中断发生了怎么办？其实这是之后在并发章节会讨论的事情，现在只需要直到当处理中断的时候，是不会允许其他中断的。</li>
</ul>
<h3 id="6-5-总结"><a href="#6-5-总结" class="headerlink" title="6.5 总结"></a>6.5 总结</h3><ul>
<li>这章的重点就是，第一程序如何运行，第二进程怎么切换。</li>
<li>我们通过LED来实现虚拟换CPU，其实就是让一个程序上CPU，但是留一手，通过timer让它不能一直运行。</li>
<li>那么如何选择下一个上CPU的进程？这是之后的章节讨论的问题了。</li>
</ul>
]]></content>
      <categories>
        <category>Operating System</category>
        <category>Virtualization</category>
        <category>Cpu</category>
      </categories>
      <tags>
        <tag>Operating System</tag>
        <tag>Virtualization</tag>
        <tag>Cpu</tag>
      </tags>
  </entry>
  <entry>
    <title>4.The Abstraction:The Process</title>
    <url>/2022/10/27/4-The-Abstraction-The-Process/</url>
    <content><![CDATA[<h2 id="4-The-Abstraction-The-Process"><a href="#4-The-Abstraction-The-Process" class="headerlink" title="4.The Abstraction: The Process"></a>4.The Abstraction: The Process</h2><ul>
<li>线程的定义：正在运行的程序。</li>
<li>问题来了：如何提供有许多CPU的假象？</li>
<li>答：通过虚拟化的技术来制造有许多CPU的假象。即通过<strong>time sharing</strong>的方式。</li>
<li>为了实现虚拟化，OS提供了低层和高层的一些机制。</li>
<li>低层上主要是提供用来实现功能的方法和协议。比如，提供了如何实现<strong>context switch</strong>来使OS停止运行一个程序从而运行另外一个程序。</li>
<li>高层上主要是提供了一些智能的policies。policies其实就是一些OS用于做决定的算法。比如说现在有一堆程序，先让哪个程序上CPU运行？在OS上有一系列的算法来决定这些事情。</li>
</ul>
<span id="more"></span>
<h3 id="4-1-什么是线程？"><a href="#4-1-什么是线程？" class="headerlink" title="4.1 什么是线程？"></a>4.1 什么是线程？</h3><ul>
<li>操作系统提供一种抽象被称为线程，用于运行程序。</li>
<li>为了明白线程是有什么组成的，我们必须先谈谈<strong>machine state</strong>：即当一个程序处于运行时，它可以读取或者更新什么？</li>
<li>第一个组成线程的<strong>machine state</strong>就是内存(<strong>memory</strong>)。指令存在内存中，程序读写的数据存在内存中。</li>
<li>第二个组成线程的<strong>machine state</strong>是寄存器(<strong>registers</strong>)。许多指令都读取或者更新寄存器，因此寄存器很重要。<ul>
<li>有许多特殊的寄存器，比如<strong>program counter(PC)</strong>，用于表明程序的下一条指令在哪里；<strong>stack pointer</strong>和<strong>frame pointer</strong>用于管理函数的参数、变量和返回值的地址。</li>
</ul>
</li>
<li>第三个组成线程的<strong>machine state</strong>是<strong>I/O information</strong>。其中包含了一系列的进程正在打开的文件。</li>
</ul>
<h3 id="4-2-进程的接口"><a href="#4-2-进程的接口" class="headerlink" title="4.2 进程的接口"></a>4.2 进程的接口</h3><ul>
<li>以下接口为OS必须为进程提供的一些接口：</li>
<li><strong>Create</strong>：OS必须提供一些方法来创建新的进程。</li>
<li><strong>Destory</strong>：既然我们可以创建，那必须可以强制销毁一个进程。正常情况下，进程应该主动退出，但是一旦有异常发生，我们需要强制销毁一个进程。</li>
<li><strong>Wait</strong>：当一个进程停止运行的时候，OS应该提供wait接口。</li>
<li><strong>Miscellaneous Control</strong>：相当于是一些操作的结合体，比如先停止一个进程，等待一会后再将其恢复运行。</li>
<li><strong>Status</strong>：用于查看一个进程的信息，比如运行了多久或者出于什么状态。</li>
</ul>
<h3 id="4-3-进程创建的细节"><a href="#4-3-进程创建的细节" class="headerlink" title="4.3 进程创建的细节"></a>4.3 进程创建的细节</h3><ul>
<li>提问：如何将一个程序转变为进程？更明确的问，OS如何启动或停止一个进程？进程创建是如何工作的？</li>
<li>第一，在OS运行一个程序前需要从磁盘（或者固态）中，加载源代码和静态数据到内存中（或者叫进程的地址空间）。<ul>
<li>早期OS中，加载线程是热加载，在运行前全部加载进来；现代OS一般是懒加载，只加载程序运行需要的部分。</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220322212127.png" style="zoom: 50%;" /></p>
<ul>
<li>第二，在加载完源代码和静态数据后，OS需要将一部分内存分配给进程的<strong>stack</strong>。比如在C中，局部变量，函数参数，返回值的地址都是在stack中。</li>
<li>第三，除了要给程序分配<strong>stack</strong>，还要给程序分配<strong>heap</strong>，<strong>heap</strong>用于动态分配的数据。比如通过malloc()函数分配、free()函数销毁的空间，列表、哈希表、树之类的数据结构。因为是动态分配的，所以heap一开始可能很小。</li>
<li>第四，OS还需要做一些和I/O有关的初始化。比如在Unix中，每个进程默认都有三个打开文件描述符，用于标准输入、输出、错误。</li>
<li>在经历过加载源代码和静态数据、分配stack、分配heap以及I/O初始化之后，finally OS把执行程序的环境搞好了。但是还有最后一件事，让程序在entry point处开始运行，也就是main()。在跳到main()入口后，OS终于让这个程序上了CPU，开始其进程的一生。</li>
</ul>
<h3 id="4-4-进程的状态"><a href="#4-4-进程的状态" class="headerlink" title="4.4 进程的状态"></a>4.4 进程的状态</h3><ul>
<li>一般来说有以下三种最基础的状态：</li>
<li>Running：进程正在处理器上运行。</li>
<li>Ready：进程已经准备好上CPU，但是OS还允许它上。</li>
<li><p>Blocked：由于进程需要完成某些操作，导致它还没有Ready。比如在等待I/O操作。</p>
</li>
<li><p>状态之间的转换：</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220322212315.png" style="zoom:67%;" /></p>
<h3 id="4-5-数据结构"><a href="#4-5-数据结构" class="headerlink" title="4.5 数据结构"></a>4.5 数据结构</h3><ul>
<li>OS也是程序，因此它有一些数据结构。比如，为了追踪进程的状态，OS会保存running、ready、blocked的process list。</li>
<li>比如在xv6中，OS需要追踪的数据结构：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220322213001.png" style="zoom:67%;" /></p>
<ul>
<li><p>其中保存了 <strong>register context</strong>，用于保存一个停止进程的寄存器内容。当一个进程停止时，其寄存器信息会保存在内存中，只要将寄存器恢复，那么进程就能回复继续运行，也就是后面会说的<strong>context switch</strong>。</p>
</li>
<li><p>Process list用于保存正在运行的进程的信息，是一种比较简单的数据结构。还有别的比如说<strong>PCB</strong>(Process Control Block)。</p>
</li>
</ul>
<h3 id="4-6-总结"><a href="#4-6-总结" class="headerlink" title="4.6 总结"></a>4.6 总结</h3><ul>
<li>我们知道了OS最基本的抽象：进程，它是运行着的程序。</li>
<li>知道了进程，再来看看本质：低层的mechanisms和高层的policies，mechanisms用于怎么实现，policies用于如何规划。二者结合在一起我们才能理解OS如何虚拟化CPU。</li>
</ul>
]]></content>
      <categories>
        <category>Operating System</category>
        <category>Virtualization</category>
        <category>Cpu</category>
      </categories>
      <tags>
        <tag>Operating System</tag>
        <tag>Virtualization</tag>
        <tag>Cpu</tag>
      </tags>
  </entry>
  <entry>
    <title>7.Scheduling: Introduction</title>
    <url>/2022/10/27/7-Scheduling-Introduction/</url>
    <content><![CDATA[<h2 id="7-Scheduling-Introduction"><a href="#7-Scheduling-Introduction" class="headerlink" title="7.Scheduling: Introduction"></a>7.Scheduling: Introduction</h2><ul>
<li>前面我们了解了低层的用于运行进程的机制，现在该来谈一谈高层的policy来决定如何调度进程上CPU了。这章就来学习下调度进程的算法。</li>
</ul>
<span id="more"></span>
<h3 id="7-1-Workload-Assumptions"><a href="#7-1-Workload-Assumptions" class="headerlink" title="7.1 Workload Assumptions"></a>7.1 Workload Assumptions</h3><ul>
<li>在往下走之前，我们先做一些假设，有关于在系统中运行的进程的假设，这些假设我们叫做<strong>workload</strong>。当然我们做的这些假设其实在OS中是不切实际不现实的，但是随着深入下去，我们会逐渐接近实际情况，逐渐打破这些假设。</li>
<li>我们也经常把进程叫做<strong>job</strong>，对job我们做出如下五个假设：<ul>
<li>1.每个job运行时间相等</li>
<li>2.所有job都在同一时间到达</li>
<li>3.一旦job开始运行，就运行到job完成</li>
<li>4.所有的job都只使用CPU（也就是说没有I/O请求）</li>
<li>5.Job的运行时长已知</li>
</ul>
</li>
</ul>
<h3 id="7-2-Scheduling-Metrics"><a href="#7-2-Scheduling-Metrics" class="headerlink" title="7.2 Scheduling Metrics"></a>7.2 Scheduling Metrics</h3><ul>
<li>既然是调度算法，那么就要有一个调度指标，根据这个调度指标来决定让哪个进程上CPU。</li>
<li>首先我们使用一个最简单的调度指标：<strong>turnaround time</strong>（周转时间）。周转时间的定义为，job的完成时间减去job到达系统的时间：<script type="math/tex">T_{turnaround}=T_{completion} - T_{arrival}</script>。因为我们假设所有job同时到达系统，也就是说<script type="math/tex">T_{arrival}=0</script>，因此 <script type="math/tex">T_{turnaround}=T_{completion}</script>。</li>
<li>注意，周转时间是一种<strong>performance</strong>的指标，是我们这一章首要考虑的。另一种指标考虑的是<strong>fairness</strong>。这两种指标好比鱼与熊掌，不可得兼。</li>
</ul>
<h3 id="7-3-First-In-First-Out-FIFO"><a href="#7-3-First-In-First-Out-FIFO" class="headerlink" title="7.3 First In, First Out (FIFO)"></a>7.3 First In, First Out (FIFO)</h3><ul>
<li>最基本的算法<strong>First In, First Out (FIFO)</strong>，有时也叫 <strong>First Come, First Served (FCFS)</strong>。过于简单不多赘述。优点是简单易实现。</li>
<li>假设A、B、C几乎同时到达，但是FIFO是挑一个先到达的，所以假设A比B先一点，B比C先一点。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220328161849.png" style="zoom:80%;" /></p>
<ul>
<li>此种情况下，计算每个job的平均周转时间：<script type="math/tex">\frac{10+20+30}{3}=20</script>。</li>
<li>现在让我们打破第一个假设，即不再认为所有job都运行相同的时间，这种情况下FIFO的性能有时就不是很好。例如以下情况：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220328162231.png" style="zoom:80%;" /></p>
<ul>
<li>此种情况下，计算每个job的平均周转时间：<script type="math/tex">\frac{100+110+120}{3}=110</script>。</li>
<li>这种问题叫 <strong>convoy effect</strong>（护航效应），就是说对资源占用较少的job排在了对资源占用较多的job后面。那咋办呢？且看下一种算法。</li>
</ul>
<h3 id="7-4-Shortest-Job-First-SJF"><a href="#7-4-Shortest-Job-First-SJF" class="headerlink" title="7.4 Shortest Job First (SJF)"></a>7.4 Shortest Job First (SJF)</h3><ul>
<li>短作业优先，顾名思义，运行时间短的job先上CPU运行。</li>
<li>在之前的例子上，可得到如下图运行顺序：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220328211902.png" style="zoom:80%;" /></p>
<ul>
<li><p>计算每个job的平均周转时间：<script type="math/tex">\frac{10+20+120}{3}=50</script>。</p>
</li>
<li><p>在我们假设所有job同时到达的情况下，SJF是一个优化的调度策略。但实际情况下往往不是所有job同时到达的。</p>
</li>
<li>现在让我们打破假设2，即job有可能在任何时刻到达，这种情况下应该怎么办？如果用SJF可能会出现以下情况，A先到，B、C在10s到，且A运行100s，B、C分别运行10s：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220328213101.png" style="zoom:80%;" /></p>
<ul>
<li>这时每个job的平均周转时间：<script type="math/tex">\frac{100+(110-10)+(120-10)}{3}=103.33</script>。</li>
</ul>
<h3 id="7-5-Shortest-Time-to-Completion-First-STCF"><a href="#7-5-Shortest-Time-to-Completion-First-STCF" class="headerlink" title="7.5 Shortest Time-to-Completion First (STCF)"></a>7.5 Shortest Time-to-Completion First (STCF)</h3><ul>
<li>为了解决上面这种情况，考虑到我们之前学过的timer interrupt和context switch我们采用新的算法<strong>Shortest Time-to-Completion First (STCF)</strong>或者叫<strong>Preemptive Shortest Job First (PSJF)</strong> 。也就是抢占式的SJF，即当一个job到达时，如果它的运行时间短，那可以抢占当前job正在使用的CPU。</li>
<li>在之前的例子上，如下图：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220328213624.png" style="zoom:80%;" /></p>
<ul>
<li>这时每个job的平均周转时间：<script type="math/tex">\frac{(120-0)+(20-10)+(30-10)}{3}=50</script>。</li>
</ul>
<h3 id="7-6-A-New-Metric-Response-Time"><a href="#7-6-A-New-Metric-Response-Time" class="headerlink" title="7.6 A New Metric: Response Time"></a>7.6 A New Metric: Response Time</h3><ul>
<li>如果我们知道job的运行时间并且job仅仅使用CPU的话，那么周转时间是我们唯一的指标，STCF是一个很好的策略。但事实上，坐在终端前的用户希望能够和系统进行交互，因此我们必须考虑另一个指标：<strong>response time</strong>（响应时间）。</li>
<li>响应时间的定义为job第一次上CPU的时间减去job到达系统的时间：<script type="math/tex">T_{response}=T_{firstrun} - T_{arrival}</script>。</li>
<li>对图7.5，A的响应时间为0，B为0，C为10。</li>
<li>之前的STCF对于考虑周转时间的情况下是很好的，但是却不利用响应时间，你想想你要是C的用户，你的程序要10s才能得到响应，你急不急？所以我们应该使用一种对于响应时间敏感的算法。</li>
</ul>
<h3 id="7-7-Round-Robin"><a href="#7-7-Round-Robin" class="headerlink" title="7.7  Round Robin"></a>7.7  Round Robin</h3><ul>
<li>为了解决上述问题，采用 <strong>Round Robin（RR）</strong>的算法。基本思想就是不让每个job运行到它技术，每个job在CPU上都只能运行一个时间片（<strong>time slice</strong>有时也叫<strong>scheduling quantum</strong>），然后换下一个job上来运行。重复以上直到所有job运行结束。注意，时间片的长度必须是timer interrupt的倍数。</li>
<li>举个栗子，A、B、C同时到达，每个都要运行5s。SJF算法运行图如7.6，RR算法运行图如7.7：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220328215527.png" style="zoom:80%;" /></p>
<ul>
<li>RR算法每个job的平均响应时间：<script type="math/tex">\frac{0+1+2}{3}=1</script>，SJF算法每个job的平均响应时间：<script type="math/tex">\frac{0+5+10}{3}=5</script>，只能说高下立判。</li>
<li>RR算法中，时间片的长度太长或者太短都不行。<ul>
<li>如果太短了，那么context switch的代价会影响整个性能。</li>
<li>如果太长了，那么回到了老问题，响应时间太长。</li>
</ul>
</li>
<li>举个栗子，还是上面的ABC，看图7.7，A在13s结束，B在14s结束，C在15s结束，其实很差劲。如果考虑周转时间的话，RR真的拉跨。又回到了那句话，performance和fairness不能得兼。</li>
</ul>
<h3 id="7-8-Incorporating-I-O"><a href="#7-8-Incorporating-I-O" class="headerlink" title="7.8 Incorporating I/O"></a>7.8 Incorporating I/O</h3><ul>
<li>现在该打破第四个假设了，也就是说程序是需要I/O操作的。</li>
<li>那么程序在等待I/O的时候，其实CPU是空闲的，进程是blocked的。那么这时就应该安排别的进程上CPU，等待I/O的进程等到I/O结果了，再恢复该进程。</li>
<li>举个栗子，A、B各需要50msCPU，区别在于，A每10ms就发起一次I/O请求，B不需要I/O。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220329000554.png" style="zoom:80%;" /></p>
<ul>
<li>假设我们用的是STCF，很明显，这时CPU的利用率是很低的。所以应该充分利用CPU，像下面这样：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220329000716.png" style="zoom:80%;" /></p>
<h3 id="7-9-No-More-Oracle"><a href="#7-9-No-More-Oracle" class="headerlink" title="7.9 No More Oracle"></a>7.9 No More Oracle</h3><ul>
<li>现在该打破最后一个假设了，也就是说调度器不知道每个job需要运行时长。这个时候SJF/STCF都不好用了，RR也是一样。别着急后续会讲。</li>
</ul>
<h3 id="7-10-Summary"><a href="#7-10-Summary" class="headerlink" title="7.10 Summary"></a>7.10 Summary</h3><ul>
<li>两个调度指标周转时间和响应时间，不可得兼。</li>
<li>针对两者，对应有不同的算法。</li>
</ul>
]]></content>
      <categories>
        <category>Operating System</category>
        <category>Virtualization</category>
        <category>Cpu</category>
      </categories>
      <tags>
        <tag>Operating System</tag>
        <tag>Virtualization</tag>
        <tag>Cpu</tag>
      </tags>
  </entry>
  <entry>
    <title>8.Scheduling: The Multi-Level Feedback Queue</title>
    <url>/2022/10/27/8-Scheduling-The-Multi-Level-Feedback-Queue/</url>
    <content><![CDATA[<h2 id="8-Scheduling-The-Multi-Level-Feedback-Queue"><a href="#8-Scheduling-The-Multi-Level-Feedback-Queue" class="headerlink" title="8.Scheduling: The Multi-Level Feedback Queue"></a>8.Scheduling: The Multi-Level Feedback Queue</h2><ul>
<li>书接上回，我们来看看如何平衡两个调度指标，即周转时间和响应时间。</li>
<li>采用 <strong>Multi-level Feedback Queue (MLFQ)</strong>，解决了两个问题：<ul>
<li>第一，优化了周转时间。</li>
<li>第二，同时兼顾了响应时间。</li>
</ul>
</li>
</ul>
<span id="more"></span>
<h3 id="8-1-MLFQ-Basic-Rules"><a href="#8-1-MLFQ-Basic-Rules" class="headerlink" title="8.1 MLFQ: Basic Rules"></a>8.1 MLFQ: Basic Rules</h3><ul>
<li>MLFQ有不同的实现方式，但是基本思想是一致的。</li>
<li>在我们的方法中，MLFQ有多个队列，每个队列有不同的优先级。在任意之间点，处于ready状态的job只能处于一个队列中。MLFQ根据队列的优先级来决定运行哪一个job：优先级高的job可以先上CPU运行。当然，一个队列中可能有多个job，那么我们就采用RR的算法来运行处于统一队列中的job。</li>
<li>因此，MLFQ的两条基本规则：<ul>
<li><strong>Rule 1</strong>: If Priority(A) &gt; Priority(B), A runs (B doesn’t) </li>
<li><strong>Rule 2</strong>: If Priority(A) = Priority(B), A &amp; B run in RR</li>
</ul>
</li>
<li>举个栗子：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220330181943.png" style="zoom:80%;" /></p>
<ul>
<li>在上图中，由于A、B优先级高，所有A、B会以RR的方式轮流使用CPU，而可怜的C和D永远也使用不了CPU—an outrage！</li>
<li>所以咋办？答案就是优先级不能是定死的，也就是说每个job的优先级是需要动态改变的。那根据什么规则来改变呢？可以根据每个job的历史行为来预测它未来的状态，根据历史来改变它的优先级。比如，如果一个job一直在让出CPU，因为它在不停等待键盘输入，那么就要提高它的优先级，因为当前该job正在和用户交互，要缩小响应时间；再比如，如果一个job长时间地使用CPU，那么就要适当减低它的优先级，因为要考虑到别的job。</li>
</ul>
<h3 id="8-2-Attempt-1-How-To-Change-Priority"><a href="#8-2-Attempt-1-How-To-Change-Priority" class="headerlink" title="8.2 Attempt #1: How To Change Priority"></a>8.2 Attempt #1: How To Change Priority</h3><ul>
<li>在给出答案之前，我们明确：需要交互式的job一般是运行时间短的（并且有可能会经常退出CPU），运行时间长的job一般需要长时间的CPU也就是说响应时间没那么重要。</li>
<li>这里尝试第一次给出改变优先级的规则：<ul>
<li><strong>Rule 3</strong>：当一个job到达系统的时候，被放进优先级最高的队列。</li>
<li><strong>Rule 4</strong>：如果一个job在运行时，使用完了分给它的整个时间片，那就降低它的优先级（把他移到下一级队列）。</li>
<li><strong>Rule 5</strong>：如果一个job在时间片用完之前就让出了CPU，那么保持它的优先级不动。</li>
</ul>
</li>
<li>举个栗子：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220330183313.png" style="zoom:80%;" /></p>
<ul>
<li>如果有短job来了咋办？再举个栗子：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220330183359.png" style="zoom:80%;" /></p>
<ul>
<li>I/O咋办？再举个栗子，灰色job不停的需要I/O操作。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220330183706.png" style="zoom:80%;" /></p>
<ul>
<li>现在的MLFQ的问题：<ul>
<li>第一，<strong>starvation</strong>，也就是饥饿。如果系统中存在大量的交互性job，也就是说有很多的job，它们由于需要I/O操作一直停留在优先级高的队列中，那么优先级低的队列中的job永远得不到执行，饿死啦！</li>
<li>第二，<strong>game the scheduler</strong>，也就是恶意程序把调度器骗了。想象一下，如果一个job在使用完99%的时间片后就发起一次I/O请求，根据我们的<strong>Rule5</strong>，因为它没有使用完时间片所以它会保持优先级不变，那么它就有可能永远停留在优先级最高的队列中。</li>
<li>第三，一个job的行为是可能发生<strong>变化</strong>的。比如说，一个job可能前期大量使用CPU，后期就变成需要交互性的了。因为之前它大量使用CPU，可能它已经到了优先级最低的队列，但此时它又需要大量I/O和用户交互，那么此时的响应时间就会很高。</li>
</ul>
</li>
</ul>
<h3 id="8-3-Attempt-2-The-Priority-Boost"><a href="#8-3-Attempt-2-The-Priority-Boost" class="headerlink" title="8.3 Attempt #2: The Priority Boost"></a>8.3 Attempt #2: The Priority Boost</h3><ul>
<li><p>为了解决上述问题，我们重写<strong>Rule 5</strong>，思想很简单，每隔一段时间增加所有job的优先级。做法有很多，我们采取最简单的：每隔一段时间，就把所有的job都放到优先级最高的队列中。</p>
<ul>
<li><strong>Rule 5</strong>：在周期<strong>S</strong>后，将系统中的所有job移到优先级最高的队列中。</li>
</ul>
</li>
<li><p>这种做法解决了上述的两个问题：</p>
<ul>
<li><p>第一，解决了饥饿问题。看下图，左边没有增加优先级的时候，黑色job永远待在Q0，暗无天日。右图有了增加优先级，每隔一段时间所有job都会被移到优先级最高的队列，因此黑色job有了出头之日。</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220330190852.png" style="zoom:80%;" /></p>
</li>
<li><p>第二，解决了job的行为会发生变化的问题。如果一个job早期大量使用CPU，在后期又转变成了交互型的，那么由于这个规则，每隔一段时间它就被移到优先级最高的队列，因此该问题解决。</p>
</li>
</ul>
</li>
<li><p>那么<strong>S</strong>该如何设置？如果S过长，那么还是可能有饥饿现象，太短的话，交互型job可能不能很好的共享CPU。（一般采用黑魔法， 不懂）</p>
</li>
</ul>
<h3 id="8-4-Attempt-3-Better-Accounting"><a href="#8-4-Attempt-3-Better-Accounting" class="headerlink" title="8.4 Attempt #3: Better Accounting"></a>8.4 Attempt #3: Better Accounting</h3><ul>
<li>上面的做法很好，解决了两个问题，但是还有一个问题没有解决。如何应对恶意程序？</li>
<li>我们重写Rule 4a和Rule 4b，变成：<ul>
<li><strong>Rule 4</strong>：只要一个job使用了所在队列分配的一个时间片的时间，那么就降低它的优先级（不管它有没有在使用完一个时间片之前让出CPU）</li>
</ul>
</li>
<li>举个栗子：没有这种机制时，灰色程序就一直可以停留在最高级别的队列，</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220330192159.png" style="zoom:67%;" /></p>
<ul>
<li>有了这种机制，那么就变成：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220330192227.png" style="zoom:67%;" /></p>
<h3 id="8-5-Tuning-MLFQ-And-Other-Issues"><a href="#8-5-Tuning-MLFQ-And-Other-Issues" class="headerlink" title="8.5 Tuning MLFQ And Other Issues"></a>8.5 Tuning MLFQ And Other Issues</h3><ul>
<li>MLFQ还有一些问题，即如何设定调度器的参数？比如有多少个队列？每个队列的时间片长度应该是多少？定期增加优先级的周期应该是多少？等等这些问题，很不好解决，只能根据一些经验来设定，所以不赘述。</li>
</ul>
<h3 id="8-6-MLFQ-Summary"><a href="#8-6-MLFQ-Summary" class="headerlink" title="8.6 MLFQ: Summary"></a>8.6 MLFQ: Summary</h3><ul>
<li>优化后的MLFQ的规则：<ul>
<li><strong>Rule 1</strong>：如果A的优先级大于B，A可以运行。</li>
<li><strong>Rule 2</strong>：如果A、B优先级相等，A、B以RR的方式运行，时间片的长度由所在队列的等级决定。</li>
<li><strong>Rule 3</strong>：一个job进入系统时，放到最高级别的队列中。</li>
<li><strong>Rule 4</strong>：只要一个job使用了所在队列分配的一个时间片的时间，那么就降低它的优先级（不管它有没有在使用完一个时间片之前让出CPU）</li>
<li><strong>Rule 5</strong>：在周期<strong>S</strong>后，将系统中的所有job移到优先级最高的队列中。</li>
</ul>
</li>
<li>可以看出，MLFQ不需要知道一个job需要运行多久，而是根据job的历史行为来预测未来的行为；并且兼顾了周转时间和响应时间。</li>
</ul>
]]></content>
      <categories>
        <category>Operating System</category>
        <category>Virtualization</category>
        <category>Cpu</category>
      </categories>
      <tags>
        <tag>Operating System</tag>
        <tag>Virtualization</tag>
        <tag>Cpu</tag>
      </tags>
  </entry>
  <entry>
    <title>13. The Abstraction: Address Spaces</title>
    <url>/2022/10/27/13-The-Abstraction-Address-Spaces/</url>
    <content><![CDATA[<h1 id="13-The-Abstraction-Address-Spaces"><a href="#13-The-Abstraction-Address-Spaces" class="headerlink" title="13. The Abstraction: Address Spaces"></a>13. The Abstraction: Address Spaces</h1><h2 id="13-1-Early-Systems"><a href="#13-1-Early-Systems" class="headerlink" title="13.1 Early Systems"></a>13.1 Early Systems</h2><ul>
<li>从内存的角度来说，早期的机器并没有提供很多的抽象给用户，因此比较简单，如下图：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220402155011.png" style="zoom: 67%;" /></p>
<span id="more"></span>
<h2 id="13-2-Multiprogramming-and-Time-Sharing"><a href="#13-2-Multiprogramming-and-Time-Sharing" class="headerlink" title="13.2 Multiprogramming and Time Sharing"></a>13.2 Multiprogramming and Time Sharing</h2><ul>
<li>因为早期机器很贵，因此有了<strong>Multiprogramming</strong>的需求，需要充分利用CPU。</li>
<li>欲望是无穷的，人们又有了<strong>Time Sharing</strong>的需求。人与机器的交互也变得很重要，你不想机器不理你对吧。</li>
<li>如何实现<strong>Time Sharing</strong>呢？比较简单的方式是，让一个进程上CPU，并且给它内存所有的使用权限。运行一会后，停止运行，保存当前的所有信息到磁盘上，然后换下一个进程上来。这种方式当然可以，但是不够elegant，so crude！</li>
<li>问题就在于太慢啦！虽然保存寄存器信息很快，但是还有别的保存是很耗时的。所以我们要做的是让所有进程都保留在内存中，有效实现time sharing。如下图：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220402160122.png" style="zoom: 67%;" /></p>
<ul>
<li>问题又来了，多进程都在内存中，如何做到<strong>protection</strong>？一个进程不能读别的进程的内容吧，也不能修改吧。</li>
</ul>
<h2 id="13-3-The-Address-Space"><a href="#13-3-The-Address-Space" class="headerlink" title="13.3 The Address Space"></a>13.3 The Address Space</h2><ul>
<li>解决方法是对物理内存进行抽象，我们把这种抽象叫做<strong>Address Space</strong>。理解地址空间，就要理解是如何虚拟化内存的。</li>
<li>Address Space包含了运行程序的所有内存状态。主要是：<ul>
<li>code：即程序的代码，指令集。</li>
<li>stack：用于保存所有的局部变量、参数和返回值等。</li>
<li>heap：保存动态分配的内存。</li>
<li>其他</li>
</ul>
</li>
<li>如下图就是一个Address Space：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220402160742.png" style="zoom:67%;" /></p>
<ul>
<li>stack和heap一个从上往下，一个从下往上，这种做法并不是固定的。</li>
<li>在Address Space中，地址是从0KB到16KB的，但其实它并不是指真正物理内存的0KB到16KB。那么问题就来了，OS如何才能建立起这种对内存抽象呢？</li>
<li>建立抽象其实就是OS在虚拟化内存，OS这样做会让运行的程序认为，它真的被加载到物理内存的0KB到16KB了（经典欺骗进程）。举个栗子，当进程A试图从地址0开始加载时，其实并不是真的物理内存的0，而是它的地址空间的0，那么OS就要和硬件联手，把这个地址空间的0对应到物理内存的320KB去（因为A真的放在这）。</li>
</ul>
<h2 id="13-4-Goals"><a href="#13-4-Goals" class="headerlink" title="13.4 Goals"></a>13.4 Goals</h2><ul>
<li>虚拟化内存，我们要达到以下几个目标：</li>
<li>第一，虚拟内存（VM）系统是透明的，也就是说对程序是不可见的。程序意识不到自己的空间是假的，意识不到它的0不是真的0。</li>
<li>第二，VM的效率。OS应该尽可能的提高虚拟的效率，这就要靠硬件的支持了。</li>
<li>第三，保护。OS应该保护进程的信息不被其他进程读写，同样也应该保护OS的内存不被其他进程读写。也就是说各进程之间要隔离开来。</li>
</ul>
<h2 id="13-5-Summary"><a href="#13-5-Summary" class="headerlink" title="13.5 Summary"></a>13.5 Summary</h2><ul>
<li>VM系统提供大的、私人的地址空间给程序，用于保存进程自己的信息。</li>
<li>OS可以连同硬件一起，将虚拟的地址转化为物理地址。</li>
<li>OS还对不同进程提供保护，提供隔离性。</li>
<li>未完待续</li>
</ul>
]]></content>
      <categories>
        <category>Operating System</category>
        <category>Virtualization</category>
        <category>Memory</category>
      </categories>
      <tags>
        <tag>Operating System</tag>
        <tag>Virtualization</tag>
        <tag>Memory</tag>
      </tags>
  </entry>
  <entry>
    <title>17. Free-Space Management</title>
    <url>/2022/10/27/17-Free-Space-Management/</url>
    <content><![CDATA[<h1 id="17-Free-Space-Management"><a href="#17-Free-Space-Management" class="headerlink" title="17. Free-Space Management"></a>17. Free-Space Management</h1><ul>
<li>这节就接着上节来讲讲怎么进行内存管理。具体来说，我们要讨论的就是<strong>paging</strong>的概念。简单点的话，把内存分成固定大小的块，管理这些块即可。复杂点来说，当这些块的大小不固定时，变长时该如何管理？比如一个进程可能通过malloc()和free()来分配或销毁内存。还可能存在<strong>外部碎片</strong>的问题。</li>
<li><p>问题来了：如何在满足变长内存块的情况下进行内存管理？有什么策略可以用来最小化外部碎片？这些可用方法的时间和空间开销是多少？</p>
<span id="more"></span>
<h2 id="17-1-Assumptions"><a href="#17-1-Assumptions" class="headerlink" title="17.1 Assumptions"></a>17.1 Assumptions</h2></li>
<li><p>假设我们通过malloc()和free()来对内存进行分配和销毁：</p>
</li>
</ul>
<p>对于malloc()，接收一个size参数，用来代表需要分配多少字节的内存。</p>
<p>对于free()，接收一个指针作为参数，释放相关内存。那么free()怎么知道要释放多少的内存呢？稍后就知道了。</p>
<p>用<strong>free list</strong>，一种数据结构来管理空闲内存。</p>
<ul>
<li>再假设，我们只考虑外部碎片，不考虑内部碎片。</li>
<li>再假设，一旦内存分配给客户端了，就不再重定位到内存中别的位置，也就是说哦我们不考虑<strong>compaction</strong>。（虽然它很有用）</li>
<li>最后假设，分配器管理的都是连续的字节空间，并且我们假设该空间固定大小。</li>
</ul>
<h2 id="17-2-Low-level-Mechanisms"><a href="#17-2-Low-level-Mechanisms" class="headerlink" title="17.2 Low-level Mechanisms"></a>17.2 Low-level Mechanisms</h2><ul>
<li><strong>Splitting and Coalescing</strong></li>
</ul>
<p>有一个30字节的heap，它和free list 的对应关系如下：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220409093933.png" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220409093947.png" style="zoom:80%;" /></p>
<p>假设我们请求分配1个字节的空间，这是分配器就会采取<strong>splitting</strong>：找到满足要求的chunk，并且把它分成两块，第一块用于返回给caller，第二块继续保存在list中。那么就会变成这样：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220409094520.png" style="zoom:80%;" /></p>
<p>还是对于上述初始情况，假设我们调用free(10)会怎么样呢？如果简单的把10开始这个chunk加到list里去就是这种情况：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220409094759.png" style="zoom:80%;" /></p>
<p>这时，虽然总和可用是30字节，但是任何一个超过10字节的请求都会被拒绝，因为一个chunk最大可用是10。所以采用<strong>coalescing</strong>的方法，变成下面这样：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220409095214.png" style="zoom:80%;" /></p>
<p>有了coalescing，就可以保证最大程度利用内存。</p>
<ul>
<li><strong>Tracking The Size Of Allocated Regions</strong></li>
</ul>
<p>就像之前说的，free()函数只接收了一个指针参数，但是系统也可以知道该chunk有多大，然后把它加到free list中去，那么是如何做到的？</p>
<p>为了满足上述目的，分配器需要额外保存一点信息在<strong>header</strong>中。看个图：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220409095743.png" style="zoom: 67%;" /></p>
<p>假设malloc(20)，那么下面的20字节是分配用的空间，上面的header是为了加速释放内存用的，具体来说，header中包括：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220409100131.png" style="zoom: 67%;" /></p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220409100259.png" style="zoom:80%;" /></p>
<p>magic是用于提供额外的integrity和其他信息。当调用free时：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220409100536.png" style="zoom:80%;" /></p>
<p>在获得指向头部的指针后，就可以通过magic number来检查 assert(hptr-&gt;magic == 1234567) ，并且计算出要释放的区域的大小（20字节+header）。因此当用户申请N字节的内存时，不是找大小满足N的chunk，而是找大小满足N+header大小的chunk。</p>
<ul>
<li><strong>Embedding A Free List</strong></li>
</ul>
<p>假设内存空间一共4096字节，也就是4KB。对于free list，首先初始化，list中只有一个元素大小4096（减去header尺寸），list中的node：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220409104900.png" style="zoom:80%;" /></p>
<p>我们通过系统调用mmap()来构建heap，</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220409134613.png" style="zoom:80%;" /></p>
<p>运行代码之后，list中就有了一个元素，size是4096-8=4088。我们假设heap的虚拟地址是从16KB开始的，那么就像：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220409134906.png" style="zoom:80%;" /></p>
<p>假设用户请求分配100字节内存：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220409134958.png" style="zoom:80%;" /></p>
<p>注意每个header是8个字节，因为包含了两个整数，每个整数是4字节。也就是说，lib实际分配的是100+8=106字节。</p>
<p>假设heap的分配情况是这样：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220409135320.png" style="zoom:80%;" /></p>
<p>这时如果我们要释放中间那块chunk会发生什么？free(16500)也就是物理地址，free(16K+108+8)，也就是sptr指向的地方。free后就会把该chunk加到free list中去：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220409135640.png" style="zoom:80%;" /></p>
<p>现在list中就有两个chunk。</p>
<p>现在我们再释放剩下两个chunk：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220409135812.png" style="zoom:80%;" /></p>
<p>这种还没有合并，遍历list对相邻chunk进行合并，那么就是一个完整的heap了。</p>
<ul>
<li><strong>Growing The Heap</strong></li>
</ul>
<p>如果heap空间用完了咋办？可以通过系统效用，比如UNIX中sbrk来申请更多内存。</p>
<h2 id="17-3-Basic-Strategies"><a href="#17-3-Basic-Strategies" class="headerlink" title="17.3 Basic Strategies"></a>17.3 Basic Strategies</h2><ul>
<li>没有最好的策略，只能尽量采取合适的策略来减少外部碎片。</li>
<li><strong>Best Fit</strong>：找到大小最合适chunk分配。优点简单，缺点时间复杂度较高。</li>
<li><strong>Worst Fit</strong>：找到最大的chunk分配。优点可能减少了外部best fit带来的小的chunk，缺点时间复杂度较高。</li>
<li><strong>First Fit</strong>：找到第一个满足要求的chunk分配。优点速度快，缺点可能污染free list的开头。比如说一个很大的chunk分配给很小的内存申请。</li>
<li><strong>Next Fit</strong>：找到第二个满足要求的chunk分配。和first fit很像，避免污染开头。</li>
</ul>
<h2 id="17-4-Other-Approaches"><a href="#17-4-Other-Approaches" class="headerlink" title="17.4 Other Approaches"></a>17.4 Other Approaches</h2><ul>
<li><p>Segregated Lists</p>
</li>
<li><p>Buddy Allocation</p>
</li>
<li>Other Ideas</li>
</ul>
<h2 id="17-5-Summary"><a href="#17-5-Summary" class="headerlink" title="17.5 Summary"></a>17.5 Summary</h2><ul>
<li>介绍了很初级的内存分配器。</li>
</ul>
]]></content>
      <categories>
        <category>Operating System</category>
        <category>Virtualization</category>
        <category>Memory</category>
      </categories>
      <tags>
        <tag>Operating System</tag>
        <tag>Virtualization</tag>
        <tag>Memory</tag>
      </tags>
  </entry>
  <entry>
    <title>15. Mechanism: Address Translation</title>
    <url>/2022/10/27/15-Mechanism-Address-Translation/</url>
    <content><![CDATA[<h1 id="15-Mechanism-Address-Translation"><a href="#15-Mechanism-Address-Translation" class="headerlink" title="15. Mechanism: Address Translation"></a>15. Mechanism: Address Translation</h1><ul>
<li>提供即高效又能保持OS控制的虚拟化内存方法。</li>
<li>高效需要硬件的支持；控制意味着OS必须保证一个程序不能访问别的程序的内存空间，也不能访问OS的内存空间；最后还要灵活，也就是说一个程序想怎么使用地址空间都可以。</li>
<li><p>那么问题来了，对于虚拟化内存：如何高效？如何提供灵活性？如何控制程序不访问别的程序内存空间？如何高效地完成这一切？</p>
</li>
<li><p>采用一种叫做<strong>hardware-based address translation</strong>或者简称<strong>address translation</strong>。该方法的作用就是把虚拟地址转换成物理实际地址。这样，程序就好像拥有了私人内存一样，但其实是所有程序共享内存。</p>
<span id="more"></span>
<h2 id="15-1-Assumptions"><a href="#15-1-Assumptions" class="headerlink" title="15.1 Assumptions"></a>15.1 Assumptions</h2></li>
<li><p>第一，愚蠢的假设：假设用户的地址空间是连续放在物理内存中的。</p>
</li>
<li>第二，假设地址空间的大小小于物理内存的大小</li>
<li><p>第三，假设每个地址空间的大小都相等。</p>
</li>
<li><p>这些假设会随着学习的深入被逐个打破，因为每个都是不现实的。</p>
</li>
</ul>
<h2 id="15-2-An-Example"><a href="#15-2-An-Example" class="headerlink" title="15.2 An Example"></a>15.2 An Example</h2><ul>
<li>一个进程的地址空间如下图所示：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220405184720.png" style="zoom:80%;" /></p>
<p>它的三条指令可以等价于以下C语言代码：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220405184832.png" style="zoom:80%;" /></p>
<p>当这些指令运行时，从进程层面来说，发生了以下内存的读写：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220405185030.png" style="zoom:80%;" /></p>
<p>从程序的角度来看，地址空间时从地址0开始一直到地址16KB的，所有用到的内存地址都应该在这个范围里面。但是从虚拟化内存的角度来看，OS要把该进程放在物理内存中，那么问题来了：如何<strong>透明地</strong>在内存中重定位该进程？如何提供一种假象，虽然该进程在物理内存中可能是任意位置开始，但是使得该进程好像在物理内存中真的是从地址0开始的？</p>
<ul>
<li>一个物理内存实际的样子：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220405190107.png" style="zoom: 67%;" /></p>
<h2 id="15-3-Dynamic-Hardware-based-Relocation"><a href="#15-3-Dynamic-Hardware-based-Relocation" class="headerlink" title="15.3 Dynamic (Hardware-based) Relocation"></a>15.3 Dynamic (Hardware-based) Relocation</h2><ul>
<li>为了解决上述问题，采用一种叫做<strong>base and bounds</strong>或者<strong>dynamic relocation</strong>的方法。</li>
<li>具体做法是，每一个CPU中设置两个硬件寄存器，一个是<strong>base</strong>寄存器，一个是<strong>bounds</strong>寄存器(或者叫<strong>limit</strong>寄存器)。有了这两个寄存器就可以让我们把进程放在内存的任意位置，并且保证一个进程不会访问别的进程的物理内存空间。</li>
<li>当一个程序开始运行时，OS决定该进程应该放在物理内存的什么位置，并且把base寄存器的值设置为该进程在内存中的起始位置。在上述例子中，该进程在物理内存中实际是从32KB开始的，那么当该进程上CPU的时候，就应该把base寄存器设置为32KB。</li>
<li>当该进程运行时需要访问内存，产生了一个地址时，实际该地址是一个虚拟地址，是相对该进程的地址空间来的，那么如何将其转换为物理内存的实际地址呢？</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220405190426.png" style="zoom:80%;" /></p>
<p>也就是说，实际地址等于虚拟地址加上base寄存器中的地址。</p>
<p>对于上述进程的第一条指令：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220405190530.png" style="zoom:80%;" /></p>
<p>取该指令，PC值为128，那么这时候取该指令的物理内存实际地址为128+32KB(32768)=32896。这样PC就从物理内存中32896的位置取到了该指令，接下来执行该指令。该指令是说取15KB地址的值，注意这个15KB是虚拟地址，那么同理加上base的值，实际是从15+32=47KB的物理内存地址中取得该值的。</p>
<ul>
<li>把虚拟地址转换为物理地址的过程就是<strong>address translation</strong>也叫<strong>dynamic relocation</strong>。</li>
<li>别忘了我们还提到了一个bound寄存器，它的作用是啥？别小瞧他，OS最看重的就是protection，而bound寄存器就是用来实现不让一个进程访问别的进程的内存以及操作系统的内存的。bound寄存器中存的值，代表该进程的地址空间最大有多少，也就是说每一个虚拟地址不能超过bound寄存器中的值。这样久确保了这个进程访问不了其他进程的内存。</li>
<li>关于bound寄存器的定义可以有两种，一种是保存地址空间的大小，也就是说虚拟地址不能超过bound；还有一种是保存该进程的物理内存地址的最大值，也就是说translation后的地址不能超过bound。这里我们采用第一种。</li>
<li>举个栗子，一个进程的地址空间大小4KB，它在物理内存中从16KB开始，那么：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220405191924.png" style="zoom:80%;" /></p>
<h2 id="15-4-Hardware-Support-A-Summary"><a href="#15-4-Hardware-Support-A-Summary" class="headerlink" title="15.4 Hardware Support: A Summary"></a>15.4 Hardware Support: A Summary</h2><ul>
<li>总结一下从硬件获得的支持：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220405193608.png" style="zoom: 67%;" /></p>
<h2 id="15-5-Operating-System-Issues"><a href="#15-5-Operating-System-Issues" class="headerlink" title="15.5 Operating System Issues"></a>15.5 Operating System Issues</h2><ul>
<li>不能光硬件做事，OS总归也要做点事吧，别忘了这门课是在学什么。</li>
<li>第一，当创建一个进程时，要在内存中找到一个位置存放该进程了，也就是确定该进程的地址空间在内存中的实际位置。别忘了我们之前还做过假设，那就是所有进程的地址空间是连续存放的，那么就简单了，只要找到第一个空闲的内存地址即可。当创建进程时，OS需要从一个叫<strong>free list</strong>的数据结构中找到该内存地址，然后把它标记为已使用。</li>
<li>第二，当终止一个进程时，要将该进程的地址空间释放以便其他进程或者OS使用。也就是说OS把该内存放回free list，然后清理相关的数据结构。</li>
<li>第三，当做context switch的时候OS保存一些信息。因为一个CPU只有一对base and bound，所以当做context switch的时候需要保存base and bound的信息。也就是说，让一个进程先下CPU的时候，需要把base and bound寄存器的信息放在内存中，通常是某种数据结构，比如PCB。同样，当恢复改进程时，需要恢复寄存器信息。</li>
<li>第四，OS必须提供<strong>exception handlers</strong>或者可以调用的函数，和之前讨论的一样，这些是在启动时设置的。比如说，当一个进程访问的虚拟地址越界时要发起异常，交给handler来处理，handler就会终止该进程。</li>
<li>下图展示了硬件和OS的交互：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220405195345.png" style="zoom: 67%;" /></p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220405195523.png" style="zoom:80%;" /></p>
<h2 id="15-6-Summary"><a href="#15-6-Summary" class="headerlink" title="15.6 Summary"></a>15.6 Summary</h2><ul>
<li><p>主要讲的就是<strong>address translation</strong>。</p>
</li>
<li><p><strong>base and bounds</strong> 或者<strong>dynamic relocation</strong>。</p>
</li>
<li>当然这种做法是有不足的，比如图15.2中，进程的地址空间中是有很多浪费的空间，这些空间被叫做<strong>internal fragmentation</strong>，下面的章节我们就来看看如何充分使用内存空间。</li>
</ul>
]]></content>
      <categories>
        <category>Operating System</category>
        <category>Virtualization</category>
        <category>Memory</category>
      </categories>
      <tags>
        <tag>Operating System</tag>
        <tag>Virtualization</tag>
        <tag>Memory</tag>
      </tags>
  </entry>
  <entry>
    <title>18. Paging: Introduction</title>
    <url>/2022/10/27/18-Paging-Introduction/</url>
    <content><![CDATA[<h2 id="18-Paging-Introduction"><a href="#18-Paging-Introduction" class="headerlink" title="18. Paging: Introduction"></a>18. Paging: Introduction</h2><ul>
<li>内存管理有两种，一种是采用变长的chunk，也就是之前讲的segmentation。这章来讲一讲第二种方法，采用定长的chunk，这种方法叫做<strong>paging</strong>。我们把地址空间分成大小相等unit，每个unit叫做一个<strong>page</strong>；把物理内存也分成相同大小的slot，每个slot叫做 <strong>page frame</strong>。问题来了：如何使用page来虚拟化内存，从而避免外部碎片的问题？有哪些基本方法？如何用最小的空间和时间开销来实现这些方法？</li>
</ul>
<span id="more"></span>
<h2 id="18-1-A-Simple-Example-And-Overview"><a href="#18-1-A-Simple-Example-And-Overview" class="headerlink" title="18.1 A Simple Example And Overview"></a>18.1 A Simple Example And Overview</h2><ul>
<li>举个栗子，64字节的地址空间，分成4个16字节的page。（仅仅是栗子，事实空间比这大得多）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220411094428.png" style="zoom:80%;" /></p>
<p>假设物理内存128字节，对应物理内存的话：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220411094543.png" style="zoom:80%;" /></p>
<p><strong>Paging</strong>的好处：</p>
<p>1.可以高效管理内存，而不用在意用户如何使用地址空间，不用管stack和heap是向上增长还是向下增长。</p>
<p>2.很简单。</p>
<ul>
<li>可以看到，page和page frame是对应的。那么为了记录这种对应关系，<strong>每个进程</strong>都需要一个 <strong>page table</strong>的数据结构。其作用就是地址翻译，给一个虚拟地址空间中的page，翻译出其在物理内存中的page frame位置。</li>
<li>举个栗子，64字节的地址空间的进程，要访问内存：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220411095424.png" style="zoom:80%;" /></p>
<p>翻译这个虚拟地址的话，我们要先把虚拟地址分成两个部分：<strong>virtual page number (VPN)</strong>和page的<strong>offset</strong>。比如，64字节对应6位地址，虚拟地址长这样：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220411101029.png" style="zoom:80%;" /></p>
<p>划分后的虚拟地址：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220411101114.png" style="zoom:80%;" /></p>
<p>因为一共有4个page，所以VPN两位，剩下的就是offset。</p>
<p>考虑这条指令：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220411101314.png" style="zoom:80%;" /></p>
<p>十进制的21转换成二进制： 010101，这样的话：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220411101419.png" style="zoom:80%;" /></p>
<p>可以看到是第1个page，offset是5，由图18.2看到对应的<strong>physical frame number (PFN)</strong>，有时也叫<strong>physical page number PPN</strong>是7，那么翻译过程如下：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220411101600.png" style="zoom:80%;" /></p>
<ul>
<li>还有些问题：page table存在哪里？有多大？都存了什么内容？paging会让系统变慢吗？</li>
</ul>
<h2 id="18-2-Where-Are-Page-Tables-Stored"><a href="#18-2-Where-Are-Page-Tables-Stored" class="headerlink" title="18.2 Where Are Page Tables Stored?"></a>18.2 Where Are Page Tables Stored?</h2><ul>
<li>page table可能会很大。比如，32位地址空间，分成4KB的page，那么VPN就是20位，offset是12位。假设每个<strong>page table entry(PTE)</strong>需要四个字节来保存有关地址翻译的信息，那么整个page table就是4 * 2 ^ 20 = 4MB。要是有100个运行进程的话，那可就是400MB！太大了！</li>
<li>page table是保存在物理内存中的；后面会讲是如何保存在OS的虚拟地址空间中的。</li>
</ul>
<h2 id="18-3-What’s-Actually-In-The-Page-Table"><a href="#18-3-What’s-Actually-In-The-Page-Table" class="headerlink" title="18.3 What’s Actually In The Page Table?"></a>18.3 What’s Actually In The Page Table?</h2><ul>
<li>其实只要能够保存page到page frame的映射，什么数据结构都行。举个栗子，最简单的就是一个<strong>linear page table</strong>，一个数组。数组下标代表地址空间中的page下标，数组元素代表映射到物理内存的page frame下标。</li>
<li>具体来说，每个PTE是由很多位组成的。</li>
</ul>
<p><strong>valid bit</strong> 用于表明某个特定翻译是否有效，比如没有使用的地址空间都是无效的，如果请求的是无效地址就会trap。把没有使用过的page标为无效。</p>
<p><strong>protection bits</strong>用于表明某个page是否可以被读写、执行。</p>
<p>还有一些：</p>
<p><strong>present bit</strong>表明当前page在内存中还是disk上。</p>
<p><strong>dirty bit</strong>表明page自从上次被加载到内存中有没有被修改过。</p>
<p><strong>reference bit (a.k.a. accessed bit)</strong>表明page是否被访问过。</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220411104959.png" style="zoom:80%;" /></p>
<h2 id="18-4-Paging-Also-Too-Slow"><a href="#18-4-Paging-Also-Too-Slow" class="headerlink" title="18.4 Paging: Also Too Slow"></a>18.4 Paging: Also Too Slow</h2><ul>
<li>考虑这条指令：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220411105142.png" style="zoom:80%;" /></p>
<p>现在我们知道虚拟地址21对应物理内存地址117，但是how？怎么翻译过来的？</p>
<p>首先硬件必须知道当前运行进程的page table在哪里。假设一个<strong>page-table base register</strong>中包含的是一个page table的起始地址。为了找到目标PTE，硬件要执行以下函数：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220411105601.png" style="zoom:80%;" /></p>
<p>在我们的栗子中，VPN_MASK设置为110000，用于从虚拟地址中筛选出VPN。SHIFT设置为4，也就是offset的位数。对于虚拟地址21，010101，（010101 &amp; 110000） &gt;&gt;  4 = 010000 &gt;&gt; 4 = 01。也就是说是第一个虚拟page。这样再根据数组特性，数组首地址加上下标乘每个元素大小，就找到了PTE的地址。</p>
<p>然后就可以从内存中取出PTE，得到PFN，再加上offset得到真正的物理地址。</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220411110148.png" style="zoom:80%;" /></p>
<p>这样就可以得到物理地址，然后访问该地址，取出值放到eax寄存器中。</p>
<p>总结：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220411110337.png" style="zoom:80%;" /></p>
<p>可以看到，paging需要一次额外的访问内存来获取PTE，因此比较慢。</p>
<ul>
<li>问题来了：paging还是太慢，并且占用大量内存。</li>
</ul>
<h2 id="18-5-A-Memory-Trace"><a href="#18-5-A-Memory-Trace" class="headerlink" title="18.5 A Memory Trace"></a>18.5 A Memory Trace</h2><ul>
<li>考虑这段C代码：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220411110633.png" style="zoom:80%;" /></p>
<p>对应的汇编代码：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220411110801.png" style="zoom:80%;" /></p>
<p>假设进程地址空间64KB，每个page1KB。linear page table，物理内存中首地址1KB（1024）。代码在VPN1中，VPN1对应PFN4。地址空间中，数组地址位40000到44000，也就是VPN39到VPN42，(VPN 39 → PFN 7), (VPN 40 → PFN 8), (VPN 41 → PFN 9), (VPN 42 → PFN 10)。</p>
<p>当这段指令运行时，每条指令需要进行两次内存访问，第一次是找到PTE以获得page frame，第二次是去page frame 中访问。对于movl指令，还需要额外的两次访问内存，也就是说一共四次。哪四次呢？取指令的时候有两次，第一次是找到记录指令所在的位置的PTE，第二次是真正取指令；访问数组时有两次，第一次是找到数组所在位置的PTE，第二次是真正访问数组。也就是说，对于一次循环，需要有10次访问内存。</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220411135609.png" style="zoom:80%;" /></p>
<p>最下方的黑色代表指令的内存访问，左边虚拟内存，右边物理内存。</p>
<p>中间的黑灰色代表数组的内存访问，左边虚拟内存，右边物理内存。</p>
<p>最上方的浅灰色代表page table的内存访问，物理内存。</p>
<h2 id="18-6-Summary"><a href="#18-6-Summary" class="headerlink" title="18.6 Summary"></a>18.6 Summary</h2><ul>
<li>介绍了paging的方法，优点一，没有外部碎片；优点二，很灵活，无需在意用户怎么使用page。</li>
<li>但是这种方法导致系统变慢，如何解决？</li>
</ul>
]]></content>
      <categories>
        <category>Operating System</category>
        <category>Virtualization</category>
        <category>Memory</category>
      </categories>
      <tags>
        <tag>Operating System</tag>
        <tag>Virtualization</tag>
        <tag>Memory</tag>
      </tags>
  </entry>
  <entry>
    <title>19. Paging: Faster Translations (TLBs)</title>
    <url>/2022/10/27/19-Paging-Faster-Translations-TLBs/</url>
    <content><![CDATA[<h1 id="19-Paging-Faster-Translations-TLBs"><a href="#19-Paging-Faster-Translations-TLBs" class="headerlink" title="19. Paging: Faster Translations (TLBs)"></a>19. Paging: Faster Translations (TLBs)</h1><ul>
<li>Page table存在内存中，因此使用paging的方法需要额外的内存访问，因此比较耗时。问题：如何加速地址翻译并且避免额外的内存访问？需要哪些硬件支持？OS又需要做什么？</li>
<li>方法叫<strong>translation-lookaside buffer</strong>或者<strong>TLB</strong>，是MMU的一个部分。其实就是对于经常访问的page frame的一个缓存，因此也叫做<strong>address-translation cache</strong>。每次进行地址翻译时，先去TLB中找，如果没有再去内存中找。<span id="more"></span>
<h2 id="19-1-TLB-Basic-Algorithm"><a href="#19-1-TLB-Basic-Algorithm" class="headerlink" title="19.1 TLB Basic Algorithm"></a>19.1 TLB Basic Algorithm</h2></li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220413101231.png" style="zoom:80%;" /></p>
<ul>
<li>考虑一个简单的<strong>linear page table</strong>，一个由硬件管理的TLB。</li>
</ul>
<p>想通过VPN来找到FPN的时候，先去TLB中找，如果找到称为 <strong>TLB hit</strong>，就可以从TLB中取得FPN。</p>
<p>如果在TLB中没有找到就称<strong>TLB miss</strong>，这种情况下就和之前一样去内存中找到对应的PTE，从PTEAddr中拿到PTE，再从PTE中拿到PFN，并且更新TLB。</p>
<p>最后重新执行该指令就会hit了。</p>
<h2 id="19-2-Example-Accessing-An-Array"><a href="#19-2-Example-Accessing-An-Array" class="headerlink" title="19.2 Example: Accessing An Array"></a>19.2 Example: Accessing An Array</h2><ul>
<li>举个栗子，一个整数数组，有10个4字节的整数，虚拟地址是100开始；地址空间8位，也就是256B，每个 page 16B，也就是说一共有16个page，因此4位VPN，4位offset。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220413102208.png" style="zoom:80%;" /></p>
<p>考虑这段C代码：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220413102259.png" style="zoom:80%;" /></p>
<p>简单起见，我们只考虑循环的内存访问。</p>
<p>当访问第一个元素a[0]时，虚拟地址100，VPN06，因为是第一次访问，所以 TLB中VPN06对应的FPN肯定是空，TLB miss。当访问第二个元素a[1]时，神奇的事情发生了，TLB hit！为什么呢？因为对于第一个元素，TLB miss之后会去内存中找到VPN06对应的FPN放到TLB中，而第二个元素和第一个元素都是属于VPN06的，因此第二次TLB hit！同理a[2]也是TLB hit！</p>
<p>同理可得，a[3] miss，a[4] hit，a[5] hit，a[6] hit；a[7] miss，a[8] hit，a[9] hit；可以计算出hit比例是70%。我们通过 <strong>spatial locality</strong>减少了内存访问。如果地址空间再大一点的话，比如4KB，那么整个数组就可以放在同一个page中，那么就只会在第一次miss，其他都是hit。</p>
<p>注意，当我们在该程序中再次访问该数组时，会100%hit，这利用了<strong>temporal locality</strong>。</p>
<h2 id="19-3-Who-Handles-The-TLB-Miss"><a href="#19-3-Who-Handles-The-TLB-Miss" class="headerlink" title="19.3 Who Handles The TLB Miss?"></a>19.3 Who Handles The TLB Miss?</h2><ul>
<li>谁来处理TLB miss？答案有两个：硬件或者OS。</li>
</ul>
<p>早期，硬件有着complex instruction sets （<strong>CISC</strong>，complex-instruction set computers），因此由硬件来处miss。硬件通过page table register记住page table的位置，当miss时，从page table中找到PTE再找到PFN。</p>
<p>现代系统一般使用<strong>RISC</strong>（reduced-instruction set computers），由软件管理TLB，也就是OS。当miss时，OS raises an exception，切换到kernel mode然后jump 到 trap handler，对应的handler里有处理miss的代码，运行这段代码，就会从page table中找到对应地址，使用特权指令更新TLB，然后return from trap ，之后硬件再retry 指令。</p>
<ul>
<li>现在我们再来看亿点点细节：</li>
</ul>
<p>第一，这里的return from trap和普通的return from trap指令不太一样。普通的return from trap指令return后是到陷入trap的后面的代码，继续往下执行；而处理TLB miss的return from trap指令return后是return到这条指令开头，需要retry这条指令。<br>第二，在运行TLB miss handler代码时，在这段代码内要避免造成TLB miss，不然就会一直循环TLB miss。</p>
<ul>
<li>软件管理TLB的一个好处就是比较灵活，可以使用任意数据结构来实现page table；另一个好处就是简单。</li>
</ul>
<h2 id="19-4-TLB-Contents-What’s-In-There"><a href="#19-4-TLB-Contents-What’s-In-There" class="headerlink" title="19.4 TLB Contents: What’s In There?"></a>19.4 TLB Contents: What’s In There?</h2><ul>
<li>典型的TLB可能包含32、64或128个元素。每个元素长这样：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220413110858.png" style="zoom:80%;" /></p>
<p>可以看到和PTE很像，但是other bits又有所不同。</p>
<p><strong>valid</strong> bit：表明这个元素的是否有效。</p>
<p><strong>protection</strong> bit：表明这个page能被怎样访问。比如读写、读执行等。</p>
<p>等等</p>
<h2 id="19-5-TLB-Issue-Context-Switches"><a href="#19-5-TLB-Issue-Context-Switches" class="headerlink" title="19.5 TLB Issue: Context Switches"></a>19.5 TLB Issue: Context Switches</h2><ul>
<li>注意，可能多个进程的PN to PFN信息同时存储在TLB中，对这种情况如何控制？</li>
</ul>
<p>举个栗子，进程P1正在运行，TLB中保存了P1的VPN10 to PFN 100。进程P2退出了，但是一会可能要切换到P2，TLB中保存了P2的VPN10 toPFN 170：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220413134208.png" style="zoom:80%;" /></p>
<p>问题来了，当context switch的时候，如何保证TLB中上一个进程的信息对于即将要运行的进程来讲是无效的呢？硬件和OS又需要做什么来达到上述目的呢？</p>
<ul>
<li>有很多种做法</li>
</ul>
<p>一种做法是当context switch的时候就刷新TLB，因此对于下一个进程来讲TLB是空的。可以简单的把valid设置为0。但是这种做法在频繁切换进程时性能较差。</p>
<p>为了解决上述问题，可以通过硬件的支持来让不同的进程之间共享TLB。可以在TLB中加上<strong>ASID</strong>（address space identifier）字段用于表明当前这个翻译是给哪个进程用的，举个栗子：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220413135613.png" style="zoom:80%;" /></p>
<p>这样在context switch的时候就不需要清空TLB了。当然存在两个进程共享page frame的情况：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220413135743.png" style="zoom:80%;" /></p>
<h2 id="19-6-Issue-Replacement-Policy"><a href="#19-6-Issue-Replacement-Policy" class="headerlink" title="19.6 Issue: Replacement Policy"></a>19.6 Issue: Replacement Policy</h2><ul>
<li>对于所有缓存来说，都存在一个共性问题：<strong>cache replacement</strong>。当缓存满了的时候，如何选择一个来替换？问题来了：在TLB满了的时候，如何选择一个entry来替换？当然目标是尽可能减少miss rate。</li>
<li>最常见的做法是<strong>least-recently-used LRU</strong>，还有<strong>random</strong>，各有优劣。</li>
</ul>
<h2 id="19-7-A-Real-TLB-Entry"><a href="#19-7-A-Real-TLB-Entry" class="headerlink" title="19.7 A Real TLB Entry"></a>19.7 A Real TLB Entry</h2><ul>
<li>MIPS R4000的TLB entry如图</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220413140230.png" style="zoom:80%;" /></p>
<p>32位地址空间，每个page4KB，因此VPN20位，12位offset。但是在图中VPN只有19位，用户的地址空间最多用到一半？（好像是这个意思，原文：user addresses will only come from half the address space (the rest reserved for the kernel)）。物理内存64GB，因此PFN24位。</p>
<p>global bit（G）：表明该page对于进程是否全局共享，如果是那么就忽略ASID位。</p>
<p>ASID：8位，用于区分不同进程。</p>
<p>Coherence：3位，用于表明硬件是通过何种方式缓存一个page的。</p>
<p>dirty：表明page是否被修改过。</p>
<p>还有一些没有用到。</p>
<h2 id="19-8-Summary"><a href="#19-8-Summary" class="headerlink" title="19.8 Summary"></a>19.8 Summary</h2><ul>
<li>TLB用于缓存page table记录的翻译。</li>
<li>但还是存在问题，比如短时间内大量进程切换，导致TLB中缓存的page不够了，那么还是会有很多的TLB miss，超过了TLB coverage，下一章讨论解决方法。</li>
</ul>
]]></content>
      <categories>
        <category>Operating System</category>
        <category>Virtualization</category>
        <category>Memory</category>
      </categories>
      <tags>
        <tag>Operating System</tag>
        <tag>Virtualization</tag>
        <tag>Memory</tag>
      </tags>
  </entry>
  <entry>
    <title>16. Segmentation</title>
    <url>/2022/10/27/16-Segmentation/</url>
    <content><![CDATA[<h1 id="16-Segmentation"><a href="#16-Segmentation" class="headerlink" title="16. Segmentation"></a>16. Segmentation</h1><ul>
<li>接上一节的问题，当我们把地址空间放到物理内存中的时候，stack和heap中会出现内部碎片，存在空间浪费。再如下图：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220407135018.png" style="zoom:80%;" /></p>
<ul>
<li><p>因此，简单地使用一对base and bounds寄存器的方法是不行滴。要解决的问题：面对一个很大的地址空间，中间有内部碎片，如何放到物理内存中去？上图只是16KB，想象下假如是4GB呢？</p>
<span id="more"></span>
<h2 id="16-1-Segmentation-Generalized-Base-Bounds"><a href="#16-1-Segmentation-Generalized-Base-Bounds" class="headerlink" title="16.1 Segmentation: Generalized Base/Bounds"></a>16.1 Segmentation: Generalized Base/Bounds</h2></li>
<li><p>为了解决上述问题，采用的方法是<strong>Segmentation</strong>。很简单，之前的方法中，MMU有一对base and bound寄存器，那么为什么不这样做呢，给地址空间中的每一个逻辑<strong>segment</strong>设置一对base and bound寄存器。一个<strong>segment</strong>是地址空间中有着特定长度的某个连续片段。在典型的地址空间中，有三个逻辑segment：code、stack、heap。那么segmentation做的事情就是把每个segment放在物理内存中的不同地方，这样就避免了物理内存中存在没有使用的虚拟地址空间。</p>
</li>
<li>也就是说不再以整个地址空间为单位放到物理内存中去，而是以segment为单位放到物理内存中去。</li>
<li>举个栗子，将上述地址空间放到64KB的物理内存中去：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220407140100.png" style="zoom: 80%;" /></p>
<ul>
<li>从硬件方面来说，要设置三对base and bound寄存器：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220407140608.png" style="zoom:80%;" /></p>
<ul>
<li>问题来了，在这种情况下，如何做translation呢？</li>
</ul>
<p>假设现在要访问虚拟地址100。可以看到，在原地址空间中，100这个虚拟地址属于code这个segment，因此在做translation的时候就要使用code的base and bounds寄存器的值，那么实际物理内存地址就是：100+32K（32768）=32868，并且根据bound寄存器中2K的值来检查，100&lt;2K合法。</p>
<p>假设现在要访问的虚拟地址是4200。可以看到在原地址空间中这个地址属于heap这个segment，但是如果我们直接4200+34K得到的物理内存地址是不对的。因为对于34K这个base来说，4200并不是真的offset，真正的offset是4200-4K（4096）=104（&lt;3K合法），也就是说减去heap这个segment在虚拟地址空间中的起始地址。物理内存地址：104+34K=34920。</p>
<ul>
<li>如果我们试图访问非法的地址，比如说虚拟地址7KB或者更大，该怎么办？这时候硬件就应该检测出地址非法然后终止进程。在C语言中就报错：<strong>the segmentation violation</strong> or <strong>segmentation fault</strong>。</li>
</ul>
<h2 id="16-2-Which-Segment-Are-We-Referring-To"><a href="#16-2-Which-Segment-Are-We-Referring-To" class="headerlink" title="16.2 Which Segment Are We Referring To?"></a>16.2 Which Segment Are We Referring To?</h2><ul>
<li>问题来了，一个地址空间有多对base and bounds寄存器，我们怎么知道一个虚拟地址相对base的offset，怎么知道该用哪一个base寄存器？</li>
<li>第一种做法是一种<strong>explicit</strong>的做法。根据虚拟地址的头几位来将地址空间分成若干个segment。</li>
</ul>
<p>还是以上述那个地址空间，地址空间是16KB，按字节寻址，那么也就是说地址空间一共有16K，一共是4+10=14位。我们用头两位来选择segment：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220407144427.png" style="zoom:80%;" /></p>
<p>如果头两位是00，那么虚拟地址就是属于code这个segment的；如果头两位是01，那么虚拟地址就是属于heap这个segment的。还以虚拟地址4200为例，二进制表示如下：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220407144624.png" style="zoom:80%;" /></p>
<p>可以看到根据头两位01确定属于heap，剩下的就是offset 0000 0110 1000，也就是之前我们计算得到的104。ok，现在就可以用heap的base和bound寄存器来计算物理地址了。</p>
<p>这时候聪明的你就问了，头两位一共可以表示4个segment，我们只有三个，那岂不是有一个没用？</p>
<p>为了充分利用虚拟地址空间，有时候会把code和heap放在同一个segment中，这样就就只用一位来判断属于哪个segment了。</p>
<p>这种做法还有一个问题，那就是限制了虚拟地址空间的使用。在这种情况下，每个segment的最大值是4KB，那如果一个程序希望扩大其segment，比如stack或者heap，超过最大值就不行了。</p>
<ul>
<li>还有一种做法也可以帮助硬件决定选择哪一个segment，这种做法是<strong>implicit</strong>的。对于一个虚拟地址，硬件判断这个虚拟地址是如何形成的，根据形成方式来判断是哪一个segment的。比如，如果这个虚拟地址是PC形成的，那么一定属于code这个segment；如果这个地址是来自stack或者base指针，那么属于stack这个segment；那其余的就是heap的了。</li>
</ul>
<h2 id="16-3-What-About-The-Stack"><a href="#16-3-What-About-The-Stack" class="headerlink" title="16.3 What About The Stack?"></a>16.3 What About The Stack?</h2><ul>
<li>别把stack忘了，之前一直没说它，因为它有点不一样：stack是向下增长的。那么如何计算stack的物理内存地址？</li>
<li>首先，我们需要硬件的帮助。硬件除了要知道base和bound，还要知道地址空间是向上增长还是向下增长的。所以用额外的1位来表示：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220407154601.png" style="zoom:80%;" /></p>
<ul>
<li>举个栗子：</li>
</ul>
<p>假设虚拟地址是15KB，映射到物理地址应该是27KB。虚拟地址的二进制：11 1100 0000 0000，硬件根据头两位的11来判断是stack这个segment，那么剩下的1100 0000 0000也就是3K是offset，为了得到正确的负offset，必须用3K-4K=-1K，这样28K+（-1K）=27K。offset的绝对值不能超过bound寄存器中的值。</p>
<h2 id="16-4-Support-for-Sharing"><a href="#16-4-Support-for-Sharing" class="headerlink" title="16.4 Support for Sharing"></a>16.4 Support for Sharing</h2><ul>
<li>为了节省内存，不同地址空间有时共享特定内存中的segment。这就需要硬件的帮助，设置一个<strong>protection bits</strong>。给每一个segment加一个保护位，用来代表该segment是否可以被一个程序读写或者是执行该segment中的代码。当一个segment是read-only时，多个进程可以共享，也不用担心隔离的问题，并且好像是每个进程独享的一样。</li>
<li>举个栗子：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220407162556.png" style="zoom:80%;" /></p>
<p>这样，code这个segment就可以和多个地址空间进行映射。</p>
<h2 id="16-5-Fine-grained-vs-Coarse-grained-Segmentation"><a href="#16-5-Fine-grained-vs-Coarse-grained-Segmentation" class="headerlink" title="16.5 Fine-grained vs. Coarse-grained Segmentation"></a>16.5 Fine-grained vs. Coarse-grained Segmentation</h2><ul>
<li>Coarse-grained Segmentation把一个地址空间分成少的segment</li>
<li>Fine-grained Segmentation把一个地址空间分成多的segment</li>
</ul>
<h2 id="16-6-OS-Support"><a href="#16-6-OS-Support" class="headerlink" title="16.6 OS Support"></a>16.6 OS Support</h2><ul>
<li>OS不能偷懒，也要提供帮助。</li>
<li>第一，OS如何做context switch？<ul>
<li>保存并恢复segment的寄存器。</li>
</ul>
</li>
<li>第二，当一个segment要扩大或收缩时，OS该怎么做？<ul>
<li>比如malloc()分配内存时，OS要检查有没有足够的内存，并且更新segment的寄存器。</li>
</ul>
</li>
<li>第三，最重要的，OS如何管理物理内存中的空闲区域？</li>
</ul>
<p>当物理内存中存在片段时，但是该片段又不够大不能够使用，就是外部碎片。比如下图左边中间小片段：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220407163357.png" style="zoom:80%;" /></p>
<p>一种做法是，定期整理segment，使其变成右边的样子。但是这种做法时间开销太大。</p>
<p>还有种简单的做法，使用free-list管理算法来保证内存分配的最大使用率。比如best-fit，worst-fit，first-fit等等。但是不管采用什么算法，外部碎片总会存在，我们能做的就是减少之。</p>
<h2 id="16-7-Summary"><a href="#16-7-Summary" class="headerlink" title="16.7 Summary"></a>16.7 Summary</h2><ul>
<li>Segmentation的方发解决了内部碎片，并且可以code sharing。</li>
<li>但是同时带来了新的问题，外部碎片，可以用compact或者算法来解决，但是根本问题没解决。</li>
<li>还有一个，segmentation对于稀疏地址空间来说还不够灵活。举个栗子，一个较大的地址空间一直放在内存中，但是很少使用，怎么办？</li>
</ul>
]]></content>
      <categories>
        <category>Operating System</category>
        <category>Virtualization</category>
        <category>Memory</category>
      </categories>
      <tags>
        <tag>Operating System</tag>
        <tag>Virtualization</tag>
        <tag>Memory</tag>
      </tags>
  </entry>
  <entry>
    <title>21. Beyond Physical Memory: Mechanisms</title>
    <url>/2022/10/27/21-Beyond-Physical-Memory-Mechanisms/</url>
    <content><![CDATA[<h1 id="21-Beyond-Physical-Memory-Mechanisms"><a href="#21-Beyond-Physical-Memory-Mechanisms" class="headerlink" title="21. Beyond Physical Memory: Mechanisms"></a>21. Beyond Physical Memory: Mechanisms</h1><ul>
<li>目前为止，我们一直假设page是全部保存在内存中的。但是，由于内存有限的原因，再加上可能运行的进程数很多导致有许多page，实际上内存往往还保存在 <strong>hard disk</strong>中。那么问题来了，OS如何通过像hard disk之类的低速设备，来提供一个很大的地址空间的假象？</li>
</ul>
<span id="more"></span>
<h2 id="21-1-Swap-Space"><a href="#21-1-Swap-Space" class="headerlink" title="21.1 Swap Space"></a>21.1 Swap Space</h2><ul>
<li>首先要做的事情就是在磁盘上找到一块空间用于保存page，这块空间叫做<strong>swap space</strong>。那么如何知道一个page保存在磁盘上的什么位置呢？因此OS需要记住一个page的<strong>disk address</strong>。</li>
<li>假设swap space足够大，举个栗子：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220420093804.png" style="zoom:80%;" /></p>
<p>当一个进程的page需要运行时，如果在disk上找到，那么先要从disk移到内存中。</p>
<h2 id="21-2-The-Present-Bit"><a href="#21-2-The-Present-Bit" class="headerlink" title="21.2 The Present Bit"></a>21.2 The Present Bit</h2><ul>
<li>对于保存在disk上的page，一定要有一些机制要管理。假设我们采用硬件管理的TLB：</li>
</ul>
<p>回忆一下内存访问时发生了什么。运行的进程给出要访问的虚拟地址，然后硬件将虚拟地址翻译为物理地址。首先从虚拟地址中拿到VPN，接着从TLB中查看是否hit，如果hit直接返回PFN。如果miss，需从page table base register中拿到page table 的物理起始地址，然后使用VPN计算出对应的PTE的物理地址，读取PTE内容，得到PFN。最后和虚拟地址的offset拼在一起得到物理地址。</p>
<p>ok，现在如果page可能保存在disk上要怎么办？那么就要在page table中保存额外的信息了。具体是在每一个PTE中设置<strong>present bit</strong>，用来表明当前page是否在内存中。如果不在内存中，那么对于该page的访问就会造成<strong>page fault</strong>。接着就交给<strong>page-fault handler</strong>处理。</p>
<h2 id="21-3-The-Page-Fault"><a href="#21-3-The-Page-Fault" class="headerlink" title="21.3 The Page Fault"></a>21.3 The Page Fault</h2><ul>
<li>对于TLB miss，可以通过硬件处理或者软件处理；但是对于page fault，直接交给软件处理，哪怕TLB miss是被硬件处理的。如果page不在内存中，OS就会把在disk中的page交换到内存中来，那么问题来了，OS如何知道该page放在哪里呢？实际上还是用page table来保存该信息。当page不在内存中时，可以采用该PTE的PFN为来保存disk address。</li>
<li>当disk I/O完成后，也就是该page被交换到内存中后，OS就会更新page table将其标记为存在，然后更新PTE的PFN，最后retry指令。retry之后可能还会TLB miss，这就和之前一样了，会从page table中拿到PFN，更新TLB，再retry，最后从TLB中取到PFN。</li>
<li>注意，当执行I/O操作时，该线程会被blocked，因此会运行其他进程。</li>
</ul>
<h2 id="21-4-What-If-Memory-Is-Full"><a href="#21-4-What-If-Memory-Is-Full" class="headerlink" title="21.4 What If Memory Is Full?"></a>21.4 What If Memory Is Full?</h2><ul>
<li>如题，内存满了咋办？随着不断的把page放入内存，内存总会满的。这时，如果再想把page放入满的内存中会发生什么呢？首先，OS会把内存中的某些page移到disk上，然后再把需要使用的page放入内存。这个过程就不可避免地需要一种策略来决定当内存满时，选择哪一个page移出内存，<strong>page-replacement policy</strong>。具体策略会在之后介绍，这里我们先记得有这么个从策略。</li>
</ul>
<h2 id="21-5-Page-Fault-Control-Flow"><a href="#21-5-Page-Fault-Control-Flow" class="headerlink" title="21.5 Page Fault Control Flow"></a>21.5 Page Fault Control Flow</h2><p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220420103216.png" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220420103244.png" style="zoom:80%;" /></p>
<h2 id="21-6-When-Replacements-Really-Occur"><a href="#21-6-When-Replacements-Really-Occur" class="headerlink" title="21.6 When Replacements Really Occur"></a>21.6 When Replacements Really Occur</h2><ul>
<li>实际上，OS并不会等到内存完全满了 ，再去把一些page移出内存。正所谓未雨绸缪，OS总会保留内存的一部分是可用的。因此有两个概念：<strong>high watermark(HW)</strong>和<strong>low watermark(LW)</strong>，其中LW代表，当内存中可用page数低于LW时，后台负责释放内存的进程运行，知道内存中有HW的page数可用。这个后台进程一般叫做<strong>swap daemon</strong>或者<strong>page daemon</strong>。</li>
<li>有了这个后台进程，图21.3的控制流程需要稍微修改。不再直接执行替换操作，也就是DiskRead，先检查是否有可用的page位置。如果没有，就会启动后台进程来清理内存。当有page位置可用时，就会唤醒原进程继续工作。</li>
</ul>
<h2 id="21-7-Summary"><a href="#21-7-Summary" class="headerlink" title="21.7 Summary"></a>21.7 Summary</h2><ul>
<li>采用 <strong>present bit</strong>来判断page是否保存在内存中；使用<strong>page-fault handler</strong>来处理<strong>page-fault</strong> ，也就是page不在内存中的情况。</li>
<li>所有的这些操作对于进程来说都是透明的。</li>
</ul>
]]></content>
      <categories>
        <category>Operating System</category>
        <category>Virtualization</category>
        <category>Memory</category>
      </categories>
      <tags>
        <tag>Operating System</tag>
        <tag>Virtualization</tag>
        <tag>Memory</tag>
      </tags>
  </entry>
  <entry>
    <title>20. Paging: Smaller Tables</title>
    <url>/2022/10/27/20-Paging-Smaller-Tables/</url>
    <content><![CDATA[<h1 id="20-Paging-Smaller-Tables"><a href="#20-Paging-Smaller-Tables" class="headerlink" title="20. Paging: Smaller Tables"></a>20. Paging: Smaller Tables</h1><ul>
<li>继续之前的问题，page table可能过大，上一节采用了TLB缓存的方法，这一节来看看不同的方法。问题来了，如何让page table 变小呢？有哪些方法？这些方法又会带来哪些问题？</li>
</ul>
<span id="more"></span>
<h2 id="20-1-Simple-Solution-Bigger-Pages"><a href="#20-1-Simple-Solution-Bigger-Pages" class="headerlink" title="20.1 Simple Solution: Bigger Pages"></a>20.1 Simple Solution: Bigger Pages</h2><ul>
<li>如题，当使用更大的page时，那么page数就会变少，自然page table就会变小。</li>
</ul>
<p>假设地址空间32位，page大小4KB，page-table entry大小4B，那么page table大小就是<script type="math/tex">\frac{2^{32}}{2^{12}}*4B=4MB</script>。</p>
<p>现在将page大小变为16KB，那么page table大小就是 <script type="math/tex">\frac{2^{32}}{2^{14}}*4B=1MB</script>。可以看到page table大小变为原来的四分之一。</p>
<p>但是这种方法同样存在着问题，page越大，那么page内出现内部碎片的可能性就越大。因此大部分系统使用的还是相对较小的page，比如4KB (as in x86) or 8KB (as in SPARCv9)。</p>
<h2 id="20-2-Hybrid-Approach-Paging-and-Segments"><a href="#20-2-Hybrid-Approach-Paging-and-Segments" class="headerlink" title="20.2 Hybrid Approach: Paging and Segments"></a>20.2 Hybrid Approach: Paging and Segments</h2><ul>
<li>平衡之道，采用将paging和segmentation相结合的方法来减小page table的大小。</li>
</ul>
<p>举个栗子，地址空间16KB，page1KB，因此共有16个page，page和page frame的映射关系如下：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220418103928.png" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220418104038.png" style="zoom:80%;" /></p>
<p>从上图可以看到，虽然大量的page没有使用，但是依旧保存在page table中（将valid位设为0）。也就是说page table中其实保存了大量无用信息，假如地址空间再大一点，可以想象保存的无用信息可能会更多。所以为什么不采用segmentation的思想只保存valid的信息呢？</p>
<p>我们的平衡之道是：与其给每个进程设置一张page table保存所有page映射关系，不如给每个地址空间的segment设置一张page table。segmentation可以保存变长的信息，因此可以使用segmentation的方法保存变长的page table，这就是我们将segmentation和paging结合的平衡之道。</p>
<p>在这个栗子里，我们将设置三张page table，因为有三个逻辑segment：code、stack、heap。回忆一下segmentation方法，给每个进程的逻辑segment设置一对base and bound寄存器，其中base寄存器保存地址空间在物理内存的起始位置，bound保存了地址空间的边界。那么在我们的平衡之道中仍将采用base and bound的方法，只不过，这里的base保存的是每个page table在物理内存中的起始地址，bound保存的是page table的边界（也就是其中保存了多少个valid的page）。</p>
<p>假设32位地址空间，page大小4KB，地址空间被分为四个segment。使用其中的三个segment：code、heap、stack。对于32位地址，使用最高两位来判断当前地址指向的是哪个segment，00代表未使用，01代表code，10代表heap，11代表stack。</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220418110330.png" style="zoom:80%;" /></p>
<p>当TLB miss的时候，硬件使用segment bit(SN)来决定使用哪一对base and bound寄存器；然后通过VPN去base指向的page table中寻找对应PTE：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220418111748.png" style="zoom:80%;" /></p>
<p>注意，bound寄存器中保存的是当前segment中有效的page值。假设，code segemnt只使用了前三个page，那么对用的page table会有三个PTE对应保存VPN0、1、2。无效的信息没有保存，因此page table的大小就减小了。</p>
<p>当然了，这种做饭并非完美。第一，还是要使用segmentation的思想，就像之前提到的，这种思想不够灵活，因为它定好了地址空间的使用模式；第二，segmentation总是会导致外部碎片。因此我们还需要更好的方式来解决page table过大的问题。</p>
<h2 id="20-3-Multi-level-Page-Tables"><a href="#20-3-Multi-level-Page-Tables" class="headerlink" title="20.3 Multi-level Page Tables"></a>20.3 Multi-level Page Tables</h2><ul>
<li>重量级方法来了，<strong>multi-level page table</strong>，多级页表，还是那句话，在计算机里，没有什么是加一层解决不了的，如果有，就再加一层。用一句话概括多级页表就是，保存page table的page table，即套娃。</li>
</ul>
<p>本来想细节解释一番如何做成多级页表，但是文字功底有限，不如直接看图，一图胜千言。</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220418140228.png" style="zoom:80%;" /></p>
<p>简单解释一下吧。</p>
<p>可以看到，最左边就是我们原本的page table，中间是我们采用的新的数据结构page directory（本质上和page table是类似的，也就是page table的page table）。</p>
<p>如果仅仅使用page table不使用多级页表，那么就需要将左边的整个page table都保存在内存中。而在多级页表中，将page table分成若干个unit，每个unit是一个page的大小；既然将整个page table分成这么多unit了，也就意味着我们不需要把原本的page table<strong>连续</strong>的存放在内存中了，理论上我们可以将每一个uint放在内存的不同位置。既然都分开放了，那么page table中那些空的位置就不用实际上放在内存中了呀，可以只将使用过的那些位置保存在内存中。</p>
<p>那么问题就来了，对于原本<strong>连续</strong>存放在内存中的page table，我们只需要一个page table 寄存器就可以知道它的起始位置；但是当这个page table<strong>分散</strong>地存在内存中，我们如何知道他们保存在什么位置呢？</p>
<p>ok，终于来到了<strong>page directory</strong>。上面那个问题的答案就是page directory，其中保存了page table的每个unit实际保存在内存的什么位置。有了page dir，对于上图而言，可以看到原本的page table被分成了四个unit，但是实际上只有一头一尾两个unit是保存在内存中的，中间的并没有保存，从而达到节省空间的目的。</p>
<p>page directory中每个元素叫做page directory entry（PDE），其中包含了valid和PFN，valid表示是当前PDE对应的page是否有效，PFN代表了对应的page的物理块号。</p>
<p>综上所述，多级页表只不过是套娃而已，本来page table就是把地址空间分成page，将每个page离散地存在内存中；现在又把page table分成page，再离散地存在内存中，仅此而已。</p>
<ul>
<li>说了这么多，来举个栗子吧：</li>
</ul>
<p>地址空间16KB，page大小64B，因此虚拟地址14位，其中8位VPN，6位offset。如下图，白色代表使用了，灰色代表没有使用：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220418144640.png" style="zoom:80%;" /></p>
<p>那么对于page table，一共有<script type="math/tex">2^8</script>个entry，整个page table大小位<script type="math/tex">2^8*4B=1KB</script>。</p>
<p>现在来看看多级页表怎么个情况。由于每个page是64B，那么可以将page table分成<script type="math/tex">\frac{1KB}{64B}=16</script>个page，每个page中保存了16个（<script type="math/tex">\frac{2^8}{16}=16</script>）个PTE。在page dir中，每page dir entry对应page table中的一个unit（也就是一个page 大小的 PTE），也就是page dir中有16个PDE。因此对于一个虚拟地址，我们需要用VPN的最高四位来代表在page dir中的index：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220418154014.png" style="zoom:80%;" /></p>
<p>一旦我们得到了page dir index，就可以计算出对应PDE的物理地址：</p>
<p>PDEAddr = PageDirBase + (PDIndex * sizeof(PDE))</p>
<p>有了PDE地址，就可以访问其中的内容，也就是保存的page table中的page的物理地址。如果ODE标记为无效，那么访问就是无效的会抛出异常。如果是有效的，那么我们就需要再从虚拟地址中VPN的剩下位中得到在page table中的某个page的page table entry的下标：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220418155036.png" style="zoom:80%;" /></p>
<p>有了page table entry的下标就可以计算出对应的物理地址：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220418155611.png" style="zoom:80%;" /></p>
<p>那么就可以访问对应PTE中的内容，也就是记录的地址空间中的page对应的物理块号PFN，于是就可以将虚拟地址翻译为物理地址了，至此目的应该就达成了。</p>
<ul>
<li>什么？还是觉得抽象？来看个实际的栗子吧：</li>
</ul>
<p>对于上述栗子，page dir的图长这样：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220418160618.png" style="zoom:80%;" /></p>
<p>实际上，没有多级页表时，我们需要把整个page table保存在内存中，但是有了多级页表，就只要保存page table中的两个page大小的PTE，再加上page dir（一个page大小），总共加起来只需要三个page的内存。</p>
<p>考虑这个虚拟 VPN 254 ：11 1111 1000 0000。用前四位来表示page dir 的index，也就是1111 ，十进制就是15，page dir的最后一个entry：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220418161230.png" style="zoom:80%;" /></p>
<p>根据这里保存的信息，我们就找到了对应page table的page的PFN：<strong>101</strong>。</p>
<p>接着我们用后面的四位 1110来得到page table中的page里面的index，也就是十进制<strong>14</strong>（倒数第二个），也就是地址空间的下标254的page table entry：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220418161622.png" style="zoom:80%;" /></p>
<p>假设这个entry中保存的PFN为55，这样就计算出page实际的物理地址：</p>
<p>PhysAddr = (PTE.PFN &lt;&lt; SHIFT) + offset = 00 1101 1100 0000 = 0x0DC0。</p>
<ul>
<li>虽然实际上流程不是很复杂，但是说起来真的好麻烦（不想再来一遍了）。</li>
<li>wc，等等怎么还有超过两级的多级页表？？？不想再说了，其实实际原理都是一样的，只不过又加了一层，需要多翻译一次而已：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220418162606.png" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220418162656.png" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220418162718.png" style="zoom:80%;" /></p>
<p>实际上超过两级的页表还是很有必要的，因为有可能page dir过大保存在内存中还是很占内存，所以需要对page dir在分页，也就是大于两级的多级页表。</p>
<ul>
<li>可能还有一些更节省空间的方法，比如 Inverted Page Tables 或 Swapping the Page Tables to Disk，目前看不动了。所以，summary：</li>
</ul>
<h2 id="20-6-Summary"><a href="#20-6-Summary" class="headerlink" title="20.6 Summary"></a>20.6 Summary</h2><ul>
<li>我们的目的就是节省内存空间，因此要想方法把page table变小，于是就有了多级页表，也就是page table的page table。</li>
</ul>
]]></content>
      <categories>
        <category>Operating System</category>
        <category>Virtualization</category>
        <category>Memory</category>
      </categories>
      <tags>
        <tag>Operating System</tag>
        <tag>Virtualization</tag>
        <tag>Memory</tag>
      </tags>
  </entry>
  <entry>
    <title>22. Beyond Physical Memory: Policies</title>
    <url>/2022/10/27/22-Beyond-Physical-Memory-Policies/</url>
    <content><![CDATA[<h1 id="22-Beyond-Physical-Memory-Policies"><a href="#22-Beyond-Physical-Memory-Policies" class="headerlink" title="22. Beyond Physical Memory: Policies"></a>22. Beyond Physical Memory: Policies</h1><ul>
<li>接着上一节的内容来学习replacement policy，问题：OS如何决定从内存中替换哪些page？<span id="more"></span>
</li>
</ul>
<h2 id="22-1-Cache-Management"><a href="#22-1-Cache-Management" class="headerlink" title="22.1 Cache Management"></a>22.1 Cache Management</h2><ul>
<li>内存中保存了所有page的一部分，因此内存可以看作虚拟内存page的<strong>cache</strong>。因此在做replacement的时候的目标就是降低<strong>cache misses</strong>或者提高<strong>cache hits</strong>。</li>
<li>有了cache misses和cache hits就可以计算<strong>average memory access time (AMAT)</strong>，<script type="math/tex">AMAT=T_{M}+(P_{Miss}*T_{D})</script>，其中<script type="math/tex">T_{M}</script>内存访问时间，<script type="math/tex">T_{D}</script>代表磁盘访问时间，<script type="math/tex">P_{Miss}</script>代表一次miss的概率。</li>
<li>由于<script type="math/tex">T_D</script>通常比<script type="math/tex">T_M</script>大非常多，因此要尽可能地减少访问磁盘的时间，也就是降低<script type="math/tex">P_{Miss}</script>。</li>
</ul>
<h2 id="22-2-The-Optimal-Replacement-Policy"><a href="#22-2-The-Optimal-Replacement-Policy" class="headerlink" title="22.2 The Optimal Replacement Policy"></a>22.2 The Optimal Replacement Policy</h2><ul>
<li>Belady提出的MIN可能是最好的替换策略（但是非常难实现），思路是每次替换都替换在将来，离现在时间最远处会被访问的page。</li>
</ul>
<p>举个栗子来看看，假设程序需要依次访问如下page： 0, 1, 2, 0, 1, 3, 0, 3, 1, 2, 1，并且内存最多只能加载进三个page，采用上述方法是会发生这种情况：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220424093204.png" style="zoom:80%;" /></p>
<p>可以看到前三次访问都是miss，这是正常的，因为刚开始所有的page都还没有被加载进内存，这种现象称为<strong>cold-start miss</strong>或者<strong>compulsory miss</strong>。在首次访问page 3时发生miss，这时看一下访问page的顺序，发现page是最远才会访问到的（在倒数第二位），因此替换page 2装入page 3。</p>
<p>在倒数第二次访问page 2时又发生miss，根据这个策略，选择page 0或者page 3是一样的。</p>
<p>可以计算这种方法的命中率为<script type="math/tex">\frac{Hits}{Hits+Misses}=\frac{6}{6+5}=54.5\%</script>，如果不算前三次compulsory miss的话，命中率可以达到85.7%。</p>
<ul>
<li>这种方法可以有效提高命中率，但是通常情况下，未来是未知的，一般不知道程序要访问的page顺序，因此这种方法只能作为理想情况，用于和其他策略进行对比。</li>
</ul>
<h2 id="22-3-A-Simple-Policy-FIFO"><a href="#22-3-A-Simple-Policy-FIFO" class="headerlink" title="22.3 A Simple Policy: FIFO"></a>22.3 A Simple Policy: FIFO</h2><ul>
<li>这种策略比较简单，先进先出，<strong>FIFO</strong> (first-in, first-out) 。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220424094011.png" style="zoom:80%;" /></p>
<p>可以计算出命中率为36.4%，不算compulsory miss的话是57.1%。</p>
<p>FIFO的特点就在于比较简单容易实现，但是问题在于性能较差，很有可能会替换出即将要访问的page。这种现象也叫做<strong>Belady’s Anomaly</strong>。</p>
<h2 id="22-4-Another-Simple-Policy-Random"><a href="#22-4-Another-Simple-Policy-Random" class="headerlink" title="22.4 Another Simple Policy: Random"></a>22.4 Another Simple Policy: <strong>Random</strong></h2><ul>
<li>这种策略更简单，每次替换是随机替换。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220424094555.png" style="zoom:80%;" /></p>
<p>重复进行10000次实验，可得到结果：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220424094845.png" style="zoom:80%;" /></p>
<h2 id="22-5-Using-History-LRU"><a href="#22-5-Using-History-LRU" class="headerlink" title="22.5 Using History: LRU"></a>22.5 Using History: LRU</h2><ul>
<li>FIFO和Random存在的问题就是它们很可能会替换出一些重要的page，也就是可能即将要访问的page。以史为鉴，可知兴替，因此我们必须要考虑history。比如，如果程序在不久前刚访问了一个page，那么很有可能在不远的将来还会继续访问这个page。有两种历史信息可以用来做参考：</li>
</ul>
<p>第一是frequency，如果一个page在过去多次被访问到，那么在做替换时也许就不该考虑这个page；</p>
<p>第二是recency，如果一个page刚刚才被访问到，那么也不应该考虑替换这个page。</p>
<ul>
<li>因此就有两种策略可以使用了：</li>
</ul>
<p><strong>Least-Frequently-Used (LFU)</strong>：淘汰一段时间内，使用次数最少的page。</p>
<p><strong>Least-Recently-Used (LRU)</strong> ：淘汰最长时间没有被使用的page。</p>
<p>以LRU为例，康康效果：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220424100404.png" style="zoom:80%;" /></p>
<p>首次访问page 3时miss，往前看，page 0和page 1都是最近被访问到的，因此选择page 2做替换。</p>
<p>同理倒数第二行访问page 2时miss，往前看，page 1和page 3都是最近访问到的，因此选择page 0做替换。</p>
<h2 id="22-7-Implementing-Historical-Algorithms"><a href="#22-7-Implementing-Historical-Algorithms" class="headerlink" title="22.7 Implementing Historical Algorithms"></a>22.7 Implementing Historical Algorithms</h2><ul>
<li>要想实现LRU是需要硬件的帮助的，硬件需要记录每一个page的上次访问时间，这样在做page替换的时候，就可以扫描page的访问时间，找到最近没有被访问的page。</li>
<li>但是这么做的开销也是很大的，假设内存4GB，page 4KB，也就是说有一百万个page，那么就需要对这么多的page进行扫描。问题来了，有没有一种方法可以减少开销但是性能和LRU差不多呢？</li>
</ul>
<h2 id="22-8-Approximating-LRU"><a href="#22-8-Approximating-LRU" class="headerlink" title="22.8 Approximating LRU"></a>22.8 Approximating LRU</h2><ul>
<li>上述问题的答案是肯定的，可以采用Approximating LRU。思想是，通过硬件的支持，加一个<strong>use bit</strong>（或者叫<strong>reference bit</strong>），每个page都有一个use bit，use bit保存在内存中。当一个page被访问时，硬件就将其use bit设为1，但是硬件从不将use bit设为0，因为那是OS需要做的事情。</li>
<li>如何利用这个use bit来实现Approximating LRU呢？下面介绍<strong>clock algorithm</strong> ：</li>
</ul>
<p>假设所有page的信息都以循环列表的形式记录，算法开始时，clock hand指向某一个page。当发生page替换时，检查clock hand指向的page，如果该page的use bit为1，那么将该page的use bit设为0，并且将clock hand向后移动一位；如果该page的use bit为0，那么就是用该page作为替换出去的page。</p>
<ul>
<li>尽管时钟算法的性能比不了LRU，但是肯定比考虑所有page的上次访问时间要快，并且性能比完全不考虑过去的傻子算法要好。</li>
</ul>
<h2 id="22-9-Considering-Dirty-Pages"><a href="#22-9-Considering-Dirty-Pages" class="headerlink" title="22.9 Considering Dirty Pages"></a>22.9 Considering Dirty Pages</h2><ul>
<li>对时钟算法还可以在做一点改进，那就是考虑page是否修改过。因为如果一个在内存中的page最近被修改过，那在将这个page替换出内存的时候，还需要将修改内容写入磁盘，那肯定是很耗时的；如果没有修改过的话，直接将这个page替换出内存就好了。因此，假设上次访问时间相同的两个page，应当优先考虑替换出没有被修改过的page。</li>
<li>因此再加一位，<strong>modified bit</strong>（或者叫<strong>dirty bit</strong>）。</li>
</ul>
<p>时钟算法做相应调整，当发生page替换时，首先选择最近没有被访问并且没有被修改的，也就是use bit为0并且dirty bit为0；其次选择最近没有被访问过但是修改过的，也就是use bit为0并且dirty bit为1；如果use bit为1，那就设为0，向后移动clock hand。</p>
<h2 id="22-12-Summary"><a href="#22-12-Summary" class="headerlink" title="22.12 Summary"></a>22.12 Summary</h2><ul>
<li>本节学习了不同的page置换算法，现代OS有的选用时钟算法。</li>
<li>不管采用多完美的算法，总是会发生cache miss，因此设计更好的算法还不如买一块更大的内存！</li>
</ul>
]]></content>
      <categories>
        <category>Operating System</category>
        <category>Virtualization</category>
        <category>Memory</category>
      </categories>
      <tags>
        <tag>Operating System</tag>
        <tag>Virtualization</tag>
        <tag>Memory</tag>
      </tags>
  </entry>
  <entry>
    <title>28. Locks</title>
    <url>/2022/10/27/28-Locks/</url>
    <content><![CDATA[<h1 id="28-Locks"><a href="#28-Locks" class="headerlink" title="28. Locks"></a>28. Locks</h1><ul>
<li>并发中最基本的问题就是如何保证一段代码执行的原子性，这一章的<strong>lock</strong>就是用来解决这个问题的。<span id="more"></span>
</li>
</ul>
<h2 id="28-1-Locks-The-Basic-Idea"><a href="#28-1-Locks-The-Basic-Idea" class="headerlink" title="28.1 Locks: The Basic Idea"></a>28.1 Locks: The Basic Idea</h2><ul>
<li>对于更新共享变量的这段代码，也就是critical section：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220504134512.png" style="zoom:80%;" /></p>
<p>使用lock后，代码长这样：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220504134557.png" style="zoom:80%;" /></p>
<p>首先声明一个全局变量叫做mutex，这个变量中保存着这个lock当前时刻的状态，可用：<strong>available (or unlocked or free)</strong> 或不可用<strong>acquired (or locked or held)</strong>。接着在进入critical section之前先lock()，也就是申请占用mutex，如果当前mutex的状态为空闲，那就申请成功，进入critical section；这时如果有其他线程再调用lock()申请占有mutex，就会被阻塞，知道mutex被释放。最后在critical section结束后，占有mutex的线程调用unlock()对mutex进行释放。</p>
<h2 id="28-2-Pthread-Locks"><a href="#28-2-Pthread-Locks" class="headerlink" title="28.2 Pthread Locks"></a>28.2 Pthread Locks</h2><ul>
<li>POSIX库中使用mutex，给不同线程之间提供互斥  <strong>mutual exclusion</strong> 。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220504140629.png" style="zoom:80%;" /></p>
<h2 id="28-3-Building-A-Lock"><a href="#28-3-Building-A-Lock" class="headerlink" title="28.3 Building A Lock"></a>28.3 Building A Lock</h2><ul>
<li>上面讲了讲lock的基本工作方式，下面就该讲一讲如何构建一个lock了。问题来了，高效的lock提供了互斥，并且开销很低。硬件需要提供哪些帮助？OS又需要提供什么？</li>
</ul>
<h2 id="28-4-Evaluating-Locks"><a href="#28-4-Evaluating-Locks" class="headerlink" title="28.4 Evaluating Locks"></a>28.4 Evaluating Locks</h2><ul>
<li>在谈构建lock之前，首先应该明白我们的lock应该实现哪些目的，如何评估一种lock。下面介绍几种评估lock的指标。</li>
<li>第一，correctness，lock是否能够完成基本任务，也就是为不同线程之间提供互斥，防止多个线程同时进入critical section。</li>
<li>第二，fairness。当lock处于free状态时，lock是否能保证每个线程在竞争lock的时候是公平竞争？或者说，是否存在这种情况，一个线程因为一直竞争不到lock而产生饥饿现象？</li>
<li>第三，performance，特指使用 lock的时间开销。这里有多种情况需要考虑。第一种情况是无竞争时，一个运行的线程占用锁再释放锁的时间开销是多少？第二种情况，多个线程在单核CPU上竞争lock，这时时间开销是多少？最后，当使用多核CPU的时候，情况又是怎样？</li>
</ul>
<h2 id="28-5-Controlling-Interrupts"><a href="#28-5-Controlling-Interrupts" class="headerlink" title="28.5 Controlling Interrupts"></a>28.5 Controlling Interrupts</h2><ul>
<li>最早的提供互斥的一种办法就是，为critical section关闭中断。这种方法是为单处理器的系统发明的，代码长这样：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220504144942.png" style="zoom:80%;" /></p>
<p>在进入critical section之前关闭中断，这样就可以保证该线程可以执行完critical section的代码。当执行完毕后再打开中断。</p>
<p>这种方法的好处就是简单。</p>
<p>但是缺点很严重，也很多。第一，关闭中断是特权操作，也就意味着线程要执行特权操作。这是很不安全的，假如这个线程不老实，它不按照规矩在critical section前后进行lock()和unlock()，而是在所有代码一开始就lock()，直到代码结束才unlock()，那它就可以独享CPU！第二，这种做法对于多处理器是不适用的。假设关闭中断的线程是在A处理器上运行，这时只是关闭了A处理器的中断，但是其他处理器并不受影响，其他线程还可以通过在其他处理器上运行进入critical section。第三，关闭中断可能会让一些中断丢失。想象一下假如一个线程之前请求I/O，但是现在关闭中断了，那当这个线程I/O请求完毕后该怎么办？最后，就是低效的问题。打开中断或者关闭中断可能会让系统变得更慢。</p>
<p>因此，这种方法还是不行的，再想想其他办法。</p>
<h2 id="28-6-A-Failed-Attempt-Just-Using-Loads-Stores"><a href="#28-6-A-Failed-Attempt-Just-Using-Loads-Stores" class="headerlink" title="28.6 A Failed Attempt: Just Using Loads/Stores"></a>28.6 A Failed Attempt: Just Using Loads/Stores</h2><ul>
<li>不使用上一节的方法，那就要依靠CPU硬件和其提供的指令来构建一个lock。想法很简单，使用一个变量（flag）来表明当前是否有线程在占用lock。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220504151449.png" style="zoom:80%;" /></p>
<p>当lock()时，<strong>test</strong> flag是否为1，如果flag为1表示lock正在被占用，线程就循环等待；当flag不为1时，就将flag设置为1表示该进程占用了lock。unlock()就将flag设为0表示释放lock。</p>
<ul>
<li>这种方法有两个问题。</li>
</ul>
<p>第一个是正确性，它并不能够真的实现互斥。像下图这种情况，可能两个线程会同时进入critical section。</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220504152008.png" style="zoom:80%;" /></p>
<p>第二个问题是性能，当flag为1时，线程就需要循环等待。而在其循环等待的时候也是在占用CPU的，这就造成了CPU的浪费。</p>
<h2 id="28-7-Building-Working-Spin-Locks-with-Test-And-Set"><a href="#28-7-Building-Working-Spin-Locks-with-Test-And-Set" class="headerlink" title="28.7 Building Working Spin Locks with Test-And-Set"></a>28.7 Building Working Spin Locks with Test-And-Set</h2><ul>
<li>上面两种都不行，那就需要用硬件的帮助了。硬件提供了<strong>test-and-set</strong>指令：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220504153908.png" style="zoom:80%;" /></p>
<p>test-and-set指令是原子的，可以看作该指令要么全不执行要么全部执行。test-and-set中，返回old指针的值，并且将old指针的值改为new。这就保证了原子性。代码就变成了这样：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220504154126.png" style="zoom:80%;" /></p>
<p>可以看到在lock()中，由于test-and-set的原子性，可以保证lock的原子性。</p>
<ul>
<li>通过这种方式实现的lock一般叫做<strong>spin lock</strong>，是最简单的一种，不停的在CPU上spin直到lock可用。在单处理器上使用这种锁，需要使用抢占式调度器。</li>
</ul>
<h2 id="28-8-Evaluating-Spin-Locks"><a href="#28-8-Evaluating-Spin-Locks" class="headerlink" title="28.8 Evaluating Spin Locks"></a>28.8 Evaluating Spin Locks</h2><ul>
<li>首先是正确性，它是否提供了线程间的互斥？答案是yes，它可以保证一次只有一个线程进入critical section。</li>
<li>接着是公平性，它是否可以保证没有线程会因为一直竞争不到lock而饥饿？答案是no，一个在spin的线程可能会一直spin下去。</li>
<li>最后是性能，使用它的开销如何？第一种情况，多线程运行在单处理器上竞争lock，这种情况下性能很差。如果有一个线程占用了lock，那么其余线程在上CPU时就只能spin，什么别的事情也做不了。第二种情况，多线程运行在多处理器上竞争lock，这种情况下要好一点。假设线程A占用了lock，运行在CPU1上，线程B运行在CPU2上竞争lock。可能critical section比较短，由于线程A一直在运行，很快就让出lock，其他线程就可以竞争到lock。</li>
</ul>
<h2 id="28-9-Compare-And-Swap"><a href="#28-9-Compare-And-Swap" class="headerlink" title="28.9 Compare-And-Swap"></a>28.9 Compare-And-Swap</h2><ul>
<li>硬件提供的另一条原子指令是<strong>compare-and-swap</strong>或者叫<strong>compare-and-exchange</strong>：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220504160544.png" style="zoom:80%;" /></p>
<p>基本思想就是检查ptr指向的值是否和expected一样。如果一样，就更新ptr指向的值为new；如果不一样就什么都不做。最后返回原ptr指向的值。</p>
<ul>
<li>有了这条指令，lock()就变成了这样：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220504160758.png" style="zoom:80%;" /></p>
<p>其他的代码和使用test-and-set指令的代码差不多。</p>
<ul>
<li>使用compare-and-swap指令会比test-and-set指令能做的事情更多，这会在<strong>lock-free-synchronization</strong>中体现。如果不讨论这个话题，只构建一个简单的锁，使用两种指令是一样的。</li>
</ul>
<h2 id="28-10-Load-Linked-and-Store-Conditional"><a href="#28-10-Load-Linked-and-Store-Conditional" class="headerlink" title="28.10 Load-Linked and Store-Conditional"></a>28.10 Load-Linked and Store-Conditional</h2><ul>
<li>一些平台提供了一些指令来构建lock。例如，在MIPS架构中，<strong>load-linked</strong>和<strong>store-conditional</strong>指令可以用来构建lock和其他一些并发结构。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220505092435.png" style="zoom:80%;" /></p>
<p>load-linked指令返回一个指针所指向的值；</p>
<p>store-conditional，如果在上一次调用load-linked后没有更新ptr的值，就将ptr的值设置为value并且返回1；如果有更新，返回0。</p>
<ul>
<li>构建lock的代码长这样：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220505092800.png" style="zoom:80%;" /></p>
<p>在lock()中，首先线程不断循环等待flag的值为0。当flag的值为0后，再尝试使用store-conditional将flag的值设置为1，如果设置成功，all done；失败的话就重新进入循环。</p>
<ul>
<li>考虑这种情况，一个线程使用LL返回值为0 ，但此时由于中断下CPU；另一个线程上CPU使用LL得到返回值也是0 。但这并不会有任何影响，因为两个线程中只有一个线程能够顺利执行SC并且得到返回值1，另一个线程在执行SC的时候由于最近对ptr有更新，因此返回值为0。因此这种方法可以保证正确性。</li>
<li>对于lock()还有一种更简洁的等价写法：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220505093620.png" style="zoom:80%;" /></p>
<h2 id="28-11-Fetch-And-Add"><a href="#28-11-Fetch-And-Add" class="headerlink" title="28.11 Fetch-And-Add"></a>28.11 Fetch-And-Add</h2><ul>
<li>最后一个硬件原语是<strong>fetch-and-add</strong>，原子地增加一个value的值，把返回原值：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220505094146.png" style="zoom:80%;" /></p>
<ul>
<li>使用fetch-and-add指令可以构建<strong>ticket lock</strong>：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220505094238.png" style="zoom:80%;" /></p>
<p>ticket lock中使用两个变量来构建lock。</p>
<p>在lock()中，先使用fetch-and-add来获取当前线程的”turn”，当lock-&gt;turn==myturn的时候，代表该线程获取了锁。此时如果别的线程想要占有锁，会被卡在lock-&gt;turn是否等于myturn的判断这里。</p>
<p>在unlock()中，对lock-&gt;turn进行加1。</p>
<ul>
<li>这种方法和之前的方法不同的是，它保证了<strong>所有进程都在未来的某段时间一定能获得锁</strong>。一旦一个线程的ticket被赋值，在未来的某个时刻，一定能够有lock-&gt;turn==ticket。这个特性是之前的方法中没有的。</li>
</ul>
<h2 id="28-12-Too-Much-Spinning-What-Now"><a href="#28-12-Too-Much-Spinning-What-Now" class="headerlink" title="28.12 Too Much Spinning: What Now?"></a>28.12 Too Much Spinning: What Now?</h2><ul>
<li>之前的这些方法确实可以达到我们对critical section互斥访问的目的，但是性能很差。为啥性能很差呢？因为当一个线程在竞争锁时，一旦发现锁被占用，就只能通过spin来循环等待。想想N个线程，轮流上CPU，都在竞争同一个锁。开始时，第一个线程竞争到了锁，因此剩下N-1个锁在上CPU时就只能循环等待，造成了CPU资源的浪费。问题来了，如何才能使得lock不浪费CPU资源？到这个份上，光凭借硬件已经解决不了问题了，需要OS的帮助。</li>
</ul>
<h2 id="28-13-A-Simple-Approach-Just-Yield-Baby"><a href="#28-13-A-Simple-Approach-Just-Yield-Baby" class="headerlink" title="28.13 A Simple Approach: Just Yield, Baby"></a>28.13 A Simple Approach: Just Yield, Baby</h2><ul>
<li>如何解决上述问题？很简单的一个方法是，在线程要spin循环等待时，主动放弃CPU给其他线程运行。so, just yield, baby!</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220505143027.png" style="zoom:80%;" /></p>
<p>在lock()中，通过yield()让一个线程放弃CPU，让其他的线程上CPU运行。假设线程只有三种状态（running、ready和blocked），yield()只是让线程从running状态变为ready状态。</p>
<ul>
<li>当只有两个线程时，这种方法的性能看起来还不错。当一个线程占有锁时，另一个线程在运行时就只能yield()放弃CPU，从而第一个线程可以完成criticla section，这样第二个线程就可以进入critical section。</li>
<li>但是当线程很多的时候，假设有100个线程。第一个线程获得了锁，剩下99个线程在运行时必须全部yield()。这种情况下，尽管比spin的性能要好一点，但性能还是很差的。因为99个线程都需要context swtich，这些开销也是很大的。</li>
<li>并且这种方法没有解决饥饿问题。</li>
</ul>
<h2 id="28-14-Using-Queues-Sleeping-Instead-Of-Spinning"><a href="#28-14-Using-Queues-Sleeping-Instead-Of-Spinning" class="headerlink" title="28.14 Using Queues: Sleeping Instead Of Spinning"></a>28.14 Using Queues: Sleeping Instead Of Spinning</h2><ul>
<li>之前问题的本质是，由调度器决定了哪一个线程继续运行。如果调度器做了错误的选择，那么线程就会spin或者是yield。这都会造成浪费和可能的饥饿问题。因此必须显示地控制接下来到底哪一个线程上CPU运行，那就需要OS的帮助了，通过一个队列来记录哪些线程当前正在等待获取lock。</li>
<li>简单起见，使用Solaris OS的两个系统调用：park()，将运行中的线程转为sleep；unpark(threadID)，唤醒threadID进程。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220505144845.png" style="zoom:80%;" /></p>
<p>首先，还是使用了test-and-set，以及一个队列。其次队列是用来控制下一个是谁来获得lock，因此就避免了饥饿。</p>
<p>可以看到在这种结构中，多了一个guard，guard锁用来控制对flag加锁和队列操作。这种方法并没有完全避免spin，因为对于guard的锁等待还是通过spin来完成的。</p>
<p>在lock()中，首先试图通过test-and-set申请获得guard锁。在获得guard锁后，接下来的一系列操作可以保证是原子的，因为这是由guard锁保证的，其他线程由于获取不了guard锁，因此无法进入下面的这一系列操作。那么这一系列操作到底做了什么事情呢？首先判断flag锁是否空闲，如果空闲就占用flag锁，并且释放guard锁；如果flag锁正在被占用，首先将当前线程加入队列，然后释放guard锁，再通过park()将自己sleep。你可能会有疑问，什么情况下才会进入这个else？也就是什么时候flag会被其他的线程占用。考虑这种情况，初始时，什么都没发生。线程A顺利地占用了guard锁，接着 占用了flag锁，释放了guard锁。这时由于时间片中断线程A下CPU，线程B来了，B可以获得guard锁，但是由于flag锁被A占用，因此只能进入else，被迫sleep。</p>
<p>在unlock()中，首先还是先申请guard，这个锁就是个通行证，没这个锁就不能进行下面的操作。接着判断队列是否为空，如果为空就代表没有线程在等待竞争flag锁，那就简单了，直接释放掉flag锁就好了。如果队列非空，代表当前有线程在等待竞争flag锁，那就调用unpark(ID)来将对头线程唤醒。最后释放掉guard锁。你可能又会有疑问了，为什么队列非空时，在调用unpark()后不释放掉flag锁，也就是将flag设置为0？要回答这个问题你要想一想，通过unpark()唤醒的线程是在哪里进入sleep的。很简单，是在lock()中的park()进入sleep的，那么在这里通过unpark()将其唤醒，这个线程就会感觉自己是在park()之后醒来的，但是lock()中在park()之后就结束了，该线程就可以获得flag锁了，但是如何将flag锁标记为被占用呢？只能在unpark()这里不对flag锁做任何处理，让其值保持为1，这样就好像是下一个线程占用了锁。</p>
<h2 id="28-15-Different-OS-Different-Support"><a href="#28-15-Different-OS-Different-Support" class="headerlink" title="28.15 Different OS, Different Support"></a>28.15 Different OS, Different Support</h2><ul>
<li>如题，不同OS的支持是不一样的，因此构建lock的方式也是不同的。不再举例了。</li>
</ul>
<h2 id="28-16-Two-Phase-Locks"><a href="#28-16-Two-Phase-Locks" class="headerlink" title="28.16 Two-Phase Locks"></a>28.16 Two-Phase Locks</h2><ul>
<li>略去。</li>
</ul>
<h2 id="28-17-Summary"><a href="#28-17-Summary" class="headerlink" title="28.17 Summary"></a>28.17 Summary</h2><ul>
<li>主要讲的就是如何构建lock，通过硬件和OS的支持来构建lock。不同的系统具体实现方式都是不一样的。</li>
</ul>
]]></content>
      <categories>
        <category>Operating System</category>
        <category>Concurrency</category>
      </categories>
      <tags>
        <tag>Operating System</tag>
        <tag>Concurrency</tag>
      </tags>
  </entry>
  <entry>
    <title>29. Lock-based Concurrent Data Structures</title>
    <url>/2022/10/27/29-Lock-based-Concurrent-Data-Structures/</url>
    <content><![CDATA[<h1 id="29-Lock-based-Concurrent-Data-Structures"><a href="#29-Lock-based-Concurrent-Data-Structures" class="headerlink" title="29. Lock-based Concurrent Data Structures"></a>29. Lock-based Concurrent Data Structures</h1><ul>
<li>有了lock之后，就可以用在一些数据结构中，使其变得<strong>thread safe</strong>线程安全。问题来了：给定一个数据结构时，如何加入lock使其能够正常工作？如何加入lock才能有好的性能，使得多线程可以尽可能多地并发访问结构？</li>
</ul>
<span id="more"></span>
<h2 id="29-1-Concurrent-Counters"><a href="#29-1-Concurrent-Counters" class="headerlink" title="29.1 Concurrent Counters"></a>29.1 Concurrent Counters</h2><ul>
<li>以一个最简单的counter数据结构开始：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220507091715.png" style="zoom:80%;" /></p>
<ul>
<li>如何将上面的counter变成线程安全的counter？</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220507091809.png" style="zoom:80%;" /></p>
<p>可以看到，在counter中加入了lock，并且每次读写数据时都需要对其进行加锁。</p>
<ul>
<li>让我们来康康现在这个线程安全的lock性能如何。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220507092034.png" style="zoom:80%;" /></p>
<p>上图（Precise）展示了从1到4个线程，每个线程更新counter一百万次，实验环境是Intel2.7GHz I5 CPU。可以看到，随着线程数目的增大，该counter的性能逐渐变差。</p>
<ul>
<li>Scalable Counting</li>
</ul>
<p>如何解决上述多线程时性能价差的问题呢？其中一种方法叫做<strong>approximate counter</strong>。approximate counter对于每一个CPU都会设置一个局部物理计数器，并且还有一个全局计数器。对于这些计数器，相应地每个计数器都要有一个lock。</p>
<p>基本思路是：一个运行的线程要更新计数器时，更新的是其所在CPU对应的计数器，由于每个CPU对应计数器都有一个lock，因此在一个CPU上更新一定是同步的。因为每个CPU都有自己的计数器去，那么多CPU之间的线程，可以无连接的更新局部计数器，因此是scalable的。</p>
<p>但是，如何保证全局计数器保存的数值是最新的呢？局部计数器要定期把自己保存的值转移到全局计数器上，因此需要申请全局lock然后将自己的值加到全局计数器上，最后把自己的值重置为0。</p>
<p>问题又来了，将局部计数器的值转移到全局计数器上的频率是多少呢？这是由一个阈值S决定的，当局部计数器的值超过S，就转移。如果S较小，那么计数器可能就没有那么的scalable；如果S较大，计数器更scalable，但是可能计数值可能就没那么准确。</p>
<p>如果S=5：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220507095302.png" style="zoom:80%;" /></p>
<p>代码长这样：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220507094913.png" style="zoom:80%;" /></p>
<p>还是来康康性能，S值为1024：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220507095026.png" style="zoom:80%;" /></p>
<p>可以看到，Approximate性能非常好。</p>
<p>下图展示了四个线程，每个线程更新一百万次，S对性能的影响：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220507095203.png" style="zoom:80%;" /></p>
<h2 id="29-2-Concurrent-Linked-Lists"><a href="#29-2-Concurrent-Linked-Lists" class="headerlink" title="29.2 Concurrent Linked Lists"></a>29.2 Concurrent Linked Lists</h2><ul>
<li>现在来康康稍微复杂一点点的，链表。加入lock后初级版本长这样：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220507095434.png" style="zoom:80%;" /></p>
<p>可以看到，在对链表进行读写操作前，先申请lock，在所有操作都结束后，再释放lock。</p>
<p>这种做法是有大概40%几率出bug的，咱也不知道会出什么bug，但显然这种方法就是不行。</p>
<p>因此，稍稍做一些调整，让对于锁的申请和释放只在真正的critical section前后进行，并且假设malloc()本身就是线程安全的：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220507100232.png" style="zoom:80%;" /></p>
<ul>
<li><strong>Scaling Linked Lists</strong></li>
</ul>
<p>上面这个版本可以实现基本的线程安全了，但是还不够scalable。一种解决办法叫做<strong>hand-over-hand locking</strong>。思想非常简单，不再给每个链表一个lock，而是给链表中的每一个Node一个lock。对链表遍历时，必须先获取下一个node的lock，再释放当前node的lock。</p>
<h2 id="29-3-Concurrent-Queues"><a href="#29-3-Concurrent-Queues" class="headerlink" title="29.3 Concurrent Queues"></a>29.3 Concurrent Queues</h2><ul>
<li>其实队列和链表也差不多，最简单的一种方式实现就是加一把大的lock，这里就不再赘述了。这一节来看看一种并发性更好的实现方式，代码长这样：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220507220228.png" style="zoom:80%;" /></p>
<p>和普通加一把大lock不同的是，这里加了两个lock，队头队尾分别一个，这么做的目的就是提高入队操作和出队操作的并发性。并且，在这里加了一个dummy node，目的是为了将头尾操作分开。</p>
<p>这里的实现方式其实还是有问题的，并不能满足全部关于队列的使用需求。</p>
<h2 id="29-4-Concurrent-Hash-Table"><a href="#29-4-Concurrent-Hash-Table" class="headerlink" title="29.4 Concurrent Hash Table"></a>29.4 Concurrent Hash Table</h2><ul>
<li>线程安全的hash table，使用之前的线程安全的链表。每个BUCKETS一把lock，因此性能较好。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220507221352.png" style="zoom:80%;" /></p>
<p>与链表的性能对比图：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220507221504.png" style="zoom:80%;" /></p>
<h2 id="29-5-Summary"><a href="#29-5-Summary" class="headerlink" title="29.5 Summary"></a>29.5 Summary</h2><ul>
<li>主要介绍了如何构建常见的线程安全的数据结构，链表、队列及hash table。</li>
</ul>
]]></content>
      <categories>
        <category>Operating System</category>
        <category>Concurrency</category>
      </categories>
      <tags>
        <tag>Operating System</tag>
        <tag>Concurrency</tag>
      </tags>
  </entry>
  <entry>
    <title>31. Semaphores</title>
    <url>/2022/10/27/31-Semaphores/</url>
    <content><![CDATA[<h1 id="31-Semaphores"><a href="#31-Semaphores" class="headerlink" title="31. Semaphores"></a>31. Semaphores</h1><ul>
<li>前面已经学习了使用lock和condition varivable来实现并发，这一节学习<strong>semaphore</strong>信号量。有了semaphore，就只有统一的原语操作了，可以用semaphore来实现lock和condition variavle的功能。问题来了：如何使用semaphore来代替lock和condition variable？semaphore的定义是怎样的？Binary semaphore是怎样的？</li>
</ul>
<span id="more"></span>
<h2 id="31-1-Semaphores-A-Definition"><a href="#31-1-Semaphores-A-Definition" class="headerlink" title="31.1 Semaphores: A Definition"></a>31.1 Semaphores: A Definition</h2><ul>
<li>一个semaphore有一个integer，并且可以对该值进行两个操作。在POSIX标准中，两个操作是sem_wait()和sem_post()。semaphore的初始值和要使用该semaphore进行什么操作有关，所以要先对其进行初始化：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220512092452.png" style="zoom:80%;" /></p>
<p>sem_init()对semaphore进行初始化，第一个参数是s的地址，第二个参数0表明同一个进程的线程可以共享该semaphore，第三个参数1代表semaphore的初始值。</p>
<p>初始化后就可以对semaphore进行sem_wait()和sem_post()两个操作：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220512092745.png" style="zoom:80%;" /></p>
<p>注意：当semaphore为负数时，其绝对值代表有多少个线程正在等待。</p>
<h2 id="31-2-Binary-Semaphores-Locks"><a href="#31-2-Binary-Semaphores-Locks" class="headerlink" title="31.2 Binary Semaphores (Locks)"></a>31.2 Binary Semaphores (Locks)</h2><ul>
<li>现在来看看如何使用semaphore来构建一个lock。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220512105434.png" style="zoom:80%;" /></p>
<p><strong>这里的X应该设置为1</strong>，这样就可以把semaphore当作lock来使用了。</p>
<ul>
<li>康康两个线程使用semaphore构建的lock的一种情况：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220512105641.png" style="zoom:80%;" /></p>
<h2 id="31-3-Semaphores-For-Ordering"><a href="#31-3-Semaphores-For-Ordering" class="headerlink" title="31.3 Semaphores For Ordering"></a>31.3 Semaphores For Ordering</h2><ul>
<li>semaphore也可以用来实现线程之间的同步等待，使用semaphore实现同步原语，和之前得condition varivable比较像。</li>
</ul>
<p>对于代码中得父线程和子线程，想实现父线程等待子线程结束再结束：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220512112731.png" style="zoom:80%;" /></p>
<p>也就是这种效果：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220512112821.png" style="zoom:80%;" /></p>
<p><strong>这种情况下semaphore的初始值应该为0。</strong>康康使用semaphore的两种情况：</p>
<p>第一种父线程sleep等待子线程：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220512113059.png" style="zoom:80%;" /></p>
<p>第二种父线程无须sleep等待子线程：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220512113125.png" style="zoom:80%;" /></p>
<h2 id="31-4-The-Producer-Consumer-Bounded-Buffer-Problem"><a href="#31-4-The-Producer-Consumer-Bounded-Buffer-Problem" class="headerlink" title="31.4 The Producer/Consumer (Bounded Buffer) Problem"></a>31.4 The Producer/Consumer (Bounded Buffer) Problem</h2><ul>
<li><p>使用semaphre来解决生产者消费者模型：</p>
</li>
<li><p><strong>First Attempt</strong>：</p>
</li>
</ul>
<p>使用两个semaphore，empty和full：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220512113603.png" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220512113635.png" style="zoom:80%;" /></p>
<p>生产者要等buffer有空间才能放数据，消费者要等buffer有数据才能取数据。简单起见，先将MAX设置为1。这种做法可以解决多线程的同步问题。</p>
<p>但是现在如果将MAX调大一点，比如10，并且有多个生产者，多个消费者。问题就来了，有可能会race condition。假设两个生产者，其中一个先执行了put()，但是在还没有对fill更新时，由于中断换另一个生产者运行，另一个生产者拿到了和上一个生产者相同的fill，这样二者就会向同一个fill位置上放入数据，就会导致数据丢失。那么该怎么办呢？</p>
<ul>
<li><strong>A Solution: Adding Mutual Exclusion</strong></li>
</ul>
<p>其实问题就在于忘记解决互斥问题了，也好办，加把lock就好了。</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220512140612.png" style="zoom:80%;" /></p>
<p>看起来好像很简单，但是这种做法是有问题的，有可能造成deadlock？在哪里？假设现在两个线程，一个生产者，一个消费者。消费者先上CPU运行，首先它拿到了mutex，然后由于full为0 ，被sleep。这时生产者开始运行，但是由于mutex被消费者拿到了，生产者不得不等待消费者释放锁，造成了循环等待的deadlock。</p>
<ul>
<li><strong>At Last, A Working Solution</strong></li>
</ul>
<p>解决方法也很简单，减小加锁的范围，只在真正的cirtical section加锁：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220512141008.png" style="zoom:80%;" /></p>
<h2 id="31-5-Reader-Writer-Locks"><a href="#31-5-Reader-Writer-Locks" class="headerlink" title="31.5 Reader-Writer Locks"></a>31.5 Reader-Writer Locks</h2><ul>
<li>读写锁也是一个很经典的问题，其实在对数据进行读写时，虽然不允许同时写入，但往往为了提高性能，同时读取是被允许的，并且对正确性也没有影响。使用semaphore来实现读写锁：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220512141332.png" style="zoom:80%;" /></p>
<p>可以看到一共使用了两把锁，其中一把lock用来读，另一把writelock用来写。</p>
<p>对于写，申请和释放锁的流程比较简单，因为某一时间只允许一个进程写数据，那么就单纯的申请释放锁就ok了。</p>
<p>对于读，由于可以允许多个读者，所以稍微复杂一点。申请时，申请到lock后，要将读者数+1。并且判断读者数是否为1，如果为1代表这个来的读者是第一个要读，那么就要申请writelock，如果没有线程在占用writelock写数据，该读者就可以开始读了；如果不为1，代表前面已经有读者在读了，那么该读者跟着一起读了。最后要将lock释放，以允许别的线程接着申请读锁。释放时，首先还是要申请lock，然后将读者数-1。如果读者数为0，代表没人读了，那就可以释放写锁了。如果不为0，代表还有人在读，不能释放读锁。最后释放写锁。</p>
<ul>
<li>这种读写锁呢，开销比较大。并且是偏向读进程的，很有可能造成写进程的饥饿。</li>
</ul>
<h2 id="31-6-The-Dining-Philosophers"><a href="#31-6-The-Dining-Philosophers" class="headerlink" title="31.6 The Dining Philosophers"></a>31.6 The Dining Philosophers</h2><ul>
<li>哲学家用餐问题也是很经典的问题，哲学家要么在吃饭，要么在思考。但是一个哲学家吃饭时需要两个叉子，每个哲学家只能拿到左右两边的叉子，哲学家和叉子的关系如图：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220512142407.png" style="zoom:80%;" /></p>
<p>虽然这个问题的实际价值不是很大，但是确实很有意思。如何解决这个问题使得每个哲学家不挨饿？</p>
<p>先看一种解法，首先设置两个辅助函数来申请叉子，当哲学家想申请左手边的叉子就调用left(p)，右手边的就right(p)。</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220512143357.png" style="zoom:80%;" /></p>
<p>还需要设置一些semaphore来帮助解决问题，这里每一个叉子设置一个semaphore，sem_t forks[5]。</p>
<ul>
<li><strong>Broken Solution</strong></li>
</ul>
<p>一种解法是这样：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220512143941.png" style="zoom:80%;" /></p>
<p>每个哲学家都要同时依次拿到左手和右手的叉子后才能吃饭。看起来好像可以解决问题，但实际上会产生deadlock。假设每个哲学家都在申请到了左手的叉子后由于中断换另一个线程运行，那么就会导致最后每一个哲学家都只拿到了左手的叉子，在等待右手的叉子，并且永远等不到。</p>
<ul>
<li><strong>A Solution: Breaking The Dependency</strong></li>
</ul>
<p>Dijkstra想出一种办法如下：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220512144133.png" style="zoom:80%;" /></p>
<p>对最后一个哲学家，他申请叉子的顺序是先申请右手边的，再申请左手边的，这样就可以有效避免deadlock。</p>
<ul>
<li>还有其他一些类似的问题，比如吸烟者问题，理发师问题等等。</li>
</ul>
<h2 id="31-7-Thread-Throttling"><a href="#31-7-Thread-Throttling" class="headerlink" title="31.7 Thread Throttling"></a>31.7 Thread Throttling</h2><ul>
<li>可以用semaphore来控制进程开太多的线程从而导致系统性能下降。</li>
</ul>
<h2 id="31-8-How-To-Implement-Semaphores"><a href="#31-8-How-To-Implement-Semaphores" class="headerlink" title="31.8 How To Implement Semaphores"></a>31.8 How To Implement Semaphores</h2><ul>
<li>康康一个简单版本的semaphore实现，叫做<strong>Zemaphores</strong>。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220512145035.png" style="zoom:80%;" /></p>
<h2 id="31-9-Summary"><a href="#31-9-Summary" class="headerlink" title="31.9 Summary"></a>31.9 Summary</h2><ul>
<li>semaphores是强大并且灵活的原语，可以用来解决并发问题。这一章主要讲了如何用semaphore来构建lock和condition variable，以及如何用semaphore来解决经典并发问题，如哲学家进餐，生产者消费者，读写锁。</li>
</ul>
]]></content>
      <categories>
        <category>Operating System</category>
        <category>Concurrency</category>
      </categories>
      <tags>
        <tag>Operating System</tag>
        <tag>Concurrency</tag>
      </tags>
  </entry>
  <entry>
    <title>30. Condition Variables</title>
    <url>/2022/10/27/30-Condition-Variables/</url>
    <content><![CDATA[<h1 id="30-Condition-Variables"><a href="#30-Condition-Variables" class="headerlink" title="30. Condition Variables"></a>30. Condition Variables</h1><ul>
<li>之前介绍了lock，以及使用lock构建的一些线程安全的数据结构。但是那并不是所有并发的内容，说到并发，怎么能不谈谈同步呢？并发中，一个线程等待另一个线程是很常见的事情。举个栗子，父线程要等待子线程结束才能结束：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220510092947.png" style="zoom:80%;" /></p>
<p>我们希望看到的结果是这样：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220510093145.png" style="zoom:80%;" /></p>
<p>那要怎么做才能实现上述目的呢？首先尝试使用一个共享变量：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220510094817.png" style="zoom:80%;" /></p>
<p>这种做法基本可以达到我们的目的，但是效率很低，因为父线程一直在spin。实际上，我们应该将父线程sleep，当子线程结束时，再awake父线程。那么问题来了：在多线程程序中，经常出现一个线程要等待另一个线程的。简单的做法就像上面这样，在条件满足前一直spin，但是很低效。那应该用什么方法来代替呢？<br><span id="more"></span></p>
<h2 id="30-1-Definition-and-Routines"><a href="#30-1-Definition-and-Routines" class="headerlink" title="30.1 Definition and Routines"></a>30.1 Definition and Routines</h2><ul>
<li>为了实现同步等待的目的，线程用到的叫做<strong>condition variable</strong>。condition variable是一个队列，当一些条件不满足时线程可以将自己放到这个队列中（wait）。当由于其他线程的操作使得其他该条件成立时，可以将在队列中的一个或多个线程唤醒（signal），允许他们继续运行。</li>
<li>声明condition variable，简单点可以直接pthread_cond_t c，每个condition variable都有两个原语：wait()和signal()。wait()原语将线程自己sleep；signal()原语可以将一个sleeping的线程唤醒，一般用于某个线程改变了某个条件后。特别的。POSIX库中长这样：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220510104332.png" style="zoom:80%;" /></p>
<p>​    你可能发现，在wait()中还传入了lock作为参数，wait()的作用就是<strong>原子地</strong>先将锁释放，然后将线程sleep。当线程被唤醒时，在wait()中必须重新申请占用lock，才能进行接下来的操作。这样可以避免race condition。</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220510110338.png" style="zoom:80%;" /></p>
<p>这样有两种情况：</p>
<p>第一种是父线程需要等待子线程，那么父线程就会被sleep。当子线程结束时，由于done=1，父线程会从wait()处被唤醒，这时父线程需要先的申请lock，如果子线程还没有释放lock，父线程无法进行下面的操作。</p>
<p>第二种情况，父线程无须等待子线程，那就没什么好说的了，按照流程进行下去。</p>
<p>下面来看一种更复杂的情况：生产者消费者模型。</p>
<h2 id="30-2-The-Producer-Consumer-Bounded-Buffer-Problem"><a href="#30-2-The-Producer-Consumer-Bounded-Buffer-Problem" class="headerlink" title="30.2 The Producer/Consumer (Bounded Buffer) Problem"></a>30.2 The Producer/Consumer (Bounded Buffer) Problem</h2><ul>
<li>一个或多个生产者以及一个或多个消费者，生产者向buffer中生产数据，消费者从buffer中取出数据消费。这种模型在实际系统中很常见，比如多线程的web服务器，生产者线程生产HTTP请求，消费者线程处理HTTP请求。等等。</li>
<li>因为有界buffer是共享资源，因此必须保证对其的同步操作，要避免race condition。</li>
</ul>
<p>首先来看简单的生产者和消费者，这里简单起见buffer只是一个整数值，后面会扩展的：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220510142913.png" style="zoom:80%;" /></p>
<p>生产者不停的生产数据，消费者不停的取出数据。其中put()，假设buffer是空的，然后将数据放进去后通过将count设置为1表明buffer已满；get()从buffer中取数据，然后将count设置为0，返回数据值。</p>
<p>对于这个模型，条件是这样：只有当count是0时，才能put()；只有count是1时，才能get()。因为你不能向已经满了的buffer在放数据，也不能从空的buffer中取数据。</p>
<ul>
<li>A Broken Solution</li>
</ul>
<p>现在假设只有一个生产者和一个消费者，现在要想实现生产者和消费者的同步该怎么做呢？也就是说实现，只有在生产者向buffer中生产数据后，消费者才能从buffer中取数据？只有lock是不够的，还需要用到condition variable。先来看一次失败的尝试：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220510143939.png" style="zoom:80%;" /></p>
<p>这种做法在只有一个生产者和一个消费者的时候是可行的，如果是多线程时，就会有两个问题。</p>
<p>第一，在判断count状态时使用了if语句。假设有两个消费者<script type="math/tex">T_{c1}、T_{c2}</script>，一个生产者<script type="math/tex">T_{p}</script>。考虑下面这种情况：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220510144719.png" style="zoom:80%;" /></p>
<p>问题在于，当<script type="math/tex">T_{p}</script>向buffer中put数据后，本应该让Ready的<script type="math/tex">T_{c1}</script>运行，但是被<script type="math/tex">T_{c2}</script>抢占了先机，当<script type="math/tex">T_{c2}</script>把数据取完之后，<script type="math/tex">T_{c1}</script>开始运行了，但这是已经没有数据了，ops。</p>
<p>问题的原因在于，当<script type="math/tex">T_{c1}</script>被唤醒成Ready状态后，没有立刻运行使其成为Run，在其真正Run之前，buffer的状态又发生了改变。</p>
<p>对于这种情况，可以将if改为while，那么可以解决第一个问题。变成这样：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220510150448.png" style="zoom:80%;" /></p>
<p>当判断语句是while时，现在<script type="math/tex">T_{c1}</script>被唤醒，然后由于while循环立即检查count的状态。如果Buffer为空，<script type="math/tex">T_{c1}</script>又会sleep。记住，在condition varivable中永远使用while循环，可能并不一定真的要重新检查条件，但是加上总没错的。</p>
<p>这虽然解决了第一个问题，但是第二个问题还没有解决。考虑下面这种情况：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220510151019.png" style="zoom:80%;" /></p>
<p>问题在于，一开始<script type="math/tex">T_{c1}、T_{c2}</script>都在sleep，接着<script type="math/tex">T_{p}</script>放入数据，接着<script type="math/tex">T_{p}</script>也sleep。<script type="math/tex">T_{c1}</script>被唤醒消费数据，然后试图去唤醒<script type="math/tex">T_{p}</script>，但是由于并不能控制唤醒哪个进程，完全有可能唤醒<script type="math/tex">T_{c2}</script>，ops，搞错了，<script type="math/tex">T_{c2}</script>醒来一看没有数据于是接着睡，<script type="math/tex">T_{c1}</script>认为自己唤醒了<script type="math/tex">T_{p}</script>，也开始睡，<script type="math/tex">T_{p}</script>自始至终都在睡，好嘛大家都在睡！</p>
<p>要想解决这个问题，就要让signal唤醒的线程正确。所以在这里要使用两个condition variable，代码长这样：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220510152646.png" style="zoom:80%;" /></p>
<p>对于生产者和消费者各分配一个condition variable，生产者生产数据后唤醒消费者的cv，消费者消费数据后唤醒生产者的cv。</p>
<ul>
<li><strong>The Correct Producer/Consumer Solution</strong></li>
</ul>
<p>上面的做法已经可以基本满足需求了，现在要做最后一点改变，将Buffer的大小扩大，这样就能够减小context switch以减少开销：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220510153007.png" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220510153019.png" style="zoom:80%;" /></p>
<h2 id="30-3-Covering-Conditions"><a href="#30-3-Covering-Conditions" class="headerlink" title="30.3 Covering Conditions"></a>30.3 Covering Conditions</h2><ul>
<li>还有一个问题：唤醒线程的时候，应该唤醒哪一个？</li>
</ul>
<p>考虑这种情况，线程A申请100字节空间，线程B申请10字节空间，但是由于内存空间不足，两个线程依次sleep。不久后有线程释放了50字节空间，那么这时应该唤醒哪一个线程呢？很明显时线程B因为B只要求10字节的空间，唤醒它可能让他运行。但是往往很有可能就唤醒了A，A被唤醒后还是没有足够的内存空间。</p>
<p>因此解决方法是：不要pthread_cond_signal()，用pthread_cond_broadcast()。signal只是唤醒单个线程，而broadcast唤醒所有线程。那么这种做法是可以满足需求的，所有应该被唤醒的线程都被唤醒了，但是缺点是可能会唤醒那些不该被唤醒的线程，因此性能会变差。这种情况叫做<strong>covering condition</strong>。</p>
<h2 id="30-4-Summary"><a href="#30-4-Summary" class="headerlink" title="30.4 Summary"></a>30.4 Summary</h2><ul>
<li>采用condition variable实现了线程间的同步，并且介绍了经典问题生产者消费者模型。</li>
</ul>
]]></content>
      <categories>
        <category>Operating System</category>
        <category>Concurrency</category>
      </categories>
      <tags>
        <tag>Operating System</tag>
        <tag>Concurrency</tag>
      </tags>
  </entry>
  <entry>
    <title>32. Common Concurrency Problems</title>
    <url>/2022/10/27/32-Common-Concurrency-Problems/</url>
    <content><![CDATA[<h1 id="32-Common-Concurrency-Problems"><a href="#32-Common-Concurrency-Problems" class="headerlink" title="32. Common Concurrency Problems"></a>32. Common Concurrency Problems</h1><h2 id="32-1-What-Types-Of-Bugs-Exist"><a href="#32-1-What-Types-Of-Bugs-Exist" class="headerlink" title="32.1 What Types Of Bugs Exist?"></a>32.1 What Types Of Bugs Exist?</h2><ul>
<li>并发中有哪些类型的bug？大致分为两种：<strong>non-deadlock bugs</strong>和<strong>deadlock bugs</strong>。</li>
</ul>
<span id="more"></span>
<h2 id="32-2-Non-Deadlock-Bugs"><a href="#32-2-Non-Deadlock-Bugs" class="headerlink" title="32.2 Non-Deadlock Bugs"></a>32.2 Non-Deadlock Bugs</h2><ul>
<li>主要又分为两类：<strong>atomicity violation</strong>和<strong>order violation</strong>。</li>
<li><strong>atomicity violation</strong>：</li>
</ul>
<p>可能出现的Bug：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220513102528.png" style="zoom:80%;" /></p>
<p>解决办法：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220513102548.png" style="zoom:80%;" /></p>
<ul>
<li><strong>order violation</strong>：</li>
</ul>
<p>可能出现的bug：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220513102650.png" style="zoom:80%;" /></p>
<p>解决方法：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220513102705.png" style="zoom:80%;" /></p>
<ul>
<li><strong>Non-Deadlock Bugs: Summary</strong></li>
</ul>
<p>97%的非死锁bug都是原子性和同步的问题，一般通过lock可以解决。</p>
<h2 id="32-3-Deadlock-Bugs"><a href="#32-3-Deadlock-Bugs" class="headerlink" title="32.3 Deadlock Bugs"></a>32.3 Deadlock Bugs</h2><ul>
<li>死锁，当不同进程循环等待资源时，就会造成死锁。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220513102913.png" style="zoom:80%;" /></p>
<p>假设线程1占有lock1，线程2占有lock2，那么就造成了死锁。</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220513103001.png" style="zoom:80%;" /></p>
<ul>
<li>死锁产生的条件：</li>
</ul>
<p><strong>Mutual exclusion</strong>：线程要对想访问的资源申请互斥访问，比如加锁。</p>
<p><strong>Hold and wait</strong>：当线程在等待其他资源时，保持自己已经申请到的资源。</p>
<p><strong>No preemption</strong>：不能强制线程放弃已占有的资源。</p>
<p><strong>Circular wait</strong>：存在一条循环等待链，其中已经占有部分资源的线程在等待其他线程。</p>
<p>四个条件必须同时满足才能产生死锁。也就是说只要破坏其中一个条件就可以避免死锁。下面康康如何破坏这四个条件。</p>
<ul>
<li><strong>Prevention</strong></li>
</ul>
<p><strong>Circular wait</strong>：</p>
<p>可以通过固定资源的访问顺序来破坏循环等待条件。比如在上面那个栗子中，可以规定线程必须先申请lock1再申请lock2，这样就可以避免死锁。但是这种做法往往不现实，因为你要知道系统中所有要用到的资源，并且不方便新增资源。</p>
<p><strong>Hold and wait</strong>：</p>
<p>可以通过让线程一次性申请完所需的所有资源后再往下进行，像这样：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220513104610.png" style="zoom:80%;" /></p>
<p>但是这种做法会降低系统的并发性。</p>
<p><strong>No preemption</strong>：</p>
<p>可以通过当线程由于申请不到其他资源而等待时，释放掉其已经占有的资源，像这样：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220513104815.png" style="zoom:80%;" /></p>
<p><strong>Mutual exclusion</strong>：</p>
<p>可以通过不使用lock的方式来申请对资源的访问，比如使用compareAndSwap：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220513105107.png" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220513105118.png" style="zoom:80%;" /></p>
<ul>
<li><strong>Deadlock Avoidance via Scheduling</strong></li>
</ul>
<p>除了死锁预防，还可以死锁避免。死锁避免需要知道运行过程中的线程可能需要申请哪些lock，并合理安排对这些lock的调度。比如银行家算法，虽然可以有效避免死锁，但是应用场景比较局限，并且会限制系统的并发性。</p>
<ul>
<li><strong>Detect and Recover</strong></li>
</ul>
<p>最后是检测和恢复，也就是说允许系统产生死锁，但是产生死锁后通过一定的手段对死锁进行恢复。比如通过检测进程资源图中是否存在循环等待来判断死锁，或者一个线程等待资源时间过长就判断发生死锁等；然后再通过强制释放某个进程的资源来打破死锁。</p>
<h2 id="32-4-Summary"><a href="#32-4-Summary" class="headerlink" title="32.4 Summary"></a>32.4 Summary</h2><ul>
<li>这一章介绍了并发问题可能存在Bug，分为非死锁问题和死锁问题。非死锁问题主要是原子性和顺序性的问题；死锁问题主要是如何预防、避免、检测并恢复。</li>
</ul>
]]></content>
      <categories>
        <category>Operating System</category>
        <category>Concurrency</category>
      </categories>
      <tags>
        <tag>Operating System</tag>
        <tag>Concurrency</tag>
      </tags>
  </entry>
  <entry>
    <title>26. Concurrency: An Introduction</title>
    <url>/2022/10/27/26-Concurrency-An-Introduction/</url>
    <content><![CDATA[<h1 id="26-Concurrency-An-Introduction"><a href="#26-Concurrency-An-Introduction" class="headerlink" title="26. Concurrency: An Introduction"></a>26. Concurrency: An Introduction</h1><ul>
<li>在前面很长的部分里我们讨论了虚拟化的问题，主要是对CPU和内存的虚拟化。在接下来的部分里，我们将学习一个进程（process）的抽象，那就是线程（thread）。一个进程可以包含多个线程，也是就<strong>multi-thread</strong> program，每个线程像一个单独的进程，但是区别在于同一进程的线程之间共享地址空间，因此可以访问相同的数据。</li>
<li>线程和进程十分相似。线程有自己的PC来表明当前指令的地址；线程有自己的寄存器用来做计算；因此如果有两个线程在一个处理器上运行，就会面临<strong>context switch</strong>的问题。对于进程来说，context switch时将进程信息保存在<strong>process control block（PCB）</strong>中；而对于线程来说，context switch时将线程信息保存在<strong>thread control block（TCB）</strong>中。但是有一点不同，对于线程来说，context switch时并不会改变地址空间，也就是说使用的page table不需要改变。</li>
<li>线程和进程的另一个区别在于stack。在之前的进程中（现在叫<strong>single-thread process</strong>），只有一个stack；但是在multi-thread process中，每一个线程都对应一个stack。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220427094358.png" style="zoom:80%;" /></p>
<span id="more"></span>
<h2 id="26-1-Why-Use-Threads"><a href="#26-1-Why-Use-Threads" class="headerlink" title="26.1 Why Use Threads?"></a>26.1 Why Use Threads?</h2><ul>
<li>如题，为何要使用线程？</li>
<li>第一，<strong>并行性</strong>。假设有一个很大的数组，现在要把数组的每一个元素都加1。在single-thread的程序中，就只能按部就班地从头做到尾。但是现在如果有了multi-thread程序，并且有多核CPU，就可以让每个CPU运行一个线程，每个线程完成一部分任务，提高了<strong>并行性</strong>。</li>
<li>第二，避免由于I/O而block程序。假设一个程序中需要发起不同的I/O请求，对于single-thread的进程来说，发起I/O请求就会被block，但是如果想在发起I/O请求后还做一些事情，比如计算或者是提出别的I/O请求应该怎么办？在multi-thread进程中，可以让一个线程来发起I/O请求，其他线程继续运行，也就是说block的是发起I/O的那个线程而不是整个儿进程。</li>
</ul>
<h2 id="26-2-An-Example-Thread-Creation"><a href="#26-2-An-Example-Thread-Creation" class="headerlink" title="26.2 An Example: Thread Creation"></a>26.2 An Example: Thread Creation</h2><ul>
<li>直接看代码吧：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220427095803.png" style="zoom:80%;" /></p>
<p>Pthread_create用于创建一个新的线程并完成一些事情。具体来说，第17行，创建p1线程，完成mythread函数，参数是“A”。</p>
<p>Pthread_join用于等待某一个线程结束。具体来说。第20行，等待p1线程运行结束。</p>
<p>对于上述代码，有着多种不同的执行顺序：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220427100128.png" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220427100149.png" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220427100203.png" style="zoom:80%;" /></p>
<ul>
<li>可以看到，线程让事情变得更复杂，到底让哪个线程上CPU运行？计算机如果没有concurrency，就无法回答这个问题。但是有了concurrency，就变得更worse。</li>
</ul>
<h2 id="26-3-Why-It-Gets-Worse-Shared-Data"><a href="#26-3-Why-It-Gets-Worse-Shared-Data" class="headerlink" title="26.3 Why It Gets Worse: Shared Data"></a>26.3 Why It Gets Worse: Shared Data</h2><ul>
<li>上面举例了简单的创建线程，但是没有讲的是线程共享数据的同时是如何交互的呢？</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220427100644.png" style="zoom:80%;" /></p>
<p>正如上面这个栗子，在所有代码都执行完后，我们期待最终counter的结果是2e7：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220427100752.png" style="zoom:80%;" /></p>
<p>但事实并非如此。实际运行后的结果：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220427101019.png" style="zoom:80%;" /></p>
<p>再运行一次康康？</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220427101037.png" style="zoom:80%;" /></p>
<p>可以看到每次的结果都不一样，也就是说结果是不确定的。</p>
<h2 id="26-4-The-Heart-Of-The-Problem-Uncontrolled-Scheduling"><a href="#26-4-The-Heart-Of-The-Problem-Uncontrolled-Scheduling" class="headerlink" title="26.4 The Heart Of The Problem: Uncontrolled Scheduling"></a>26.4 The Heart Of The Problem: Uncontrolled Scheduling</h2><ul>
<li>上述问题到底是什么原因导致的？为了搞清楚这个问题，就必须从汇编语言的层面来康康在更新counter时到底发生了什么。实际上，在对counter更新时执行了一下三条汇编指令：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220427101355.png" style="zoom:80%;" /></p>
<p>第一条是将0x8049a1c地址中的值取出，保存到eax寄存器；</p>
<p>第二条是对eax寄存器中的值做加1；</p>
<p>第三条是将eax寄存器中的值保存到0x8049a1c地址。</p>
<p>问题的本质就在于，一个线程执行这三条指令时并不是原子的，如下图：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220427101644.png" style="zoom:80%;" /></p>
<p>解释一下几个术语：</p>
<p>当超过两个线程在共享数据并且试图同时修改一个数据时，这种现象叫做<strong>race condition</strong>（或者data race）。</p>
<p>当发生race condition的时候，把修改数据的那段代码叫做<strong>critical section</strong>。</p>
<p>我们期望的结果是<strong>mutual exclusion</strong>，也就是说在执行critical section的代码时，其他的线程不能执行这段代码。</p>
<h2 id="26-5-The-Wish-For-Atomicity"><a href="#26-5-The-Wish-For-Atomicity" class="headerlink" title="26.5 The Wish For Atomicity"></a>26.5 The Wish For Atomicity</h2><ul>
<li>想要解决上面这个问题，就必须实现原子性。也就是说对于更新counter的三条汇编指令，要么全部执行，要么全不执行。所以我们又需要硬件的帮助了，可以基于硬件提供的指令，可以构建一套指令叫做<strong>synchronization primitives</strong>。有了硬件的帮助，再加上OS就可以多线程同步地访问critical section，保证顺序可控。这一部分会在这个章节的后面继续讲解。</li>
</ul>
<h2 id="26-6-One-More-Problem-Waiting-For-Another"><a href="#26-6-One-More-Problem-Waiting-For-Another" class="headerlink" title="26.6 One More Problem: Waiting For Another"></a>26.6 One More Problem: Waiting For Another</h2><ul>
<li>在多线程中另一个需要解决的问题就是同步，一个线程必须等待另一个线程完成才能继续往下执行。在后面的部分讲解。</li>
</ul>
<h2 id="26-7-Summary-Why-in-OS-Class"><a href="#26-7-Summary-Why-in-OS-Class" class="headerlink" title="26.7 Summary: Why in OS Class?"></a>26.7 Summary: Why in OS Class?</h2><ul>
<li>如题，多线程不应该在编程层面考虑吗？为什么要在OS的课程里学习？实际上，OS是第一个并发程序。比如系统调用write()来写文件，两个程序同时调用该怎么办？OS会处理这一切的。因此，OS必须考虑多线程的问题。</li>
</ul>
]]></content>
      <categories>
        <category>Operating System</category>
        <category>Concurrency</category>
      </categories>
      <tags>
        <tag>Operating System</tag>
        <tag>Concurrency</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-V2-07-重建二叉树</title>
    <url>/2022/10/28/%E5%89%91%E6%8C%87offer-V2-07-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="剑指offer-V2-07-重建二叉树"><a href="#剑指offer-V2-07-重建二叉树" class="headerlink" title="剑指offer-V2-07-重建二叉树"></a>剑指offer-V2-07-重建二叉树</h1><p><a href="https://leetcode.cn/problems/zhong-jian-er-cha-shu-lcof/">原题点这里</a></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202210281016258.png" alt=""></p>
<span id="more"></span>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>对于一个根节点，在inorder也就是中序遍历中，在其数组左边位置上的数字都是左子树的节点值，同理右边位置上的数字都是右子树上的节点值。那么可以先在inorder中找到root的下表inIdx，inorder中在inIdx左边就是所有左子树的节点值，右边就是右子树节点值。那么对于前序遍历preorder，左子树的所有节点在下标[1～inIdx]中，是根据左子树节点数量来判断的，同理右子树在[inIdx:]，因此就可以采用分治递归。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">	Val   <span class="type">int</span></span><br><span class="line">	Left  *TreeNode</span><br><span class="line">	Right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">buildTree</span><span class="params">(preorder []<span class="type">int</span>, inorder []<span class="type">int</span>)</span></span> *TreeNode &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(preorder) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	root := &amp;TreeNode&#123;Val: preorder[<span class="number">0</span>]&#125;</span><br><span class="line">	inIdx := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(inorder); i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> inorder[i] == preorder[<span class="number">0</span>] &#123;</span><br><span class="line">			inIdx = i</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	root.Left = buildTree(preorder[<span class="number">1</span>:inIdx+<span class="number">1</span>], inorder[:inIdx])</span><br><span class="line">	root.Right = buildTree(preorder[inIdx+<span class="number">1</span>:], inorder[inIdx+<span class="number">1</span>:])</span><br><span class="line">	<span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>offer</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-V2-09-用两个栈实现队列</title>
    <url>/2022/10/28/%E5%89%91%E6%8C%87offer-V2-09-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1 id="剑指offer-V2-09-用两个栈实现队列"><a href="#剑指offer-V2-09-用两个栈实现队列" class="headerlink" title="剑指offer-V2-09-用两个栈实现队列"></a>剑指offer-V2-09-用两个栈实现队列</h1><p><a href="https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">原题点这里</a></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202210281054104.png" alt=""></p>
<span id="more"></span>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>用两个栈，一个做输入栈，一个做输出栈。appendTail的时候就直接append到输入栈。deleteHead的时候把输入栈的元素出栈，把这些元素再入栈到输出栈，然后输出栈再出栈最后一个元素。这样经过两次栈的操作，就把后入先出变成了先入先出。但感觉对于golang来讲是脱裤子放屁，因为实际上go里面的栈就是数据，队列也是数组。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> CQueue <span class="keyword">struct</span> &#123;</span><br><span class="line">	inStack, outStack []<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span></span> CQueue &#123;</span><br><span class="line">	<span class="keyword">return</span> CQueue&#123;</span><br><span class="line">		inStack:  <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>),</span><br><span class="line">		outStack: <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *CQueue)</span></span> AppendTail(value <span class="type">int</span>) &#123;</span><br><span class="line">	this.inStack = <span class="built_in">append</span>(this.inStack, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *CQueue)</span></span> DeleteHead() <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(this.outStack) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> <span class="built_in">len</span>(this.inStack) == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> <span class="built_in">len</span>(this.inStack) &gt; <span class="number">0</span> &#123;</span><br><span class="line">			this.outStack = <span class="built_in">append</span>(this.outStack, this.inStack[<span class="built_in">len</span>(this.inStack)<span class="number">-1</span>])</span><br><span class="line">			this.inStack = this.inStack[:<span class="built_in">len</span>(this.inStack)<span class="number">-1</span>]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	tmp := this.outStack[<span class="built_in">len</span>(this.outStack)<span class="number">-1</span>]</span><br><span class="line">	this.outStack = this.outStack[:<span class="built_in">len</span>(this.outStack)<span class="number">-1</span>]</span><br><span class="line">	<span class="keyword">return</span> tmp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your CQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * obj := Constructor();</span></span><br><span class="line"><span class="comment"> * obj.AppendTail(value);</span></span><br><span class="line"><span class="comment"> * param_2 := obj.DeleteHead();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>offer</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-V2-10-2-青蛙跳台阶问题</title>
    <url>/2022/10/29/%E5%89%91%E6%8C%87offer-V2-10-2-%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="剑指offer-V2-10-2-青蛙跳台阶问题"><a href="#剑指offer-V2-10-2-青蛙跳台阶问题" class="headerlink" title="剑指offer-V2-10-2-青蛙跳台阶问题"></a>剑指offer-V2-10-2-青蛙跳台阶问题</h1><p><a href="https://leetcode.cn/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/submissions/">原题点这里</a></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202210291833198.png" alt=""></p>
<span id="more"></span>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>和斐波那契数列一样，只不过初始值换成了1和2。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">numWays</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> n &lt; <span class="number">3</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> n</span><br><span class="line">	&#125;</span><br><span class="line">	a, b := <span class="number">1</span>, <span class="number">2</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">3</span>; i &lt;= n; i++ &#123;</span><br><span class="line">		tmp := (a + b) % <span class="number">1000000007</span></span><br><span class="line">		a = b</span><br><span class="line">		b = tmp</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>offer</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-V2-10-1-斐波那契数列</title>
    <url>/2022/10/29/%E5%89%91%E6%8C%87offer-V2-10-1-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</url>
    <content><![CDATA[<h1 id="剑指offer-V2-10-1斐波那契数列"><a href="#剑指offer-V2-10-1斐波那契数列" class="headerlink" title="剑指offer-V2-10-1斐波那契数列"></a>剑指offer-V2-10-1斐波那契数列</h1><p><a href="https://leetcode.cn/problems/fei-bo-na-qi-shu-lie-lcof/">原题点这里</a></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202210291825502.png" alt=""></p>
<span id="more"></span>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>要么直接递归，要么就模拟一下。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">fib</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> n &lt; <span class="number">2</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> n</span><br><span class="line">	&#125;</span><br><span class="line">	a, b := <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">2</span>; i &lt;= n; i++ &#123;</span><br><span class="line">		tmp := (a + b) % (<span class="number">1000000007</span>)</span><br><span class="line">		a = b</span><br><span class="line">		b = tmp</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>offer</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-V2-11-旋转数组的最小数字</title>
    <url>/2022/10/30/%E5%89%91%E6%8C%87offer-V2-11-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h1 id="剑指offer-V2-11-旋转数组的最小数字"><a href="#剑指offer-V2-11-旋转数组的最小数字" class="headerlink" title="剑指offer-V2-11-旋转数组的最小数字"></a>剑指offer-V2-11-旋转数组的最小数字</h1><p><a href="https://leetcode.cn/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof/">原题点这里</a></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202210301325777.png" alt=""></p>
<span id="more"></span>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>对于有序数组，一般可以采用二分查找。当mid元素小于right时，说明最小元素一定在&lt;=mid的位置上；如果mid大于right，说明最小元素一定在mid+1到right之间；如果二者相等，不好判断，则把right—再判断。当left和right相等时，跳出循环。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minArray</span><span class="params">(numbers []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	left, right := <span class="number">0</span>, <span class="built_in">len</span>(numbers)<span class="number">-1</span></span><br><span class="line">	<span class="keyword">for</span> left &lt; right &#123;</span><br><span class="line">		mid := (left + right) / <span class="number">2</span></span><br><span class="line">		<span class="keyword">if</span> numbers[mid] &gt; numbers[right] &#123;</span><br><span class="line">			left = mid + <span class="number">1</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> numbers[mid] &lt; numbers[right] &#123;</span><br><span class="line">			right = mid</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			right--</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> numbers[left]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>offer</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-V2-12-矩阵中的路径</title>
    <url>/2022/10/30/%E5%89%91%E6%8C%87offer-V2-12-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h1 id="剑指offer-V2-矩阵中的路径"><a href="#剑指offer-V2-矩阵中的路径" class="headerlink" title="剑指offer-V2-矩阵中的路径"></a>剑指offer-V2-矩阵中的路径</h1><p><a href="https://leetcode.cn/problems/ju-zhen-zhong-de-lu-jing-lcof/">原题点这里</a></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202210301332896.png" alt=""></p>
<span id="more"></span>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>递归+回溯。使用原数组保存是否访问信息，节省空间。如果当前位置byte和字符串当前位置byte不相等，直接return false。当k等于字符串长度-1时，代表完全匹配，直接return true。判断每一次dfs结果是否为true，如果是直接return true。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exist</span><span class="params">(board [][]<span class="type">byte</span>, word <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    row := <span class="built_in">len</span>(board)</span><br><span class="line">	col := <span class="built_in">len</span>(board[<span class="number">0</span>])</span><br><span class="line">	<span class="keyword">if</span> row == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	dirs := [][]<span class="type">int</span>&#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;&#125;</span><br><span class="line">	<span class="keyword">var</span> valid <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span></span><br><span class="line">	valid = <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> i &gt;= <span class="number">0</span> &amp;&amp; i &lt; row &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; j &lt; col &amp;&amp; board[i][j] != <span class="string">&#x27;*&#x27;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(i, j, k <span class="type">int</span>)</span></span> <span class="type">bool</span></span><br><span class="line">	dfs = <span class="function"><span class="keyword">func</span><span class="params">(i, j, k <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> board[i][j] != word[k] &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> k &gt;= <span class="built_in">len</span>(word)<span class="number">-1</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> _, dir := <span class="keyword">range</span> dirs &#123;</span><br><span class="line">			nI := i + dir[<span class="number">0</span>]</span><br><span class="line">			nJ := j + dir[<span class="number">1</span>]</span><br><span class="line">			<span class="keyword">if</span> valid(nI, nJ) &#123;</span><br><span class="line">				old := board[i][j]</span><br><span class="line">				board[i][j] = <span class="string">&#x27;*&#x27;</span></span><br><span class="line">				<span class="keyword">if</span> dfs(nI, nJ, k+<span class="number">1</span>) &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">				&#125;</span><br><span class="line">				board[i][j] = old</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; row; i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">0</span>; j &lt; col; j++ &#123;</span><br><span class="line">			<span class="keyword">if</span> dfs(i, j, <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>offer</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>offer</tag>
      </tags>
  </entry>
  <entry>
    <title>DRL-1.Overview</title>
    <url>/2022/10/30/DRL-1-Overview/</url>
    <content><![CDATA[<h1 id="DRL-1-Overview"><a href="#DRL-1-Overview" class="headerlink" title="DRL-1.Overview"></a>DRL-1.Overview</h1><h2 id="1-RL-Basics"><a href="#1-RL-Basics" class="headerlink" title="1.RL Basics"></a>1.RL Basics</h2><h3 id="1-1-Terminology"><a href="#1-1-Terminology" class="headerlink" title="1.1 Terminology"></a>1.1 Terminology</h3><ul>
<li>State：当前环境的状态空间</li>
<li>Action：Agent当前可以采取的动作空间</li>
<li>Policy $\pi$ ：policy函数$\pi:(s,a) -&gt; [0,1]$ $\pi:(a | s)=P(A=a|S=s)$ ，大写字母代表还没有观测到的随机变量，小写字母代表已经观测到的确定值。策略函数做的事情就是：在给定状态s下，agent会采取不同action的概率。<span id="more"></span>
以超级玛丽的游戏为例，假设你正在玩超级玛丽，游戏某一时刻的截图如下：</li>
</ul>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209042114190.png" style="zoom: 33%;" /></p>
<p>此时我们假设观测到的画面observstion就是当前的状态state(虽然情况可能并没有这么简单)，那么现在state有了。Action是啥？</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209042116087.png" style="zoom: 33%;" /></p>
<p>Action就是身为Agent的玛丽当前三个可选择的动作，{left, right, up}。</p>
<p>假设现在有一个策略函数$\pi$，根据该函数可以得到agent采取不同动作的概率：</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209042119431.png" style="zoom: 33%;" /></p>
<ul>
<li>Reward：奖励是自定义的，根据agent的状态定义不同的reward。比如：</li>
</ul>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209042122133.png" style="zoom: 33%;" /></p>
<ul>
<li>State Transition：状态转移，在一个old state，采取了某一个action，得到了一个new state。状态转移也可以是随机的，比如说在某一个state采取了某一个action，那么下一个state也可能是随机的。$p(s^{‘}|s,a)=P(S^{‘}=s^{‘}|S=s,A=a)$</li>
</ul>
<h3 id="1-2-Two-Sources-of-Randomness"><a href="#1-2-Two-Sources-of-Randomness" class="headerlink" title="1.2 Two Sources of Randomness"></a>1.2 Two Sources of Randomness</h3><ul>
<li>第一种是action的随机性，即处于某一个状态时，agent会采取的action是随机的，也就是根据策略函数来的：</li>
</ul>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209042232132.png" style="zoom:33%;" /></p>
<ul>
<li>第二种是state的随机性，即处于某一个状态，采取某个action后，下一个新的state是随机的，也就是根据状态转移函数来的：</li>
</ul>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209042236648.png" style="zoom:33%;" /></p>
<h3 id="1-3-Agent-Environment-Interaction"><a href="#1-3-Agent-Environment-Interaction" class="headerlink" title="1.3 Agent-Environment Interaction"></a>1.3 Agent-Environment Interaction</h3><p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209042237031.png" style="zoom:33%;" /></p>
<h3 id="1-4-Rewards-and-Returns"><a href="#1-4-Rewards-and-Returns" class="headerlink" title="1.4 Rewards and Returns"></a>1.4 Rewards and Returns</h3><ul>
<li>Return：从当前时刻t开始以后的Reward之和。</li>
</ul>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209042240965.png" style="zoom:33%;" /></p>
<p>那么问题是，当前时刻的Reward和以后时刻的Reward并不是相同重要的，所以要做Discount。</p>
<ul>
<li>Discounted Return：</li>
</ul>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209042244036.png" style="zoom:33%;" /></p>
<p>$\gamma$ 是Discount factor，一个可调节超参数，属于$[0,1]$。</p>
<p>注意到，$U_{t}$跟以后所有时刻的Reward有关，所以只有当整个游戏或者说交互过程结束后，我们才能计算$U_t$的值。</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209042248048.png" style="zoom:33%;" /></p>
<p>由于在时刻t，$R_t…R_n$是随机的，所以$U_t$也是随机的。</p>
<p>并且$R_i$取决于$S_i、A_i$，因此$U_t$取决于$R_t…R_n$以及$A_i…A_n$。</p>
<h3 id="1-5-Value-Function"><a href="#1-5-Value-Function" class="headerlink" title="1.5 Value Function"></a>1.5 Value Function</h3><h4 id="1-5-1-Action-value-function-Q-pi-s-a"><a href="#1-5-1-Action-value-function-Q-pi-s-a" class="headerlink" title="1.5.1 Action value function $Q_{\pi}(s,a)$"></a>1.5.1 Action value function $Q_{\pi}(s,a)$</h4><p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209042258491.png" style="zoom:33%;" /></p>
<p>$Q_{\pi}(s,a)$是对随机变量$U_t$求期望求出来的，所以是一个值。</p>
<h4 id="1-5-2-State-Value-Function-V-pi-s"><a href="#1-5-2-State-Value-Function-V-pi-s" class="headerlink" title="1.5.2 State Value Function $V_{\pi}(s)$"></a>1.5.2 State Value Function $V_{\pi}(s)$</h4><p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209042303189.png" style="zoom:33%;" /></p>
<p>对于 $Q_{\pi}(s,a)$  函数，确定state为$s_t$的情况下，就变成了$Q_{\pi}(s,A)$，是一个随机变量，因此可以对其求期望，就得到了$V_{\pi}(s_t)$。</p>
<ul>
<li>如果action是离散的，求期望就是用概率乘以随机变量的值再求和。</li>
</ul>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209042306730.png" style="zoom:33%;" /></p>
<ul>
<li>如果action是连续的，求期望就是用概率乘以随机变量的值再积分。</li>
</ul>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209042309483.png" style="zoom:33%;" /></p>
<h4 id="1-5-3-Understanding-of-Value-Functions"><a href="#1-5-3-Understanding-of-Value-Functions" class="headerlink" title="1.5.3 Understanding of Value Functions"></a>1.5.3 Understanding of Value Functions</h4><ul>
<li>对于Action Value Function，$Q_{\pi}(s,a)$在状态s时，agent采取行动a的好坏，值越高代表，采取这个action越好。</li>
<li>对于 State Value Function，对于一个确定的策略函数$\pi$，$V_{\pi}(s)$评价了当前agent处于状态s的这个环境好坏。</li>
</ul>
<h2 id="2-Value-Based-RL"><a href="#2-Value-Based-RL" class="headerlink" title="2. Value Based RL"></a>2. Value Based RL</h2><h4 id="2-1-Action-Value-Functions"><a href="#2-1-Action-Value-Functions" class="headerlink" title="2.1 Action-Value Functions"></a>2.1 Action-Value Functions</h4><p>对于在某一个策略$\pi$下的$Q(s,a)$，$Q^*(s_t,a_t)$的定义为，找到一个$\pi$，使得$Q$函数值最大。</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209060909413.png" style="zoom:33%;" /></p>
<h4 id="2-2-Deep-Q-Network-DQN"><a href="#2-2-Deep-Q-Network-DQN" class="headerlink" title="2.2 Deep Q-Network(DQN)"></a>2.2 Deep Q-Network(DQN)</h4><p>以超级玛丽游戏为例，假设我们知道了$Q^<em>$函数，那么如何通过这个函数来玩游戏，采取最佳的策略呢？很显然，我们要采取能够使$Q^</em>$函数值最大的那个action $a^*$。</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209060914336.png" style="zoom:33%;" /></p>
<p>这样，在$Q^<em>$函数的指导下，我们就可以知道在一个state s下该采取什么action了。但问题在于，我们并不知道$Q^</em>$函数，如何解决？</p>
<p>Deep Q Network(DQN)就派上用场了，用神经网络的方法来模拟函数$Q^<em>$，即用$Q(s,a;w)$来模拟$Q^</em>(s,a)$。</p>
<p>对于DQN来说：</p>
<ul>
<li>输入：当前的状态</li>
<li>输出：一个维度是动作空间的向量，代表每一个动作的分数</li>
</ul>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209060920619.png" style="zoom:33%;" /></p>
<p>根据模拟出来的结果，采取对应分数最高的action，即“up”。</p>
<p>整个流程是这个亚子：</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209060921261.png" style="zoom:33%;" /></p>
<h4 id="2-3-Temporal-Difference-TD-Learning"><a href="#2-3-Temporal-Difference-TD-Learning" class="headerlink" title="2.3 Temporal Difference(TD) Learning"></a>2.3 Temporal Difference(TD) Learning</h4><p>将一个大的模型估计，拆分成两部分，一部分是实际观测值，另一部分是小的模型估计：</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209060947066.png" style="zoom:33%;" /></p>
<p>在RL中，类似的采用如下方式使用TD算法：</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209061020537.png" style="zoom:33%;" /></p>
<p>简单证明下：</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209061021882.png" style="zoom:33%;" /></p>
<p>得到：</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209061021070.png" style="zoom:33%;" /></p>
<ul>
<li>$Q(s_t,a_t;w)$，是对$U_t$的估计</li>
<li>$Q(s_{t+1},a_{t+1};w)$，是对$U_{t+1}$的估计</li>
</ul>
<p>因此</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209061104099.png" style="zoom:33%;" /></p>
<p>TD Target：</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209061106530.png" style="zoom:33%;" /></p>
<p>Loss：</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209061107169.png" style="zoom:33%;" /></p>
<p>Gradient descent：</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209061108858.png" style="zoom:33%;" /></p>
<p>一次TD算法的迭代：</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209061110900.png" style="zoom:33%;" /></p>
<h2 id="3-Policy-Based-RL"><a href="#3-Policy-Based-RL" class="headerlink" title="3. Policy-Based RL"></a>3. Policy-Based RL</h2><p>对于策略函数$\pi(a|s)$，给出的函数值是一个向量，代表在当前state s下，agent采取不同action的概率。那么如果有一个好的$\pi$，我们就可以根据$\pi$来玩游戏了。但是如何去学习到一个好的$\pi$呢？</p>
<p>当然，对于有限的state和action，最简单的方式是枚举。通过玩很多次游戏，将所有state和action的组合做一个表格，这样就得到了一个$\pi$。但是对于state和action的间较大的情况，这种方法不适用，因此我们采用Policy Network的方法。</p>
<h3 id="3-1-Policy-Network-pi-a-s-theta"><a href="#3-1-Policy-Network-pi-a-s-theta" class="headerlink" title="3.1 Policy Network $\pi(a|s;\theta)$"></a>3.1 Policy Network $\pi(a|s;\theta)$</h3><p>采用policy network $\pi(a|s;\theta)$来近似$\pi(a|s)$，其中$\theta$是神经网络的可训练参数。policy network接受当前的状态state s，通过神经网络的操作比如conv、dense，最后softmax得到结果。</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209061514836.png" style="zoom:33%;" /></p>
<p>注意</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209061516405.png" style="zoom:33%;" /></p>
<h3 id="3-2-State-Value-Function-Approximation"><a href="#3-2-State-Value-Function-Approximation" class="headerlink" title="3.2 State-Value Function Approximation"></a>3.2 State-Value Function Approximation</h3><p>对于State Value Function $V_{\pi}(s)$，假如action是离散的，那么得到：</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209042306730.png" style="zoom:33%;" /></p>
<p>将当中的$\pi(a|s)$用policy network $\pi(a|s;\theta)$代替，就得到了$V_{\pi}(s)$的近似$V(s_t;\theta)$：</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209061527296.png" style="zoom:33%;" /></p>
<p>那么，Policy-Based RL就是：学习参数$\theta$使得$J(\theta)$最大：</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209061529298.png" style="zoom:33%;" /></p>
<p>为啥要使得$J(\theta)$最大呢？先看下$J(\theta)$的定义，是状态价值函数$V$的关于随机变量$S$的期望。而状态价值函数用于评价当前状态的好坏，对其求期望可以用于评价所有状态下的一个平均好坏，那我们肯定希望平均状态更好一点，因此我们要maximize期望，也就是$J(\theta)$。</p>
<p>那么如何去学习到一个好的$\theta$能够使得$J(\theta)$最大呢？因为是要求最大，所以采用policy gradient ascent，也就是梯度上升。</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209061537725.png" style="zoom:33%;" /></p>
<p>这里的梯度其实应该是关于$J(\theta)$求的，但是这里写的是关于$V$求的，是因为这里采用随机梯度来代替求真正的梯度，而这种随机性来源于状态s。</p>
<p>问题来了，如何求$\frac{\partial V(s;\theta)}{\partial \theta}$ ？</p>
<p>看一个简单版本的推导，虽然过程不够严谨，但是结果是正确的，有助于理解。</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209061549717.png" style="zoom:33%;" /></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209061551577.png" style="zoom:33%;" /></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209061552967.png" style="zoom:33%;" /></p>
<p>所以最后的结果是：</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209061613535.png" style="zoom:33%;" /></p>
<p>要计算这个梯度，不管action是离散的还是连续的，可能都有点困难，所以可以采用蒙特卡洛，sample出来一个action $\hat{a}$，用$g(\hat{a},\theta)$来代替policy gradient。</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209061620972.png" style="zoom:33%;" /></p>
<p>使用policy gradient更新policy network的一次迭代：</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209061622646.png" style="zoom:33%;" /></p>
<h2 id="4-Actor-Critic-Methods"><a href="#4-Actor-Critic-Methods" class="headerlink" title="4. Actor-Critic Methods"></a>4. Actor-Critic Methods</h2><p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209061716941.png" style="zoom:33%;" /></p>
<p>在Policy-Based RL的迭代过程中，$Q_{\pi}$是不知道的，如果在加上对$Q_{\pi}$的近似估计就得倒了AC。</p>
<h3 id="4-1-Value-Network-and-Policy-Network"><a href="#4-1-Value-Network-and-Policy-Network" class="headerlink" title="4.1 Value Network and Policy Network"></a>4.1 Value Network and Policy Network</h3><ul>
<li>Policy network (actor)：使用神经网络$\pi(a|s;\theta)$来近似$\pi(a|s)$</li>
</ul>
<p>输入是state s，输出是采取不同action的概率。</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209061724337.png" style="zoom:33%;" /></p>
<ul>
<li>Value network (critic)：使用神经网络$q(s,a;w)$来近似$Q_{\pi}(s,a)$</li>
</ul>
<p>输入是state s，输出是采取不同action的分数。</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209061725517.png" style="zoom:33%;" /></p>
<h3 id="4-2-Train-the-Neural-Networks"><a href="#4-2-Train-the-Neural-Networks" class="headerlink" title="4.2 Train the Neural Networks"></a>4.2 Train the Neural Networks</h3><p>对于状态价值函数，如果将$\pi$和$q$都采用神经网络近似，就得到：</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209061727682.png" style="zoom:33%;" /></p>
<p>那么训练过程其实就是学习更新参数$\theta$和$w$。迭代过程如下：</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209061730007.png" style="zoom:33%;" /></p>
<p>下面说说具体如何使用不同算法更新参数。</p>
<ul>
<li>使用TD算法更新value network $q$</li>
</ul>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209061733735.png" style="zoom:33%;" /></p>
<ul>
<li>使用policy gradient更新policy network $\pi$</li>
</ul>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209061738135.png" style="zoom:33%;" /></p>
<h3 id="4-3-Summary-of-Algorithm"><a href="#4-3-Summary-of-Algorithm" class="headerlink" title="4.3 Summary of Algorithm"></a>4.3 Summary of Algorithm</h3><p>在一次迭代中，算法流程如下：</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209061740479.png" style="zoom:33%;" /></p>
]]></content>
      <categories>
        <category>Deep Reinforcement Learning</category>
      </categories>
      <tags>
        <tag>Deep Reinforcement Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>DRL-2.Advanced Topics on Value-Based Learning</title>
    <url>/2022/10/30/DRL-2-Advanced-Topics-on-Value-Based-Learning/</url>
    <content><![CDATA[<h1 id="DRL-2-Advanced-Topics-on-Value-Based-Learning"><a href="#DRL-2-Advanced-Topics-on-Value-Based-Learning" class="headerlink" title="DRL-2.Advanced Topics on Value-Based Learning"></a>DRL-2.Advanced Topics on Value-Based Learning</h1><h2 id="1-Experience-Replay-ER-amp-Prioritized-ER"><a href="#1-Experience-Replay-ER-amp-Prioritized-ER" class="headerlink" title="1. Experience Replay (ER) &amp; Prioritized ER"></a>1. Experience Replay (ER) &amp; Prioritized ER</h2><h3 id="1-1-Experience-Replay"><a href="#1-1-Experience-Replay" class="headerlink" title="1.1 Experience Replay"></a>1.1 Experience Replay</h3><ul>
<li>A transition：$(s_t, a_t,r_t,s_{t+1})$</li>
</ul>
<p>重复使用之前已经利用过的transition。将n个transition保存到replay buffer中，n是一个可调节超参数，通常取$10^5 - 10^6$。</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209151641708.png" style="zoom: 25%;" /></p>
<ul>
<li>TD with Experience Replay</li>
</ul>
<p>在使用Stochastic gradient desenct（SGD）时，从过去的经验中随机sample一条transition来更新梯度：</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209151644846.png" style="zoom:33%;" /></p>
<p>使用Experience Replay的好处：</p>
<ol>
<li>让梯度更新是不相关的</li>
<li>多次使用收集到的经验<span id="more"></span>
</li>
</ol>
<h3 id="1-2-Prioritized-Experience-Replay"><a href="#1-2-Prioritized-Experience-Replay" class="headerlink" title="1.2 Prioritized Experience Replay"></a>1.2 Prioritized Experience Replay</h3><ul>
<li>Importance Sampling</li>
</ul>
<p>虽然要重复使用之前的transition，但并不是所有的transition的重要性是一致的。因此在sample时要使用importance sampling而不是uniform sampling。</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209151656925.png" style="zoom: 33%;" /></p>
<p>总的来说，误差越大，被sample到的可能性就越大。</p>
<ul>
<li>Scaling Learning Rate</li>
</ul>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209151658443.png" style="zoom:33%;" /></p>
<p>如果是uniform sampling，$\alpha$应该是相同的。如果是Importance Sampling，那么$\alpha$应该随着重要性调整。</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209151701837.png" style="zoom:33%;" /></p>
<p>这样：重要性高的transition学习率就低，并且一开始$\beta$很小，慢慢增大到1。</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209151703106.png" style="zoom: 25%;" /></p>
<h2 id="2-Overestimation-Target-Network-amp-Double-DQN"><a href="#2-Overestimation-Target-Network-amp-Double-DQN" class="headerlink" title="2.Overestimation, Target Network, &amp; Double DQN"></a>2.Overestimation, Target Network, &amp; Double DQN</h2><h3 id="2-1-Problem-of-Overestimation"><a href="#2-1-Problem-of-Overestimation" class="headerlink" title="2.1 Problem of Overestimation"></a>2.1 Problem of Overestimation</h3><p> 使用TD算法来更新会使得action-values的值变大。</p>
<p>原因1：maximization</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209161139700.png" style="zoom:33%;" /></p>
<p>原因2：Bootstrapping</p>
<p>随着迭代次数的增大，overesitimation会越来越大。为了解决这个问题，有两种解决方法：</p>
<p>方法一：使用target network来计算TD targets（解决了Bootstrapping的问题）。</p>
<p>方法二：使用Double DQN来消除maximization。</p>
<h3 id="2-2-Target-Network"><a href="#2-2-Target-Network" class="headerlink" title="2.2 Target Network"></a>2.2 Target Network</h3><p>不使用参数为$w$的$Q$网络计算TD Target，这样更新参数$w$时就不会用到$Q$函数。使用一个新的网络Target Network来计算TD Target，参数为$w^-$，并且$w^-$和$w$ 不一样。</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209161416706.png" style="zoom:33%;" /></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209161418262.png" style="zoom:33%;" /></p>
<p>使用Target Network来计算更新梯度：</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209161419583.png" style="zoom:33%;" /></p>
<p>在上面的流程中，原本的$Q$网络可以正常更新参数，那么Target Network如何更新参数呢？用两种选择定期更新参数$w^-$：</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209161421850.png" style="zoom:33%;" /></p>
<p>虽然采用Target Network的方法，但是并不能完全消除采用TD算法导致overestimate的问题。</p>
<h3 id="2-3-Double-DQN"><a href="#2-3-Double-DQN" class="headerlink" title="2.3 Double DQN"></a>2.3 Double DQN</h3><p>在上一节里，使用了Target Network来计算TD Target，如果这里不仅采用它来计算TD Target，并且使用它来选择action。之前是采用$Q$网络来选择action，选择使得$Q$函数分数最高的action。现在是使用参数为$w^-$的Target Network来做选择：</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209161432568.png" style="zoom:33%;" /></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209161433591.png" style="zoom:33%;" /></p>
<p>这么做效果不错，但还不够好，下面介绍Double DQN。其实就是在使用Target Network计算TD Target的基础上，再选择出使得Target Network分数最高的action $a^<em>$，然后使用这个$a^</em>$加上Target Network来计算TD Target：</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209161446166.png" style="zoom:33%;" /></p>
<p>这样做的效果会好一点：</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209161452999.png" style="zoom:33%;" /></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209161453510.png" style="zoom:33%;" /></p>
<h2 id="3-Dueling-Network"><a href="#3-Dueling-Network" class="headerlink" title="3. Dueling Network"></a>3. Dueling Network</h2><h3 id="3-1-Optimal-Value-Functions"><a href="#3-1-Optimal-Value-Functions" class="headerlink" title="3.1 Optimal Value Functions"></a>3.1 Optimal Value Functions</h3><ul>
<li>Optimal action-value function:</li>
</ul>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209161458946.png" style="zoom:33%;" /></p>
<ul>
<li>Optimal state-value function:</li>
</ul>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209161459856.png" style="zoom:33%;" /></p>
<ul>
<li>Optimal advantage function:</li>
</ul>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209161500471.png" style="zoom:33%;" /></p>
<ul>
<li>Advantage Function的性质：</li>
</ul>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209161502827.png" style="zoom:33%;" /></p>
<p>​    首先由这个性质可以推出：</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209161508496.png" style="zoom:33%;" /></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209161509110.png" style="zoom:33%;" /></p>
<p>接着，由$A^*$的定义可以得到：</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209161510351.png" style="zoom:33%;" /></p>
<p>因此第二个性质：</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209161511852.png" style="zoom:33%;" /></p>
<h3 id="3-2-Dueling-Network"><a href="#3-2-Dueling-Network" class="headerlink" title="3.2 Dueling Network"></a>3.2 Dueling Network</h3><p>可以借鉴之前采用$Q(s,a;w)$来模拟$Q$的思想，采用$A(s,a;w)$来模拟$A$：</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209161515371.png" style="zoom:33%;" /></p>
<p>采用$V(s;w)$来模拟$V$：</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209161516249.png" style="zoom:33%;" /></p>
<p>这样，上面的性质2就可以采用Dueling Network来模拟$Q^*$：</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209161518833.png" style="zoom:33%;" /></p>
<p>令$W=(W^A,W^V)$，就得到：</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209161519846.png" style="zoom:33%;" /></p>
<p>实际上$Q(s,a;w)$是对$Q^*$的近似。</p>
<p>有个问题，为啥在$Q^<em>$里加上最后恒等于0的这一项$\mathop{max} \limits_a A^</em>(s,a)$呢？答案是为了是结果唯一。</p>
<p>要想近似$Q^*$还有一个方法：</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209161532623.png" style="zoom:33%;" /></p>
]]></content>
      <categories>
        <category>Deep Reinforcement Learning</category>
      </categories>
      <tags>
        <tag>Deep Reinforcement Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>DRL-3.Policy Gradient with Baseline</title>
    <url>/2022/10/30/DRL-3-Policy-Gradient-with-Baseline/</url>
    <content><![CDATA[<h1 id="DRL-3-Policy-Gradient-with-Baseline"><a href="#DRL-3-Policy-Gradient-with-Baseline" class="headerlink" title="DRL-3.Policy Gradient with Baseline"></a>DRL-3.Policy Gradient with Baseline</h1><h2 id="1-Policy-Gradient-with-Baseline"><a href="#1-Policy-Gradient-with-Baseline" class="headerlink" title="1. Policy Gradient with Baseline"></a>1. Policy Gradient with Baseline</h2><h3 id="1-1-Policy-Gradient"><a href="#1-1-Policy-Gradient" class="headerlink" title="1.1 Policy Gradient"></a>1.1 Policy Gradient</h3><p>recall：使用策略函数$\pi(a|s;\theta)$来控制agent的行为；</p>
<p>状态价值函数：</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209162106947.png" style="zoom:33%;" /></p>
<p>Policy gradient：</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209162108173.png" style="zoom:33%;" /><br><span id="more"></span></p>
<h3 id="1-2-Baseline"><a href="#1-2-Baseline" class="headerlink" title="1.2 Baseline"></a>1.2 Baseline</h3><p>Baseline $b$，可以是任意一个函数，并且独立与$A$。</p>
<p>那么：</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209191105034.png" style="zoom:33%;" /></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209191107871.png" style="zoom:33%;" /></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209191108712.png" style="zoom:33%;" /></p>
<p>因此得到结论：</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209191108683.png" style="zoom:33%;" /></p>
<p>那么policy gradient就可以写成：</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209191111136.png" style="zoom:33%;" /></p>
<p>计算这个梯度不好算，所以采用蒙特卡洛近似。</p>
<h3 id="1-3-Monte-Carlo-Approximation"><a href="#1-3-Monte-Carlo-Approximation" class="headerlink" title="1.3 Monte Carlo Approximation"></a>1.3 Monte Carlo Approximation</h3><p>令：</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209191113918.png" style="zoom:33%;" /></p>
<p>随机sample出一个样本$a_t\sim\pi$，然后计算$g(a_t)$，就得到了policy gradient的无偏估计。</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209191117952.png" style="zoom:33%;" /></p>
<h3 id="1-4-Stochastic-Policy-Gradient"><a href="#1-4-Stochastic-Policy-Gradient" class="headerlink" title="1.4 Stochastic Policy Gradient"></a>1.4 Stochastic Policy Gradient</h3><p>随机策略梯度：</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209191119065.png" style="zoom:33%;" /></p>
<p>随机策略梯度上升：</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209191120421.png" style="zoom:33%;" /></p>
<p>不管我们采取什么Baseline $b$，策略梯度的值都是一样的，但是Baseline $b$影响了$g(a_t)$，选择一个好的Baseline $b$可以使得算法收敛速度更快。</p>
<h3 id="1-5-Choices-of-Baselines"><a href="#1-5-Choices-of-Baselines" class="headerlink" title="1.5 Choices of Baselines"></a>1.5 Choices of Baselines</h3><ul>
<li>$b=0$</li>
</ul>
<p>​    那么就得到了标准的策略梯度：</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209191125908.png" style="zoom:33%;" /></p>
<ul>
<li>$b$ 是state value</li>
</ul>
<p>因为$s_t$已经被观测到了，因此$b=V_{\pi}(s_t)$独立与$A_t$。</p>
<h2 id="2-REINFORCE-with-Baseline"><a href="#2-REINFORCE-with-Baseline" class="headerlink" title="2. REINFORCE with Baseline"></a>2. REINFORCE with Baseline</h2><h3 id="2-1-Approximations"><a href="#2-1-Approximations" class="headerlink" title="2.1 Approximations"></a>2.1 Approximations</h3><p>上一节学习了随机策略梯度，在其中有一项$Q_\pi$，还记得：</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209191447542.png" style="zoom:33%;" /></p>
<p>如果采用蒙特卡洛近似$Q\pi$，这种做法就叫做REINFORCE：</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209191449369.png" style="zoom:33%;" /></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209191449969.png" style="zoom:33%;" /></p>
<p>在随机策略梯度中还有一项$V\pi(s;\theta)$，可以采用神经网络$v(s;w)$来近。</p>
<p>那么现在策略梯度就变成了近似策略梯度：</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209191453654.png" style="zoom:33%;" /></p>
<p>在这其中，一共做了三次近似：</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209191457610.png" style="zoom:33%;" /></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209191457189.png" style="zoom:33%;" /></p>
<h3 id="2-2-Policy-and-Value-Networks"><a href="#2-2-Policy-and-Value-Networks" class="headerlink" title="2.2 Policy and Value Networks"></a>2.2 Policy and Value Networks</h3><p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209191459384.png" style="zoom:33%;" /></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209191459988.png" style="zoom:33%;" /></p>
<h3 id="2-3-REINFORCE-with-Baseline"><a href="#2-3-REINFORCE-with-Baseline" class="headerlink" title="2.3 REINFORCE with Baseline"></a>2.3 REINFORCE with Baseline</h3><p>使用近似随机梯度上升来更新策略网络：</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209191502972.png" style="zoom:33%;" /></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209191502606.png" style="zoom:33%;" /></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209191503260.png" style="zoom:33%;" /></p>
<p>使用梯度下降来更新状态价值网络：</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209191526157.png" style="zoom:33%;" /></p>
<h3 id="2-4-Summary-of-Algorithm"><a href="#2-4-Summary-of-Algorithm" class="headerlink" title="2.4 Summary of Algorithm"></a>2.4 Summary of Algorithm</h3><p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209191527728.png" style="zoom:33%;" /></p>
<h2 id="3-Advantage-Actor-Critic-A2C"><a href="#3-Advantage-Actor-Critic-A2C" class="headerlink" title="3. Advantage Actor-Critic(A2C)"></a>3. Advantage Actor-Critic(A2C)</h2><h3 id="3-1-Actor-and-Critic"><a href="#3-1-Actor-and-Critic" class="headerlink" title="3.1 Actor and Critic"></a>3.1 Actor and Critic</h3><p>Policy network(actor)：$\pi(a|s;\theta)$，是对策略函数的近似，用于控制agent。</p>
<p>Value network(critic)：$v(s;w)$，是对状态价值函数的近似，用于评估当前状态好坏。</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209191539093.png" style="zoom:33%;" /></p>
<h3 id="3-2-Training-of-A2C"><a href="#3-2-Training-of-A2C" class="headerlink" title="3.2 Training of A2C"></a>3.2 Training of A2C</h3><p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209191540918.png" style="zoom:33%;" /></p>
<h3 id="3-3-Properties-of-Value-Functions"><a href="#3-3-Properties-of-Value-Functions" class="headerlink" title="3.3 Properties of Value Functions"></a>3.3 Properties of Value Functions</h3><h4 id="3-3-1-Properties-of-Action-Value-Functions"><a href="#3-3-1-Properties-of-Action-Value-Functions" class="headerlink" title="3.3.1 Properties of Action-Value Functions"></a>3.3.1 Properties of Action-Value Functions</h4><p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209211415457.png" style="zoom:33%;" /></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209211416056.png" style="zoom:33%;" /></p>
<p>定理1：</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209211416643.png" style="zoom:33%;" /></p>
<h4 id="3-3-2-Prooerties-of-State-Value-Functions"><a href="#3-3-2-Prooerties-of-State-Value-Functions" class="headerlink" title="3.3.2 Prooerties of State-Value Functions"></a>3.3.2 Prooerties of State-Value Functions</h4><p>根据定义1，可得到：</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209211419078.png" style="zoom:33%;" /></p>
<p>因此定理2：</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209211419403.png" style="zoom:33%;" /></p>
<h3 id="3-4-Monte-Carlo-Approximations"><a href="#3-4-Monte-Carlo-Approximations" class="headerlink" title="3.4 Monte Carlo Approximations"></a>3.4 Monte Carlo Approximations</h3><h4 id="3-4-1-Approximation-to-Action-Value"><a href="#3-4-1-Approximation-to-Action-Value" class="headerlink" title="3.4.1 Approximation to Action-Value"></a>3.4.1 Approximation to Action-Value</h4><p>根据定理1：</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209211421260.png" style="zoom:33%;" /></p>
<h4 id="3-4-2-Approximation-to-State-Value"><a href="#3-4-2-Approximation-to-State-Value" class="headerlink" title="3.4.2 Approximation to State-Value"></a>3.4.2 Approximation to State-Value</h4><p>根据定理2：</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209211422041.png" style="zoom:33%;" /></p>
<h3 id="3-5-Updating-Policy-Network"><a href="#3-5-Updating-Policy-Network" class="headerlink" title="3.5 Updating Policy Network"></a>3.5 Updating Policy Network</h3><p>还记得之前的随机策略梯度：</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209211426589.png" style="zoom:33%;" /></p>
<p>由于优势函数是不知道的，所以还不能计算随机策略梯度，但是当我们有了关于$Q_{\pi}$和$V_{\pi}$的近似后，就可以估计随机策略梯度了。</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209211432052.png" style="zoom:33%;" /></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209211433250.png" style="zoom:33%;" /></p>
<p>再用$v(s;w)$来近似估计$V_{\pi}(s)$：</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209211434586.png" style="zoom:33%;" /></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209211435854.png" style="zoom:33%;" /></p>
<p>采用策略梯度上升来更新策略网络：</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209211435171.png" style="zoom:33%;" /></p>
<h3 id="3-6-Updating-Value-Network"><a href="#3-6-Updating-Value-Network" class="headerlink" title="3.6 Updating Value Network"></a>3.6 Updating Value Network</h3><p>前面由蒙特卡洛近似得到：</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209211513150.png" style="zoom:33%;" /></p>
<p>用$v(s;w)$来近似就得到：</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209211514744.png" style="zoom:33%;" /></p>
<p>实际上等式的右边就是TD Target $y_t$。</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209211515663.png" style="zoom:33%;" /></p>
<h3 id="3-7-REINFORCE-versus-A2C"><a href="#3-7-REINFORCE-versus-A2C" class="headerlink" title="3.7 REINFORCE versus A2C"></a>3.7 REINFORCE versus A2C</h3><p>REINFORCE和A2C最大的区别就是TD Target的定义不一样，REINFORCE定义TD Target时考虑了全部时刻的reward，而A2C只考虑了部分时刻的reward。在A2C中，又分为one-step TD Target和multi-step TD Target，二者的区别在于：one-step TD Target就是上面说的A2C的版本，只考虑当前时刻的reward，而multi-step TD Target考虑了从当前时刻开始到未来某一时刻的reward。</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209211535467.png" style="zoom:33%;" /></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209211535996.png" style="zoom:33%;" /></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209211536691.png" style="zoom:33%;" /></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209211536175.png" style="zoom:33%;" /></p>
<p>区别就在于：</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209211537635.png" style="zoom:33%;" /></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202209211537367.png" style="zoom:33%;" /></p>
]]></content>
      <categories>
        <category>Deep Reinforcement Learning</category>
      </categories>
      <tags>
        <tag>Deep Reinforcement Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Git命令使用</title>
    <url>/2022/11/02/Git%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="Git命令使用"><a href="#Git命令使用" class="headerlink" title="Git命令使用"></a>Git命令使用</h1><h2 id="git-cherry-pick"><a href="#git-cherry-pick" class="headerlink" title="git cherry-pick"></a>git cherry-pick</h2><p><a href="https://blog.csdn.net/FightFightFight/article/details/81039050">https://blog.csdn.net/FightFightFight/article/details/81039050</a></p>
<p>通常用于在两个分支之间，比如master和prod，想把master分支上的部分commit合并到prod上。<br><span id="more"></span><br>git cherry-pick将某一个commit合并到当前本地所在分支上。</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git cherry-pick commit-ish</span><br></pre></td></tr></table></figure>
<p>如果出现冲突，需要手动解决冲突。然后</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 暂存修改，可以直接commit</span></span><br><span class="line">$ git commit</span><br><span class="line"><span class="comment"># 或者add + cherry-pick --continue</span></span><br><span class="line">$ git add . </span><br><span class="line">$ git cherry-pick --<span class="built_in">continue</span></span><br><span class="line"><span class="comment"># 最后推送到远端仓库。</span></span><br><span class="line">$ git push</span><br></pre></td></tr></table></figure>
<p>如果解决冲突后，本地分支内容和cheey-pick之间没有改变，</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.取消上次操作</span></span><br><span class="line">$ git cherry-pick --abort</span><br><span class="line"><span class="comment"># 2.允许空提交</span></span><br><span class="line">$ git commit --allow-empty</span><br></pre></td></tr></table></figure>
<h2 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h2><p>列出本地所有分支以及当前所在分支</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">  master</span><br><span class="line">* prod</span><br></pre></td></tr></table></figure>
<p>删除本地分支</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git branch --delete <span class="built_in">test</span></span><br><span class="line">$ git branch -d <span class="built_in">test</span></span><br><span class="line">Deleted branch <span class="built_in">test</span> (was 2df9b8d).</span><br></pre></td></tr></table></figure>
<p>删除远程分支</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git push origin :dev  </span><br></pre></td></tr></table></figure>
<h2 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h2><p>切换本地分支</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">&#x27;master&#x27;</span></span><br></pre></td></tr></table></figure>
<p>新建本地分支并且切换过去</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git checkout -b <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<p>在使用本地多分支开发时，切换分支时，记得暂存当前分支的修改，也就是git add + git commit</p>
<h2 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h2><p>拉取远程仓库某一个分支到本地</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 不指定分支的话默认为 master 分支, 拉取到本地所在分支</span></span><br><span class="line">$ git fetch origin</span><br><span class="line"><span class="comment"># 指定远程分支和本地分支</span></span><br><span class="line">$ git fetch origin master:tmp</span><br></pre></td></tr></table></figure>
<h2 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h2><p>用于将本地一个分支的代码合并到当前所在分支</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git merge dev-47</span><br></pre></td></tr></table></figure>
<h2 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h2><p>比较某一个分支和当前分支的区别</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">$ git diff tmp</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-V2-16-数值的整数次方</title>
    <url>/2022/11/05/%E5%89%91%E6%8C%87offer-V2-16-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9/</url>
    <content><![CDATA[<h1 id="剑指offer-V2-16-数值的整数次方"><a href="#剑指offer-V2-16-数值的整数次方" class="headerlink" title="剑指offer-V2-16-数值的整数次方"></a>剑指offer-V2-16-数值的整数次方</h1><p><a href="https://leetcode.cn/problems/shu-zhi-de-zheng-shu-ci-fang-lcof/description/">原题点这里</a></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202211051045285.png" alt=""></p>
<span id="more"></span>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>对于十进制整数n，其二进制表示形式为$b_m…b_2b_1$，换算公式为：$n=2^0b_1+2^1b_2+…+2^{m-1}b_m$。所以$x^n=x^{2^0b_1+2^1b_2+…+2^{m-1}b_m}=x^{2^0b_1}x^{2^1b_2}…x^{2^{m-1}b_m}$，因此就可以实现对数级别时间复杂度的计算。可以采用n&amp;1来计算n当前最右边是0还是1，采用n&gt;&gt;=1来右移计算下一位。</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202211051049538.png" alt=""></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">myPow</span><span class="params">(x <span class="type">float64</span>, n <span class="type">int</span>)</span></span> <span class="type">float64</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> x == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> n &lt; <span class="number">0</span> &#123;</span><br><span class="line">		x = <span class="number">1</span> / x</span><br><span class="line">		n = -n</span><br><span class="line">	&#125;</span><br><span class="line">	res := <span class="number">1.0</span></span><br><span class="line">	<span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> n&amp;<span class="number">1</span> == <span class="number">1</span> &#123;</span><br><span class="line">			res *= x</span><br><span class="line">		&#125;</span><br><span class="line">		x *= x</span><br><span class="line">		n &gt;&gt;= <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>offer</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-V2-15-二进制中1的个数</title>
    <url>/2022/11/02/%E5%89%91%E6%8C%87offer-V2-15-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<h1 id="剑指offer-V2-15-二进制中1的个数"><a href="#剑指offer-V2-15-二进制中1的个数" class="headerlink" title="剑指offer-V2-15-二进制中1的个数"></a>剑指offer-V2-15-二进制中1的个数</h1><p><a href="https://leetcode.cn/problems/er-jin-zhi-zhong-1de-ge-shu-lcof/">原题点这里</a></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202211021717595.png" alt=""></p>
<span id="more"></span>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>直接和&amp;1，逐位查看是否等于1</p>
<h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>每次n&amp;(n-1)，相当于消去n最右边的1。</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202211021720959.png" alt=""></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hammingWeight</span><span class="params">(num <span class="type">uint32</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	ret := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> num &gt; <span class="number">0</span> &#123;</span><br><span class="line">		ret += <span class="type">int</span>(num &amp; <span class="number">1</span>)</span><br><span class="line">		num &gt;&gt;= <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">hammingWeight</span><span class="params">(num <span class="type">uint32</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	ret := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> num &gt; <span class="number">0</span> &#123;</span><br><span class="line">		ret++</span><br><span class="line">		num = num &amp; (num - <span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>offer</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-V2-17-打印从1到最大的n位数</title>
    <url>/2022/11/06/%E5%89%91%E6%8C%87offer-V2-17-%E6%89%93%E5%8D%B0%E4%BB%8E1%E5%88%B0%E6%9C%80%E5%A4%A7%E7%9A%84n%E4%BD%8D%E6%95%B0/</url>
    <content><![CDATA[<h1 id="剑指offer-V2-17-打印从1到最大的n位数"><a href="#剑指offer-V2-17-打印从1到最大的n位数" class="headerlink" title="剑指offer-V2-17-打印从1到最大的n位数"></a>剑指offer-V2-17-打印从1到最大的n位数</h1><p><a href="https://leetcode.cn/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof/description/">原题点这里</a></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202211061542052.png" alt=""></p>
<span id="more"></span>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>最直接的想法是遍历，循环次数是10的n次幂。</p>
<h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>如果对于大数来说，遍历较慢，可以采用全排列的思想来做。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printNumbers</span><span class="params">(n <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">	ret := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="type">int</span>(math.Pow10(n)); i++ &#123;</span><br><span class="line">		ret = <span class="built_in">append</span>(ret, i)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">printNumbers</span><span class="params">(n <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">	ret := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">	cs := []<span class="type">byte</span>&#123;<span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>&#125;</span><br><span class="line">	tmp := <span class="built_in">make</span>([]<span class="type">byte</span>, n)</span><br><span class="line">	<span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(k <span class="type">int</span>)</span></span></span><br><span class="line">	dfs = <span class="function"><span class="keyword">func</span><span class="params">(k <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> k == n &#123;</span><br><span class="line">			num, _ := strconv.Atoi(<span class="type">string</span>(tmp))</span><br><span class="line">			<span class="keyword">if</span> num != <span class="number">0</span> &#123;</span><br><span class="line">				ret = <span class="built_in">append</span>(ret, num)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> _, c := <span class="keyword">range</span> cs &#123;</span><br><span class="line">			tmp[k] = c</span><br><span class="line">			dfs(k + <span class="number">1</span>)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	dfs(<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>offer</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-V2-18-删除链表的节点</title>
    <url>/2022/11/06/%E5%89%91%E6%8C%87offer-V2-18-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h1 id="剑指offer-V2-18-删除链表的节点"><a href="#剑指offer-V2-18-删除链表的节点" class="headerlink" title="剑指offer-V2-18-删除链表的节点"></a>剑指offer-V2-18-删除链表的节点</h1><p><a href="https://leetcode.cn/problems/shan-chu-lian-biao-de-jie-dian-lcof/description/">原题点这里</a></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202211061551629.png" alt=""></p>
<span id="more"></span>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>删除某一个节点就是将其pre直接与其next相连，注意要删除的节点是头节点的情况。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">deleteNode</span><span class="params">(head *ListNode, val <span class="type">int</span>)</span></span> *ListNode &#123;</span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> || head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">    <span class="keyword">if</span> head.Val == val &#123;</span><br><span class="line">		<span class="keyword">return</span> head.Next</span><br><span class="line">	&#125;</span><br><span class="line">	pre, cur := head, head.Next</span><br><span class="line">	<span class="keyword">for</span> cur != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> cur.Val == val &#123;</span><br><span class="line">			pre.Next = cur.Next</span><br><span class="line">			cur = cur.Next</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			pre = cur</span><br><span class="line">			cur = cur.Next</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>offer</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-V2-19-正则表达式匹配</title>
    <url>/2022/11/07/%E5%89%91%E6%8C%87offer-V2-19-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/</url>
    <content><![CDATA[<h1 id="剑指offer-V2-19-正则表达式匹配"><a href="#剑指offer-V2-19-正则表达式匹配" class="headerlink" title="剑指offer-V2-19-正则表达式匹配"></a>剑指offer-V2-19-正则表达式匹配</h1><p><a href="https://leetcode.cn/problems/zheng-ze-biao-da-shi-pi-pei-lcof/description/">原题点这里</a></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202211071422435.png" alt=""></p>
<span id="more"></span>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202211071423096.png" alt=""></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><a href="https://leetcode.cn/problems/zheng-ze-biao-da-shi-pi-pei-lcof/solutions/92888/zhu-xing-xiang-xi-jiang-jie-you-qian-ru-shen-by-je/">https://leetcode.cn/problems/zheng-ze-biao-da-shi-pi-pei-lcof/solutions/92888/zhu-xing-xiang-xi-jiang-jie-you-qian-ru-shen-by-je/</a></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202211071423034.png" alt=""></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isMatch</span><span class="params">(s <span class="type">string</span>, p <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(p) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(s) != <span class="number">0</span> &amp;&amp; <span class="built_in">len</span>(p) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	f := <span class="built_in">make</span>([][]<span class="type">bool</span>, <span class="built_in">len</span>(s)+<span class="number">1</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s)+<span class="number">1</span>; i++ &#123;</span><br><span class="line">		f[i] = <span class="built_in">make</span>([]<span class="type">bool</span>, <span class="built_in">len</span>(p)+<span class="number">1</span>)</span><br><span class="line">	&#125;</span><br><span class="line">	f[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span></span><br><span class="line">	<span class="comment">// f[i][j]代表字符串的前i个和模式串的前j个是否能匹配，之所以要开成(len(s)+1)*(len(p)+1)的数组是为了处理空串。</span></span><br><span class="line">	<span class="comment">// f[2][3]代表字符串的前2个也就是一共两个元素和模式串的前3个也就是一共3个能否匹配。</span></span><br><span class="line">	<span class="comment">// f[0][0]默认为true，代表空串的情况，也就是字符串前0个和模式串前0个是匹配的。</span></span><br><span class="line">	<span class="comment">// f[0][j]默认为false，代表字符串为空的情况，字符串空、模式串非空肯定不匹配。</span></span><br><span class="line">	<span class="comment">// 对于f里面所说的第i个或者第j个，对应原字符串或者模试串的下标为i-1或者j-1。</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(f); i++ &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="number">1</span>; j &lt; <span class="built_in">len</span>(f[<span class="number">0</span>]); j++ &#123;</span><br><span class="line">			<span class="comment">// 每次循环中，想确定的是f[i][j]的值，也就是看字符串的前i个和模式串的前j个是否能匹配。</span></span><br><span class="line">			<span class="comment">// 模式串第j个是*，也就是下标j-1</span></span><br><span class="line">			<span class="keyword">if</span> p[j<span class="number">-1</span>] == <span class="string">&#x27;*&#x27;</span> &#123;</span><br><span class="line">				<span class="keyword">if</span> f[i][j<span class="number">-2</span>] &#123;</span><br><span class="line">					<span class="comment">// 判断模式串第j-1个，即看f[i][j-2]的值。如果f[i][j-2]能匹配，想当于可以不看当前*以及*前的字符。</span></span><br><span class="line">					f[i][j] = <span class="literal">true</span></span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> i != <span class="number">0</span> &amp;&amp; f[i<span class="number">-1</span>][j] &amp;&amp; (s[i<span class="number">-1</span>] == p[j<span class="number">-2</span>] || p[j<span class="number">-2</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">					<span class="comment">// 对应字符串前i个和模式串前j-1个不匹配情况</span></span><br><span class="line">					<span class="comment">// 如果f[i-1][j]==true，代表字符串前i-1个和模式串前j个匹配，也就是说字符串第i-1个的值和模式串第j-1个也就是*前的字符相等。</span></span><br><span class="line">					<span class="comment">// 如果f[i-1][j]==false，反之，那么就不用考虑了。</span></span><br><span class="line">					<span class="comment">// 1. s[i-1] == p[j-2] 代表字符串第i个和模式串*之前也就是第j-1个相等</span></span><br><span class="line">					<span class="comment">// 2. p[j-2] == &#x27;.&#x27; 代表模式串第j-1个是.</span></span><br><span class="line">					<span class="comment">// 以上两种情况都是属于匹配的</span></span><br><span class="line">					f[i][j] = <span class="literal">true</span></span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> i != <span class="number">0</span> &amp;&amp; f[i<span class="number">-1</span>][j<span class="number">-1</span>] &amp;&amp; (s[i<span class="number">-1</span>] == p[j<span class="number">-1</span>] || p[j<span class="number">-1</span>] == <span class="string">&#x27;.&#x27;</span>) &#123;</span><br><span class="line">				<span class="comment">// 模式串第j个不是*，有可能是.或者字母</span></span><br><span class="line">				<span class="comment">// 因为是确定了1对1的，那么先看下f[i-1][j-1]，如果下一阶段不匹配，那么当前阶段就不用看了。</span></span><br><span class="line">				f[i][j] = <span class="literal">true</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> f[<span class="built_in">len</span>(s)][<span class="built_in">len</span>(p)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>offer</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-V2-20-表示数值的字符串</title>
    <url>/2022/11/08/%E5%89%91%E6%8C%87offer-V2-20-%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="剑指offer-V2-20-表示数值的字符串"><a href="#剑指offer-V2-20-表示数值的字符串" class="headerlink" title="剑指offer-V2-20-表示数值的字符串"></a>剑指offer-V2-20-表示数值的字符串</h1><p><a href="https://leetcode.cn/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof/description/">原题点这里</a></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202211081029639.png" alt=""></p>
<span id="more"></span>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202211081029336.png" alt=""></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>有限状态自动机，确定所有可能出现的状态：</p>
<ol>
<li>起始的空格</li>
<li>符号位</li>
<li>整数部分</li>
<li>左侧有整数的小数点</li>
<li>左侧无整数的小数点（根据前面的第二条额外规则，需要对左侧有无整数的两种小数点做区分）</li>
<li>小数部分</li>
<li>字符 e</li>
<li>指数部分的符号位</li>
<li>指数部分的整数部分</li>
<li>末尾的空格</li>
</ol>
<p>状态转移：</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202211081032973.png" alt=""></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> State <span class="type">int</span></span><br><span class="line"><span class="keyword">type</span> CharType <span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	STATE_INITIAL State = <span class="literal">iota</span></span><br><span class="line">	STATE_INT_SIGN</span><br><span class="line">	STATE_INTEGER</span><br><span class="line">	STATE_POINT</span><br><span class="line">	STATE_POINT_WITHOUT_INT</span><br><span class="line">	STATE_FRACTION</span><br><span class="line">	STATE_EXP</span><br><span class="line">	STATE_EXP_SIGN</span><br><span class="line">	STATE_EXP_NUMBER</span><br><span class="line">	STATE_END</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">	CHAR_NUMBER CharType = <span class="literal">iota</span></span><br><span class="line">	CHAR_EXP</span><br><span class="line">	CHAR_POINT</span><br><span class="line">	CHAR_SIGN</span><br><span class="line">	CHAR_SPACE</span><br><span class="line">	CHAR_ILLEGAL</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">toCharType</span><span class="params">(ch <span class="type">byte</span>)</span></span> CharType &#123;</span><br><span class="line">	<span class="keyword">switch</span> ch &#123;</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;0&#x27;</span>, <span class="string">&#x27;1&#x27;</span>, <span class="string">&#x27;2&#x27;</span>, <span class="string">&#x27;3&#x27;</span>, <span class="string">&#x27;4&#x27;</span>, <span class="string">&#x27;5&#x27;</span>, <span class="string">&#x27;6&#x27;</span>, <span class="string">&#x27;7&#x27;</span>, <span class="string">&#x27;8&#x27;</span>, <span class="string">&#x27;9&#x27;</span>:</span><br><span class="line">		<span class="keyword">return</span> CHAR_NUMBER</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;E&#x27;</span>:</span><br><span class="line">		<span class="keyword">return</span> CHAR_EXP</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;.&#x27;</span>:</span><br><span class="line">		<span class="keyword">return</span> CHAR_POINT</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>, <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">		<span class="keyword">return</span> CHAR_SIGN</span><br><span class="line">	<span class="keyword">case</span> <span class="string">&#x27; &#x27;</span>:</span><br><span class="line">		<span class="keyword">return</span> CHAR_SPACE</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> CHAR_ILLEGAL</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isNumber</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	transfer := <span class="keyword">map</span>[State]<span class="keyword">map</span>[CharType]State&#123;</span><br><span class="line">		STATE_INITIAL: <span class="keyword">map</span>[CharType]State&#123;</span><br><span class="line">			CHAR_SPACE:  STATE_INITIAL,</span><br><span class="line">			CHAR_NUMBER: STATE_INTEGER,</span><br><span class="line">			CHAR_POINT:  STATE_POINT_WITHOUT_INT,</span><br><span class="line">			CHAR_SIGN:   STATE_INT_SIGN,</span><br><span class="line">		&#125;,</span><br><span class="line">		STATE_INT_SIGN: <span class="keyword">map</span>[CharType]State&#123;</span><br><span class="line">			CHAR_NUMBER: STATE_INTEGER,</span><br><span class="line">			CHAR_POINT:  STATE_POINT_WITHOUT_INT,</span><br><span class="line">		&#125;,</span><br><span class="line">		STATE_INTEGER: <span class="keyword">map</span>[CharType]State&#123;</span><br><span class="line">			CHAR_NUMBER: STATE_INTEGER,</span><br><span class="line">			CHAR_EXP:    STATE_EXP,</span><br><span class="line">			CHAR_POINT:  STATE_POINT,</span><br><span class="line">			CHAR_SPACE:  STATE_END,</span><br><span class="line">		&#125;,</span><br><span class="line">		STATE_POINT: <span class="keyword">map</span>[CharType]State&#123;</span><br><span class="line">			CHAR_NUMBER: STATE_FRACTION,</span><br><span class="line">			CHAR_EXP:    STATE_EXP,</span><br><span class="line">			CHAR_SPACE:  STATE_END,</span><br><span class="line">		&#125;,</span><br><span class="line">		STATE_POINT_WITHOUT_INT: <span class="keyword">map</span>[CharType]State&#123;</span><br><span class="line">			CHAR_NUMBER: STATE_FRACTION,</span><br><span class="line">		&#125;,</span><br><span class="line">		STATE_FRACTION: <span class="keyword">map</span>[CharType]State&#123;</span><br><span class="line">			CHAR_NUMBER: STATE_FRACTION,</span><br><span class="line">			CHAR_EXP:    STATE_EXP,</span><br><span class="line">			CHAR_SPACE:  STATE_END,</span><br><span class="line">		&#125;,</span><br><span class="line">		STATE_EXP: <span class="keyword">map</span>[CharType]State&#123;</span><br><span class="line">			CHAR_NUMBER: STATE_EXP_NUMBER,</span><br><span class="line">			CHAR_SIGN:   STATE_EXP_SIGN,</span><br><span class="line">		&#125;,</span><br><span class="line">		STATE_EXP_SIGN: <span class="keyword">map</span>[CharType]State&#123;</span><br><span class="line">			CHAR_NUMBER: STATE_EXP_NUMBER,</span><br><span class="line">		&#125;,</span><br><span class="line">		STATE_EXP_NUMBER: <span class="keyword">map</span>[CharType]State&#123;</span><br><span class="line">			CHAR_NUMBER: STATE_EXP_NUMBER,</span><br><span class="line">			CHAR_SPACE:  STATE_END,</span><br><span class="line">		&#125;,</span><br><span class="line">		STATE_END: <span class="keyword">map</span>[CharType]State&#123;</span><br><span class="line">			CHAR_SPACE: STATE_END,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	state := STATE_INITIAL</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">		typ := toCharType(s[i])</span><br><span class="line">		<span class="keyword">if</span> _, ok := transfer[state][typ]; !ok &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			state = transfer[state][typ]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> state == STATE_INTEGER || state == STATE_POINT || state == STATE_FRACTION || state == STATE_EXP_NUMBER || state == STATE_END</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>offer</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-V2-21-调整数组顺序使奇数位于偶数前面</title>
    <url>/2022/11/08/%E5%89%91%E6%8C%87offer-V2-21-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2/</url>
    <content><![CDATA[<h1 id="剑指offer-V2-21-调整数组顺序使奇数位于偶数前面"><a href="#剑指offer-V2-21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="剑指offer-V2-21-调整数组顺序使奇数位于偶数前面"></a>剑指offer-V2-21-调整数组顺序使奇数位于偶数前面</h1><p><a href="https://leetcode.cn/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/description/">原题点这里</a></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202211081052911.png" alt=""></p>
<span id="more"></span>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>快速排序的基础，采用双指针。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">exchange</span><span class="params">(nums []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	i := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> k := <span class="number">0</span>; k &lt; <span class="built_in">len</span>(nums); k++ &#123;</span><br><span class="line">		<span class="keyword">if</span> nums[k]%<span class="number">2</span> != <span class="number">0</span> &#123;</span><br><span class="line">			nums[i], nums[k] = nums[k], nums[i]</span><br><span class="line">			i++</span><br><span class="line"></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> nums</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>offer</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-V2-22-链表中倒数第k个节点</title>
    <url>/2022/11/10/%E5%89%91%E6%8C%87offer-V2-22-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h1 id="剑指offer-V2-22-链表中倒数第k个节点"><a href="#剑指offer-V2-22-链表中倒数第k个节点" class="headerlink" title="剑指offer-V2-22-链表中倒数第k个节点"></a>剑指offer-V2-22-链表中倒数第k个节点</h1><p><a href="https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/description/">原题点这里</a></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202211101442859.png" alt=""></p>
<span id="more"></span>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>快慢指针、双指针，一个走得快的先走k步，一个走的慢的。这样当快指针走完的时候，慢指针就是倒数第k个。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getKthFromEnd</span><span class="params">(head *ListNode, k <span class="type">int</span>)</span></span> *ListNode &#123;</span><br><span class="line">	pre, cur := head, head</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; k; i++ &#123;</span><br><span class="line">		cur = cur.Next</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> cur != <span class="literal">nil</span> &#123;</span><br><span class="line">		pre = pre.Next</span><br><span class="line">		cur = cur.Next</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> pre</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>offer</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-V2-24-反转链表</title>
    <url>/2022/11/10/%E5%89%91%E6%8C%87offer-V2-24-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="剑指offer-V2-24-反转链表"><a href="#剑指offer-V2-24-反转链表" class="headerlink" title="剑指offer-V2-24-反转链表"></a>剑指offer-V2-24-反转链表</h1><p><a href="https://leetcode.cn/problems/fan-zhuan-lian-biao-lcof/description/">原题点这里</a></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202211101447159.png" alt=""></p>
<span id="more"></span>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>递归解法，假设链表现在长这样：</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202211101449942.png" alt=""></p>
<p>如果链表一部分已经被反转了：</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202211101449325.png" alt=""></p>
<p>那么实际上只要调整下$n_k$和$n_{k+1}$的前后指向关系就好。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseList</span><span class="params">(head *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">	<span class="keyword">if</span> head == <span class="literal">nil</span> || head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> head</span><br><span class="line">	&#125;</span><br><span class="line">	tmp := reverseList(head.Next)</span><br><span class="line">	head.Next.Next = head</span><br><span class="line">	head.Next = <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">return</span> tmp</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>offer</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-V2-25-合并两个排序的链表</title>
    <url>/2022/11/11/%E5%89%91%E6%8C%87offer-V2-25-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="剑指offer-V2-25-合并两个排序的链表"><a href="#剑指offer-V2-25-合并两个排序的链表" class="headerlink" title="剑指offer-V2-25-合并两个排序的链表"></a>剑指offer-V2-25-合并两个排序的链表</h1><p><a href="https://leetcode.cn/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/description/">原题点这里</a></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202211111106105.png" alt=""></p>
<span id="more"></span>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>按照顺序合并，最后返回头节点的Next就好。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * type ListNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Next *ListNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeTwoLists</span><span class="params">(l1 *ListNode, l2 *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">	ret := &amp;ListNode&#123;&#125;</span><br><span class="line">	head := ret</span><br><span class="line">	<span class="keyword">for</span> l1 != <span class="literal">nil</span> &amp;&amp; l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> l1.Val &lt; l2.Val &#123;</span><br><span class="line">			ret.Next = &amp;ListNode&#123;Val: l1.Val&#125;</span><br><span class="line">			l1 = l1.Next</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			ret.Next = &amp;ListNode&#123;Val: l2.Val&#125;</span><br><span class="line">			l2 = l2.Next</span><br><span class="line">		&#125;</span><br><span class="line">		ret = ret.Next</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> l1 != <span class="literal">nil</span> &#123;</span><br><span class="line">		ret.Next = l1</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">		ret.Next = l2</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> head.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>offer</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-V2-26-树的子结构</title>
    <url>/2022/11/11/%E5%89%91%E6%8C%87offer-V2-26-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="剑指offer-V2-26-树的子结构"><a href="#剑指offer-V2-26-树的子结构" class="headerlink" title="剑指offer-V2-26-树的子结构"></a>剑指offer-V2-26-树的子结构</h1><p><a href="https://leetcode.cn/problems/shu-de-zi-jie-gou-lcof/description/">原题点这里</a></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202211111316537.png" alt=""></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202211111316088.png" alt=""></p>
<span id="more"></span>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>首先特例处理，如果A为空或者B为空，那么false。接着，对于isSubStructure，有三种情况：</p>
<ol>
<li>B的根节点和A的根节点值相同，也就是说B是A的根节点的子树。</li>
<li>B的根节点和A的左子树的根节点值相同，也就是说B是A的左子树的子树。</li>
<li>B的根节点和A的右子树的根节点值相同，也就是说B是A的右子树的子树。</li>
</ol>
<p>其中2、3情况可以直接用isSubStructure递归来做。</p>
<p>对于第一种情况，需要再开一个递归函数叫做recur。递归终止条件是：</p>
<ol>
<li>如果A为空，代表B不是A的子树。</li>
<li>如果B为空，代表B是A的子树。</li>
<li>如果A的值不等于B的值，代表B不是A的子树。</li>
</ol>
<p>返回值是：recur(A.Left, B.Left) &amp;&amp; recur(A.Right, B.Right)。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSubStructure</span><span class="params">(A *TreeNode, B *TreeNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> A == <span class="literal">nil</span> || B == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> recur(A, B) || isSubStructure(A.Left, B) || isSubStructure(A.Right, B)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recur</span><span class="params">(A *TreeNode, B *TreeNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> B == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> A == <span class="literal">nil</span> || A.Val != B.Val &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> recur(A.Left, B.Left) &amp;&amp; recur(A.Right, B.Right)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>offer</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>offer</tag>
      </tags>
  </entry>
  <entry>
    <title>网络是怎样连接的-1.浏览器生成消息</title>
    <url>/2022/11/11/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84-1-%E6%B5%8F%E8%A7%88%E5%99%A8%E7%94%9F%E6%88%90%E6%B6%88%E6%81%AF/</url>
    <content><![CDATA[<h1 id="第一章-浏览器生成消息"><a href="#第一章-浏览器生成消息" class="headerlink" title="第一章 浏览器生成消息"></a>第一章 浏览器生成消息</h1><ul>
<li>本章讲的是HTTP消息长啥样、往哪里发消息、怎么发消息</li>
</ul>
<h2 id="1-1-生成HTTP消息"><a href="#1-1-生成HTTP消息" class="headerlink" title="1.1 生成HTTP消息"></a>1.1 生成HTTP消息</h2><ul>
<li>主要讲的是HTTP消息长啥样。</li>
<li><p>HTTP是啥？</p>
<ul>
<li>Hypertext Transfer Protocol，超文本传送协议。</li>
</ul>
</li>
<li><p>URL是啥？</p>
<ul>
<li>Uniform Resource Locator，统一资源定位符。</li>
</ul>
</li>
<li>URL常见格式？</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220327182430.png" style="zoom:80%;" /><br><span id="more"></span></p>
<ul>
<li>Web浏览器解析URL的过程？</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220327182626.png" style="zoom:80%;" /></p>
<ul>
<li><p>几种省略文件名的情况：</p>
<ul>
<li><a href="http://www.lab.glasscom.com/dir/：访问dir路径下的index.html之类的默认文件。">http://www.lab.glasscom.com/dir/：访问dir路径下的index.html之类的默认文件。</a></li>
<li><a href="http://www.lab.glasscom.com/：同上">http://www.lab.glasscom.com/：同上</a></li>
<li><a href="http://www.lab.glasscom.com：同上">http://www.lab.glasscom.com：同上</a></li>
<li><a href="http://www.lab.glasscom.com/whatisthis：如果根路径下有whatisthis的文件，就按照访问该文件处理，如果有whatisthis的目录，就按目录来处理。">http://www.lab.glasscom.com/whatisthis：如果根路径下有whatisthis的文件，就按照访问该文件处理，如果有whatisthis的目录，就按目录来处理。</a></li>
</ul>
</li>
<li><p>HTTP的基本思路：</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220327183144.png" style="zoom:80%;" /></p>
<p>​    HTTP消息主要包含两个部分：“对什么”和“进行怎样的操作”。其中，“对什么”的部分称为Uniform Resource Identifier，统一资源标识符。“进行怎样的操作”的部分称为方法。</p>
<ul>
<li>HTTP的主要方法：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220327183548.png" style="zoom:80%;" /></p>
<ul>
<li><strong>HTTP请求消息到底长啥样？</strong><ul>
<li>第一行称为请求行。这里表明了请求方法以及HTTP的版本行。</li>
<li>第二行为消息头。这里表明了如日期、客户端支持的数据类型、语言、压缩格式、客户端和服务器的软件名称和版本、数据有效期和最后更新时间等。</li>
<li>第三行为空行。</li>
<li>最后一部分为消息体。</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220327184013.png" style="zoom:80%;" /></p>
<ul>
<li><strong>HTTP响应消息到底长啥样？</strong><ul>
<li>第一行为状态码和响应短语，二者表示内容一致，即成功或失败。状态码是一个数字，响应短语是一段文字。</li>
<li>第二行为空行。</li>
<li>最后一部分为消息体。</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220327184237.png" style="zoom:80%;" /></p>
<ul>
<li><p>注意：1 条请求消息中只能写 1 个 URI。如果需要获取多个文件，必须对每个文件单独发送 1 条请求。</p>
</li>
<li><p>一个浏览器与Web服务器进行消息交互的实例：</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220327184458.png" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220327184518.png" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220327184707.png" style="zoom:80%;" /></p>
<h2 id="1-2-向-DNS-服务器查询-Web-服务器的-IP-地址"><a href="#1-2-向-DNS-服务器查询-Web-服务器的-IP-地址" class="headerlink" title="1.2 向 DNS 服务器查询 Web 服务器的 IP 地址"></a>1.2 向 DNS 服务器查询 Web 服务器的 IP 地址</h2><ul>
<li><p>主要讲的是向哪里发消息。</p>
</li>
<li><p><strong>TCP/IP的结构：</strong></p>
<ul>
<li>路由器：一种对包进行转发的设备</li>
<li><p>集线器：一种对包进行转发的设备</p>
</li>
<li><p>子网：用集线器连起来的几台计算机</p>
</li>
<li>网络：用路由器把子网连起来</li>
<li>IP地址：某一台计算机在网络中的地址</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220327185536.png" style="zoom:80%;" /></p>
<ul>
<li>先简单看一下消息发送的具体过程：<ul>
<li>发送者发出的消息经过子网的集线器，发到最近的路由器上。</li>
<li>路由器会根据消息的目的地判断下一个路由器的位置，然后将消息发送到下一个路由器上。</li>
<li>第二步不断重复，消息就到了目的地。</li>
</ul>
</li>
<li><strong>IP地址的组成：</strong><ul>
<li>本质是一串32比特的数字，按照8比特也就是1字节为一组分成4组。</li>
<li>4组数字分别用十进制表示，再用圆点隔开。</li>
<li>在32比特中，包括了网络号和主机号。因此还需要额外的信息来表明哪一部分是网络号，哪一部分是主机号。</li>
<li><strong>子网掩码</strong>用于表明网络号和主机号的组成形式<ul>
<li>子网掩码中为1的部分代表网络号，为0的部分代表主机号，如下图b</li>
<li>或者表明左数多少个比特是网络号，如下图c</li>
</ul>
</li>
<li>IP地址的主机号全0表示整个子网，全1表示向子网上的所有设备发送包，即广播。</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220327190452.png" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220327190709.png" style="zoom:80%;" /></p>
<ul>
<li>为什么有了域名还要IP？<ul>
<li>因为IP只要处理32比特的地址，而域名往往更长，处理地址的时间更长。</li>
</ul>
</li>
<li>那为啥不干脆直接用IP？<ul>
<li>IP太难记，偷懒记个域名比较方便。</li>
</ul>
</li>
<li><strong>DNS是啥？</strong><ul>
<li>Domain Name System，域名服务系统。</li>
</ul>
</li>
</ul>
<p>​        对于DNS服务器，计算机上有相应的DNS客户端。这个客户端就叫做DNS解析器或者解析器，通过DNS查询IP地址的操作就叫<strong>域名解析</strong>。负责执行解析这一操作的就是解析器。</p>
<p>​        解析器实际上是一段程序，存在于OS的Socket库中。Socket 库是用于调用网络功能的程序组件集合。</p>
<ul>
<li>如何才能知道域名和IP地址的对应关系？<ul>
<li>问问最近的DNS服务器就知道了。</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220327191434.png" style="zoom:80%;" /></p>
<ul>
<li>解析器内部原理：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220327191532.png" style="zoom:80%;" /></p>
<ul>
<li>Btw，向DNS服务发消息的时候当然也要知道DNS服务器的IP。不过这个IP是提前设置好的，如windows中：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220327191708.png" style="zoom:80%;" /></p>
<h2 id="1-3-全世界-DNS-服务器的大接力"><a href="#1-3-全世界-DNS-服务器的大接力" class="headerlink" title="1.3 全世界 DNS 服务器的大接力"></a>1.3 全世界 DNS 服务器的大接力</h2><ul>
<li>主要讲的还是往哪里发消息</li>
<li>DNS服务器接收来自客户端的消息，包含以下三种：<ul>
<li>域名</li>
<li>Class：早期设计DNS时，考虑了除互联网以外的其他网络，Class用于识别网络类型，互联网的Class值为IN。</li>
<li>记录类型：表示域名是何种类型的记录。比如当类型为A（Address）代表域名对应的是IP地址，当类型为MX（Mail eXchange）时，表示域名对应的时邮件服务器。</li>
</ul>
</li>
<li>DNS工作流程：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220327192626.png" style="zoom:80%;" /></p>
<ul>
<li>域名的层次结构：</li>
</ul>
<p>​        在域名中，越靠右的位置表示层级越高。其中，相当与一个层级的部分称为域。比如www.lab.glasscom.com 这个域名，公有4个域，www、lab、glasscom、com，其中com层级最高，www最低。每个域的信息作为整体存放在DNS服务器中，一台DNS服务器可以保存多个域的信息。简单起见，我们默认一台DNS服务器只保存一个域的信息。</p>
<ul>
<li>域名千千万，DNS服务器千千万，如何知道我们想找的域名对应的Web服务器的信息在哪一台DNS服务器上？<ul>
<li>首先，将下级域的DNS服务器的IP地址注册到它们的上级DNS服务器中。</li>
<li>再将上级DNS服务器的IP地址注册到更上级，以此类推形成树状结构。</li>
<li>这样就就可以按照层级结构，从高到低查询IP。</li>
</ul>
</li>
<li>一般来说，com等域貌似是顶级域了，但其实在com之类的域之上还有一级域，称为根域，通常被省略。如果不省略就加一个点，如 <strong>www.lab.glasscom.com.</strong>  。</li>
<li>首先将根域的IP地址保存到所有DNS服务器中，这样每一台DNS服务器可以从根域开始向下搜索，找到一个域名对应的IP。</li>
<li>分配给根域服务器的IP地址全世界只有<strong>13</strong>个。（虽然IP地址只有13个，但是服务器是非常多的）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220327193843.png" style="zoom:80%;" /></p>
<ul>
<li>具体查询域名对应IP地址的流程如下：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220327194011.png" style="zoom:80%;" /></p>
<ul>
<li>DNS服务器存在缓存功能，如果之前查过的，可以直接返回。但是注意，原本注册的信息可能发生改变，所以DNS服务器应该给缓存设置有效期。并且，DNS响应查询时，应该告诉客户端响应结果是来自缓存还是查出来的。</li>
</ul>
<h2 id="1-4-委托协议栈发送消息"><a href="#1-4-委托协议栈发送消息" class="headerlink" title="1.4 委托协议栈发送消息"></a>1.4 委托协议栈发送消息</h2><ul>
<li>主要讲的是怎么发消息。</li>
<li>使用TCP协议来收发数据的过程如下图：<ul>
<li>创建套接字（创建套接字阶段）</li>
<li>将管道连接到服务器端的套接字上（连接阶段） </li>
<li>收发数据（通信阶段） </li>
<li>断开管道并删除套接字（断开阶段）</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220327194507.png" style="zoom:80%;" /></p>
<ul>
<li>在发送数据前，两台计算机之间应当建立<strong>管道</strong>。管道两端的数据出入口称为<strong>套接字</strong>。</li>
<li>首先，服务器端创建套接字，然后客户端创建套接字，最后套接字连接形成管道。</li>
</ul>
<h3 id="1-4-1-创建套接字阶段"><a href="#1-4-1-创建套接字阶段" class="headerlink" title="1.4.1 创建套接字阶段"></a>1.4.1 创建套接字阶段</h3><ul>
<li>只需要调用Socket库中的socket程序组件即可。调用后返回一个描述符用于识别不同套接字。</li>
</ul>
<h3 id="1-4-2-连接阶段：把管道接上去"><a href="#1-4-2-连接阶段：把管道接上去" class="headerlink" title="1.4.2 连接阶段：把管道接上去"></a>1.4.2 连接阶段：把管道接上去</h3><ul>
<li>调用Socket库中connect组件，须传入三个参数：<ul>
<li>描述符，即表明用哪一个套接字和服务器端的套接字连接</li>
<li>IP</li>
<li>端口号</li>
</ul>
</li>
</ul>
<h3 id="1-4-3-通信阶段：传递消息"><a href="#1-4-3-通信阶段：传递消息" class="headerlink" title="1.4.3 通信阶段：传递消息"></a>1.4.3 通信阶段：传递消息</h3><ul>
<li>发送消息，调用Socket库中的write程序组件，传入两个参数：<ul>
<li>描述符</li>
<li>发送数据</li>
</ul>
</li>
<li>接收消息，调用Socket库中的read程序组件，传入两个参数<ul>
<li>描述符</li>
<li>保存响应消息的内存地址。</li>
</ul>
</li>
</ul>
<h3 id="1-4-4-断开阶段：收发数据结束"><a href="#1-4-4-断开阶段：收发数据结束" class="headerlink" title="1.4.4 断开阶段：收发数据结束"></a>1.4.4 断开阶段：收发数据结束</h3><ul>
<li>调用Socket库中的close程序组件，传入一个参数，描述符。</li>
</ul>
<h3 id="1-4-5-一图胜千言"><a href="#1-4-5-一图胜千言" class="headerlink" title="1.4.5 一图胜千言"></a>1.4.5 一图胜千言</h3><p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220327195733.png" style="zoom:80%;" /></p>
]]></content>
      <categories>
        <category>Network</category>
        <category>网络是怎样连接的</category>
      </categories>
      <tags>
        <tag>Network</tag>
        <tag>网络是怎样连接的</tag>
      </tags>
  </entry>
  <entry>
    <title>网络是怎样连接的-2.探索协议栈和网卡</title>
    <url>/2022/11/11/%E7%BD%91%E7%BB%9C%E6%98%AF%E6%80%8E%E6%A0%B7%E8%BF%9E%E6%8E%A5%E7%9A%84-2-%E6%8E%A2%E7%B4%A2%E5%8D%8F%E8%AE%AE%E6%A0%88%E5%92%8C%E7%BD%91%E5%8D%A1/</url>
    <content><![CDATA[<h1 id="第二章-探索协议栈和网卡"><a href="#第二章-探索协议栈和网卡" class="headerlink" title="第二章 探索协议栈和网卡"></a>第二章 探索协议栈和网卡</h1><ul>
<li>这章主要讲的是在收发数据过程中的具体工作流程，比如怎么创建套接字、怎么建立连接、怎么将数据发送出去等等。</li>
</ul>
<h2 id="2-1-创建套接字"><a href="#2-1-创建套接字" class="headerlink" title="2.1 创建套接字"></a>2.1 创建套接字</h2><ul>
<li>协议栈的内部结构：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220403111356.png" style="zoom:80%;" /></p>
<p>浏览器、邮件等一般应用程序收发数据时用TCP；DNS查询等收发较短的控制数据时用UDP。<br><span id="more"></span></p>
<ul>
<li>到底啥是套接字？</li>
</ul>
<p>​        套接字是实体就是通信控制信息。协议栈的内部有一块空间用于存放控制信息的内存空间，记录了控制通信操作的控制信息，其实体就是套接字。举个栗子，使用netstat命令可以显示套接字：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220403111926.png" style="zoom:80%;" /></p>
<ul>
<li>调用socket来创建套接字时到底发生了什么？</li>
</ul>
<p>​        首先看看消息收发操作的整个流程：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220403135124.png" style="zoom:80%;" /></p>
<p>​        </p>
<p>​        消息收发流程中，先调用socket创建套接字，其本质就是协议栈为改套接字分配一块内存空间，用于存放控制信息，并向其中写入初始状态。接着确定一个该套接字的唯一标识，并将该标识告诉应用程序，这样应用程序就知道该和谁进行通信了。</p>
<h2 id="2-2-连接服务器"><a href="#2-2-连接服务器" class="headerlink" title="2.2 连接服务器"></a>2.2 连接服务器</h2><ul>
<li>什么是连接？</li>
</ul>
<p>​    创建套接字之后，应用程序（浏览器）就会调用 connect，随后协议栈会将本地的套接字与服务器的套接字进行连接。连接就是让客户端也就是应用程序和服务器端知道该和谁通信，这些信息都是保存在套接字中的。</p>
<ul>
<li><p>有关控制信息：</p>
<ul>
<li>第一类是客户端和服务器相互联络时交换的控制信息。该信息不仅在连接时需要，在收发和断开阶段都需要，这些内容在TCP协议的规格中定义，如下表。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220403140138.png" style="zoom:80%;" /></p>
<p>这些信息会放在网络包的开头，如下图：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220403140245.png" style="zoom:80%;" /></p>
<p>当处于连接阶段网络包还没有数据的时候，网络包长这样：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220403140347.png" style="zoom:80%;" /></p>
<ul>
<li>第二类，保存在套接字中，用来控制协议栈操作的信息，协议栈会根据这些信息来执行每一步的操作。就是第一节中的套接字。</li>
</ul>
</li>
<li><p>连接操作的实际过程，调用Socket库中的connect：</p>
<ul>
<li>首先，客户端创建一个包，其中包含表示开始数据收发操作的控制信息的头部，就是上面那张表中的信息。重点是发送方和接收方的端口号，这样客户端就能知道连接服务器端的哪个套接字了。</li>
<li>然后，将头部控制位中的SYN比特设置为1，用来表示进行来连接操作。此外，还要设置序号和窗口大小。</li>
<li>TCP头部创建好后，TCP模块将信息传递给IP模块，委托它进行发送。IP模块将网络包发送给服务器端。</li>
<li>服务器端IP模块将接收到的数据传递给服务器端的TCP模块，TCP模块根据TCP头部的信息找到端口号对应的套接字，并且修改该套接字为正在连接的状态。</li>
<li>上述完成后，服务器端的TCP模块会返回响应，整个过程和客户端一样，设置TCP头部的控制信息，比如双方的端口号和SYN比特，以及将ACK控制位设置为1。然后委托IP模块进行发送。</li>
<li>然后，客户端就会收到该网络包，通过IP模块到达TCP模块。通过TCP头部信息判断连接操作是否成功，如果SYN为1表示成功，那么客户端就像套接字中写入服务器的IP、端口等信息，将状态改为连接完毕。至此，客户端的连接操作完毕。</li>
<li>最后一步，刚刚服务器端返回响应时将ACK设置为1，相应地，客户端也需要将ACK设置为1发给服务器，代表服务器刚刚发的包已经收到。当服务器收到这个返回包之后，连接操作才算全部完成。</li>
</ul>
</li>
</ul>
<h2 id="2-3-收发数据"><a href="#2-3-收发数据" class="headerlink" title="2.3 收发数据"></a>2.3 收发数据</h2><ul>
<li>建立连接之后，下一步就该收发数据了。主要就是应用程序把要发送的数据通过调用write先交给协议栈，协议栈收到数据后再执行发送操作。</li>
<li>协议栈发送数据时：<ul>
<li>首先，协议栈不关心数据中到底是啥，一切都只是二进制字节序列。</li>
<li>其次，协议栈并不是一收到数据就马上发送，先放在内部的发送缓冲区，累计到一定量再发出去，根据以下两个要素判断，二者不可得兼。<ul>
<li>第一，每个网络包能容纳的数据长度。</li>
<li>第二，时间，应用程序发送数据的频率。</li>
</ul>
</li>
</ul>
</li>
<li>对较大的数据进行拆分：</li>
</ul>
<p>​        当要发送的数据超过一个网络包能容纳的最大数据时，就要对较大数据进行拆分。对拆分出来的数据，加上TCP头部，设置发送方和接收方的端口号，然后交给IP模块进行发送。</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220403152850.png" style="zoom:80%;" /></p>
<ul>
<li>使用ACK号确认网络包已收到：</li>
</ul>
<p>​        原理如下图：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220403153535.png" style="zoom:80%;" /></p>
<p>​        序号用于表明当前从第几个字节开始发送，长度表明发送的数据包有多长，ACK号表明下一次数据该从第多少字节发送，在这之前的数据已经收到。</p>
<p>​        然而实际情况要更复杂一点。实际上序号并不会从1开始，而是用随机数计算一个初始值。如果序号从1开始，通信过程是可以预测的，很不安全。</p>
<p>​        当数据双向传输的时候原理如下图：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220403154007.png" style="zoom:80%;" /></p>
<p>​        实际工作过程如下：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220403154104.png" style="zoom:80%;" /></p>
<p>​        如果对方没有返回某些包对应的ACK号，那么就重新发送这些包。</p>
<ul>
<li>根据网络包平均往返时间调整 ACK 号等待时间：</li>
</ul>
<p>​        当网络堵塞的时候，ACK号返回就会变慢，就需要将等待时间设置的稍长，但是也不能过长也不能过短。TCP采用动态调整等待时间的方法，这个等待时间是根据 ACK 号返回所需的时间来判断的。具体来说，TCP 会在发送数据的过程中持续测量 ACK 号的返回时间，如果 ACK 号返回变慢，则相应延长等待时间；相对地，如果 ACK 号马上就能返回，则相应缩短等待时间。</p>
<ul>
<li>使用窗口有效管理 ACK 号：</li>
</ul>
<p>​        发送一个包就等待一个包的ACK号的方式虽然简单，但是在等待ACK的时候什么也不做，效率太低，于是采用滑动窗口的方式来操作，如下图：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220403154745.png" style="zoom:80%;" /></p>
<p>​        但是有个问题，如果发送方发送的太快，接收方处理不过来咋办？</p>
<p>​        接收方的TCP收到包后先将包放到接收缓冲区中，如果缓冲区满，那么发来的数据就丢失了。所以接收方应该先告诉发送方自己最多能接收多少数据。思路如下图：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220403155035.png" style="zoom:80%;" /></p>
<p>​        接收方能够接受的最大数据量称为窗口大小，一般和缓冲区大小一致。</p>
<ul>
<li>ACK 与窗口的合并：</li>
</ul>
<p>​        发送方可以根据自己发送出去的数据计算窗口减小了多少，那么增大呢？当接收方的应用程序从缓冲区中取出数据时，窗口应该增大。而ACK号是当接收方收到数据时计算，然后发送给发送方的。要是分开发送这两个参数给发送方，效率太低，所以要想办法结合在一起发送。</p>
<p>​        并且当有多个ACK号要发送时，只需要发送最后一个即可；有多个窗口更新要发送时只需要发送最后一个即可。</p>
<ul>
<li>接收 HTTP 响应消息：</li>
</ul>
<p>​        下面来讲讲接收响应。</p>
<p>​        首先，调用read程序来获取响应消息。然后该协议栈上场了，协议栈尝试从接收缓冲区中取出数据传递给应用程序，如果没有数据就i将应用程序挂起。</p>
<p>​        接收数据和发送数据比较相似，总结如下：</p>
<p>​        首先，协议栈检查收到的数据块和TCP头部的内容，判断是否有数据丢失，没有则返回ACK号。然后，协议栈将数据块暂存到接收缓冲区中，并将数据块连接起来还原出原始书数据。最后交给应用程序。</p>
<h2 id="2-4-从服务器断开并删除套接字"><a href="#2-4-从服务器断开并删除套接字" class="headerlink" title="2.4 从服务器断开并删除套接字"></a>2.4 从服务器断开并删除套接字</h2><ul>
<li>双方都可以首先发起断开连接，下面以服务器乙方发起断开过程为例：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220403161826.png" style="zoom:80%;" /></p>
<p>​        第一，服务器方的应用程序会调用Socket库的close程序。然后协议栈登场，生成包含断开信息的TCP头部，也就是将控制位的FIN比特设置为1。接着，TPC模块委托IP模块向客户端发送数据，同时，服务器的套接字记录断开的相关信息。</p>
<p>​        第二，就是客户端，返回ACK号表明收到了上一个有断开信息的包。</p>
<p>​        第三，客户端调用close，之后的过程就和第一步一样了。</p>
<p>​        第四，同第二步。</p>
<ul>
<li>删除套接字：</li>
</ul>
<p>​        通信结束后，等待一段时间就删除套接字。之所以等待，是为了防止误操作。</p>
<ul>
<li>至此，整个连接、收发、断开过程如下：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220403162557.png" style="zoom:80%;" /></p>
<h2 id="2-5-IP-与以太网的包收发操作"><a href="#2-5-IP-与以太网的包收发操作" class="headerlink" title="2.5 IP 与以太网的包收发操作"></a>2.5 IP 与以太网的包收发操作</h2><ul>
<li>包的基本知识：</li>
</ul>
<p>​        网络包的结构：头部就相当于快递的快递单，数据就相当于快递的货物。</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220404105325.png" style="zoom:80%;" /></p>
<p>​        一个包发往目的地的过程：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220404105234.png" style="zoom:80%;" /></p>
<p>​        发送方和接收方统称为终端节点。</p>
<p>​        对于转发设备：1.路由器根据目标地址判断下一个路由器的位置 2.集线器在子网中将网络包传输到下一个路由。</p>
<p>​        实际上，集线器是按照以太网规则传输包的设备，而路由器是按照IP规则传输包的设备，因此：1. IP 协议根据目标地址判断下一个 IP 转发设备的位置  2. 子网中的以太网协议将包传输到下一个转发设备</p>
<p>​        TCP/IP包：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220404105605.png" style="zoom:80%;" /></p>
<p>其中，包含两个头部：MAC头部（用于以太网协议），IP头部（用于IP协议）。对于IP协议，发送方将包的目的地也就是要访问的服务器的IP地址写入IP头部，IP协议就可以根据这一地址查找包的传输方向，找到下一个路由器的位置。接下来，IP 协议会委托以太网协议将包传输过去。这时，IP 协议会查找下一个路由器的以太网地址（MAC 地址），并将这个地址写入 MAC 头部中。这样一来，以太网协议就知道要将这个包发到哪一个路由器上了。</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220404112933.png" style="zoom:80%;" /></p>
<ul>
<li>包收发操作的整体过程：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220404113743.png" style="zoom:80%;" /></p>
<ul>
<li>生成包含接收方 IP 地址的 IP 头部:</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220404114006.png" style="zoom:80%;" /></p>
<p>最重要的头部是IP地址，这是根据网卡来决定的。那么该如何判断应该把包交给哪块网卡呢？用路由表，具体在第三章再说。</p>
<ul>
<li>生成以太网用的 MAC 头部</li>
</ul>
<p>​        MAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC 地址等信息。</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220404114305.png" style="zoom:80%;" /></p>
<p>发送方的MAC地址是网卡生产时写入ROM里的，只要读出来即可。对于接收方的MAC地址，是根据接收方的IP地址查询到的。那么怎么查询呢？</p>
<ul>
<li>通过 ARP 查询目标路由器的 MAC 地址：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220404140305.png" style="zoom:80%;" /></p>
<p>​        广播：把包发送给连接在同一以太网中的所有设备。</p>
<p>​        ARP(Address Resolution Protocol，地址解析协议)就是利用广播，对所有设备提问：“×× 这个 IP 地址是谁的？请把你的 MAC 地址告诉我。”然后就会有人回答：“这个 IP 地址是我的，我的 MAC 地址是××××”。</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220404140123.png" style="zoom:80%;" /></p>
<p>​        同时设置MAC地址缓存，持续时间几分钟。</p>
<ul>
<li>以太网的基本知识：</li>
</ul>
<p>​        原型：谁都可以接收</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220404141125.png" style="zoom:80%;" /></p>
<p>​        改进后：还是谁都可以接收</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220404141316.png" style="zoom:80%;" /></p>
<p>​        再改进：只有特定设备可以接收</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220404141342.png" style="zoom:80%;" /></p>
<p>可以认为，具备以下三个性质的就是以太网：1. 将包发送到MAC头部的接收方MAC地址代表的目的地；2. 用发送方地址识别发送方；3. 用以太类型识别包的内容</p>
<ul>
<li>将 IP 包转换成电或光信号发送出去：</li>
</ul>
<p>​        最终到底是怎么把数据发出去的？需要将数字信息转换为光电信号，才能在网线上传输。</p>
<p>​        负责执行上述操作的就是网卡，而网卡必须要有网卡驱动程序来控制。网卡的概念结构如下图：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220404141835.png" style="zoom:80%;" /></p>
<p>网卡的 ROM 中保存着全世界唯一的 MAC 地址，这是在生产网卡时写入的。</p>
<p>网卡中保存的 MAC 地址会由网卡驱动程序读取并分配给 MAC模块。</p>
<p>在启动时，驱动程序初始化，在MAC模块中设置MAC地址，网卡就可以等待来自IP的委托了。</p>
<ul>
<li>如何将包转换成电信号并发送到网线中？</li>
</ul>
<p>首先，MAC 模块会将包从缓冲区中取出，并在开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列。</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220404142318.png" style="zoom:80%;" /></p>
<p>报头和起始帧分节符：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220404142823.png" style="zoom:80%;" /></p>
<p>报头是一串像 10101010…这样 1 和 0 交替出现的比特序列，长度为 56比特，它的作用是确定包的读取时机。起始帧分界符是一个用来表示包起始位置的标记。</p>
<p>末尾的 FCS（帧校验序列）用来检查包传输过程中因噪声导致的波形紊乱、数据错误，它是一串 32 比特的序列，是通过一个公式对包中从头到尾的所有内容进行计算而得出来的。</p>
<p>略去如何根据电信号读取数据…</p>
<ul>
<li>向集线器发送网络包</li>
</ul>
<p>加上报头、起始帧分界符和 FCS 之后，我们就可以将包用电信号通过网线发送出去了。使用网卡中的PHY(MAU)模块。</p>
<ul>
<li>接收返回包：</li>
</ul>
<p>首先，PHY（MAU）模块会将信号转换成通用格式并发送给 MAC 模块，MAC 模块再头开始将信号转换为数字信息，并存放到缓冲区中。当到达信号的末尾时，还需要检查 FCS。如果 FCS 校验没有问题，接下来就要看一下 MAC 头部中接收方MAC 地址与网卡在初始化时分配给自己的 MAC 地址是否一致，以判断这个包是不是发给自己的。接下来网卡会通知计算机收到了一个包。</p>
<p>网卡驱动程序发起中断，该中断被处理程序处理后，会从缓冲区取出收到的包。根据MAC头部中的以太类型判断协议栈的类型，然后发送给响应协议栈。</p>
<ul>
<li>将服务器的响应包从 IP 传递给 TCP</li>
</ul>
<p>现在来到了协议栈中，IP模块检查包的IP头部，确认格式，接着确定接收方IP地址是不是客户端网卡地址。如果一切没问题，IP模块处理分片的包，当属于同一个包的所有分片都到了，将其拼成完整的包然后交给TCP模块。</p>
<p>TCP模块根据TCP头部信息来查找对应的套接字，找到对应的套接字之后，就可以根据套接字中记录的通信状态，执行相应的操作了。例如，如果包的内容是应用程序数据，则返回确认接收的包，并将数据放入缓冲区，等待应用程序来读取；如果是建立或断开连接的控制包，则返回相应的响应控制包，并告知应用程序建立和断开连接的操作状态。</p>
<h2 id="2-6-UDP-协议的收发操作"><a href="#2-6-UDP-协议的收发操作" class="headerlink" title="2.6 UDP 协议的收发操作"></a>2.6 UDP 协议的收发操作</h2><ul>
<li><p>不需要重发的数据用 UDP 发送更高效</p>
</li>
<li><p>控制用的短数据</p>
</li>
<li><p>音频和视频数据</p>
</li>
</ul>
<p>以上情况比较适合用UDP协议来发送。</p>
]]></content>
      <categories>
        <category>Network</category>
        <category>网络是怎样连接的</category>
      </categories>
      <tags>
        <tag>Network</tag>
        <tag>网络是怎样连接的</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-1.基本概念</title>
    <url>/2022/11/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<h1 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h1><ul>
<li><p><strong>ISP</strong> (Internet Service Provider)：因特网服务提供者，国内如中国电信、中国移动、中国联通。</p>
</li>
<li><p>因特网的组成：</p>
<ul>
<li>边缘部分：用户的主机</li>
<li>核心部分：大量网络和路由器</li>
</ul>
</li>
<li><p>三种交换方式：</p>
<ul>
<li>电话交换</li>
<li>分组交换（使用这种）</li>
<li>报文交换</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220413194532.png" style="zoom:80%;" /><br><span id="more"></span></p>
<ul>
<li>计算机网络定义（无标准）：一些<strong>互联</strong>、<strong>自治</strong>的计算机的<strong>集合</strong>。</li>
<li>计网的分类：</li>
</ul>
<p>按交换技术分类：电路交换网络、报文交换网络、分组交换网络；</p>
<p>按使用者分类：公用网、专用网；</p>
<p>按传输介质分类：有线网络、无线网络；</p>
<p>按覆盖范围分类：广域网WAN、城域网MAN、局域网LAN、个域网PAN；</p>
<p>按拓扑结构分类：总线型网络、星型网络、环形网络、网状型网络；</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220413195006.png" style="zoom:80%;" /></p>
<ul>
<li><p>常见的性能指标：</p>
<ul>
<li>速率：传送比特的速率，常用单位比特每秒等。</li>
<li>带宽：单位时间内从网络的某一点到另一点所能通过的最高数据率。</li>
<li>吞吐量：单位时间内通过某个网络（或信道、接口）的数据量。</li>
<li>时延：<ul>
<li>发送时延：分组长度/发送速率</li>
<li>传播时延：信道长度/电磁波传播速率</li>
<li>处理时延：一般不方便计算，忽略</li>
</ul>
</li>
<li>时延带宽积：传播时延*带宽，若发送端连续发送数据，则在所发送的第一个比特到达终点时，发送端就已经发送了时延带宽积个比特。</li>
<li>往返时间：Round-Trip Time，RTT</li>
<li>利用率：<ul>
<li>信道利用率：某信道有百分之几的时间是被利用的。</li>
<li>网络利用率：全网络的信道利用率的加权平均。</li>
<li>信道利用率并非越高越好，越高则时延越大。</li>
</ul>
</li>
<li>丢包率：在一定时间范围内，传输过程中丢失的分组数量与总分组数量的比率。<ul>
<li>分组在传输过程中出现误码，被结点丢弃。</li>
<li>分组到达一台队列已满的分组交换机时被丢弃。</li>
</ul>
</li>
</ul>
</li>
<li><p>计算机网络体系结构：</p>
<ul>
<li>常见的计算机网络体系结构：</li>
</ul>
<p>OSI体系结构、TCP/IP体系结构与原理体系结构：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220416185253.png" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220416185337.png" style="zoom:80%;" /></p>
<ul>
<li>分层的必要性：</li>
</ul>
<p>分层可将复杂问题转为较小的局部问题，方便处理和研究。各层解决的问题如下：</p>
<p><strong>物理层</strong>：1.采用怎样的传输媒体（介质）2.采用怎样的物理接口 3.使用怎样的信号表示比特0和1</p>
<p><strong>数据链路层</strong>：1.如何标识网络中各主机（主机编制问题，例如MAC地址）2.如何从信号所表示的一连串比特流中区分出地址和数据 3.如何协调各主机征用总线</p>
<p><strong>网络层</strong>：1.如何标识各网络以及各网络中的各主机（网络和主机共同编址的问题，例如IP地址）2.路由器如何转发分组，如何进行路由器选择</p>
<p><strong>运输层</strong>：1.如何解决进程之间基于网络的通信问题 2.出现传输错误时，如何处理</p>
<p><strong>应用层</strong>：通过应用进程之间的交互来完成特定的网络应用。</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220416190042.png" style="zoom:80%;" /></p>
<ul>
<li><p>专用术语：</p>
<p>实体：任何可发送或接受信息的硬件或软件进程</p>
<p>对等实体：收发双发相同层次中的实体</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220416190323.png" style="zoom:80%;" /></p>
<p>协议：控制两个对等实体进行逻辑通信的规则的集合。</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220416190402.png" style="zoom:80%;" /></p>
<p>协议三要素：语法、语义、同步</p>
<p>语法定义交换信息的格式；语义定义收发双方所要完成的操作；同步定义收发双方的时序关系。</p>
<p>服务：在协议的控制下，两个对等实体间的逻辑通信使得本层能够向上一层提供服务；要实现本层协议，还需要使用下一层所提供的服务。</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220416190702.png" style="zoom:80%;" /></p>
</li>
</ul>
<p>协议数据单元PDU：对等层次之间传送的数据包</p>
<p>服务数据单元SDU：同一系统内，层与层之间交换的数据包</p>
<p>多个SDU可合成一个PDU，一个SDU也可划分几个PDU。</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220416190918.png" alt=""></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Network</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>Network</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-2.物理层</title>
    <url>/2022/11/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-2-%E7%89%A9%E7%90%86%E5%B1%82/</url>
    <content><![CDATA[<h1 id="2-物理层"><a href="#2-物理层" class="headerlink" title="2.物理层"></a>2.物理层</h1><h2 id="2-1-基本概念"><a href="#2-1-基本概念" class="headerlink" title="2.1 基本概念"></a>2.1 基本概念</h2><ul>
<li>传输媒体：</li>
</ul>
<p><strong>导引型传输媒体</strong>：双绞线、同轴电缆、光纤</p>
<p><strong>非导引型传输媒体</strong>：微波通信（2~40GHz）</p>
<ul>
<li>物理层协议的主要任务：</li>
</ul>
<p><strong>机械特性</strong>：指明接口所用接线器的形状和尺寸、引脚数目和排列、固定和锁定装置。</p>
<p><strong>电气特性</strong>：指明在接口电缆的各条线上出现的电压范围。</p>
<p><strong>功能特性</strong>：指明某条线上出现的某一电平的电压表示何种意义。</p>
<p><strong>过程特性</strong>：指明对于不同功能的各种可能事件的出现顺序。</p>
<ul>
<li>物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流。</li>
<li>物理层为数据链路层屏蔽了各种传输媒体的差异，使数据链路层只需要考虑如何完成本层的协议和服务，而不必考虑网络传输的传输媒体是什么。<span id="more"></span>
</li>
</ul>
<h2 id="2-2-物理层下面的传输媒体"><a href="#2-2-物理层下面的传输媒体" class="headerlink" title="2.2 物理层下面的传输媒体"></a>2.2 物理层下面的传输媒体</h2><ul>
<li>导引型传输媒体：同轴电缆、双绞线、光纤、电力线</li>
<li>非导引型传输媒体：无线电波、微波、红外线、可见光</li>
</ul>
<h2 id="2-3-传输方式"><a href="#2-3-传输方式" class="headerlink" title="2.3 传输方式"></a>2.3 传输方式</h2><ul>
<li>串行传输与并行传输：</li>
</ul>
<p>串行速度慢，价格低，适用于长距离传输；</p>
<p>并行速度快，价格贵，适用于短距离传输。</p>
<ul>
<li>同步传输与异步传输：</li>
</ul>
<p>同步传输字节连续发送；</p>
<p>异步传输字节分开发送。</p>
<ul>
<li>单工、半双工、全双工：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220419152224.png" style="zoom:80%;" /></p>
<h2 id="2-4-编码与调制"><a href="#2-4-编码与调制" class="headerlink" title="2.4 编码与调制"></a>2.4 编码与调制</h2><ul>
<li>编码：将信号转为数字信号。</li>
<li>调制：将信号转为模拟信号。</li>
<li>码元：在使用时间域的波形表示数字信号时，代表不同离散数值的基本波形。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220419152541.png" alt=""></p>
<ul>
<li>常用编码：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220419152701.png" style="zoom:80%;" /></p>
<ul>
<li>基本调制方法：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220419152940.png" style="zoom:80%;" /></p>
<h2 id="2-5-信道的极限容量"><a href="#2-5-信道的极限容量" class="headerlink" title="2.5 信道的极限容量"></a>2.5 信道的极限容量</h2><ul>
<li>信号失真严重时，无法识别原信号。</li>
<li>失真因素：码元传输速率、信号传输距离、噪声干扰、传输媒体质量。</li>
<li>奈氏准则：在理想情况下，为了避免码间串扰，码元的传输速率是有上限的。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220419153410.png" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220419153422.png" style="zoom:80%;" /></p>
<ul>
<li>香农公式：带宽受限且有高斯白噪声干扰的信道的极限信息传输速率。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220419153446.png" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220419153500.png" style="zoom:80%;" /></p>
]]></content>
      <categories>
        <category>Network</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>Network</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-4. 网络层</title>
    <url>/2022/11/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-4-%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
    <content><![CDATA[<h1 id="4-网络层"><a href="#4-网络层" class="headerlink" title="4. 网络层"></a>4. 网络层</h1><h2 id="4-1-概述"><a href="#4-1-概述" class="headerlink" title="4.1 概述"></a>4.1 概述</h2><ul>
<li>主要任务：实现网络互连，进而实现数据包在各网络之间的传输。</li>
<li>需要解决的问题：<ul>
<li>网络层向运输层提供怎样的服务（可靠传输还是不可靠传输）。</li>
<li>网络层寻址问题。</li>
<li>路由器选择问题。<span id="more"></span>
</li>
</ul>
</li>
</ul>
<h2 id="4-2-网络层提供的两种服务"><a href="#4-2-网络层提供的两种服务" class="headerlink" title="4.2 网络层提供的两种服务"></a>4.2 网络层提供的两种服务</h2><h3 id="4-2-1-面向连接的虚电路服务"><a href="#4-2-1-面向连接的虚电路服务" class="headerlink" title="4.2.1 面向连接的虚电路服务"></a>4.2.1 面向连接的虚电路服务</h3><ul>
<li>可靠通信由网络来保证。</li>
<li>必须建立网络层的连接—虚电路VC。</li>
<li>通信双方沿着已建立的虚电路发送分组。</li>
<li>目的主机的地址仅在连接建立阶段使用，之后每个分组的首部只需携带一条电路的编号。</li>
<li><p>这种通信方式如果在使用可靠传输的网络协议，就可使所发送的分组最终达到接收方。</p>
</li>
<li><p>通信结束后，需要释放之前所建立的虚电路。</p>
</li>
<li>很多广域分组交换网都是用面向连接的虚电路服务。</li>
</ul>
<h3 id="4-2-2-无连接的数据报服务"><a href="#4-2-2-无连接的数据报服务" class="headerlink" title="4.2.2 无连接的数据报服务"></a>4.2.2 无连接的数据报服务</h3><ul>
<li>可靠通信应当由主机来保证</li>
<li>不需要建立网络层连接</li>
<li>每个分组可走不同的路径</li>
<li>每个分组的首部必须携带目的主机的完整地址</li>
<li>这种通信方式所传送的分组可能误码、丢失、重复和失序</li>
<li>由于网络本身不提供端到端的可靠传输服务，这就使网络中的路由器可以做的比较简单，而且价格低廉。</li>
<li>因特网采用了这种设计思想，将复杂的网络处理功能置于因特网的边缘（用户主机和其内部的运输层），而将相对简单的尽最大努力的分组交付功能置于因特网核心。</li>
</ul>
<h2 id="4-3-IPv4地址"><a href="#4-3-IPv4地址" class="headerlink" title="4.3 IPv4地址"></a>4.3 IPv4地址</h2><h3 id="4-3-1-概述"><a href="#4-3-1-概述" class="headerlink" title="4.3.1 概述"></a>4.3.1 概述</h3><ul>
<li>IPv4地址就是因特网上的每一台主机（或路由器）的每一个接口分配一个在全世界范围内唯一的32比特的标识符。</li>
<li>IPv4地址的编制方法经历了如下三个阶段：分类编址、划分子网、无分类编制。</li>
<li>32比特的IPv4地址不方便阅读、记录以及输入，因此采用点分十进制表示方法以便用户使用：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220427151556.png" style="zoom:80%;" /></p>
<h3 id="4-3-2-分类编制的IPv4地址"><a href="#4-3-2-分类编制的IPv4地址" class="headerlink" title="4.3.2 分类编制的IPv4地址"></a>4.3.2 分类编制的IPv4地址</h3><ul>
<li>一共分为A、B、C、D、E共五类：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220427151719.png" style="zoom:80%;" /></p>
<p>根据左起的第一个十进制数的值，可以判断出网络类别：小于127的为A类，128~191的为B类，192-223的为C类。</p>
<p>只有A、B、C类地址可分配给网络中的主机或路由器的各接口。</p>
<p>主机号为全0的地址是网络地址不能分配给主机或路由器的各接口；主机号为全1的地址是广播地址，不能分配给主机或路由器的各接口。</p>
<ul>
<li>A类地址：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220427152312.png" style="zoom:80%;" /></p>
<ul>
<li>B类地址：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220427153322.png" style="zoom:80%;" /></p>
<ul>
<li>C类地址：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220427153417.png" style="zoom:80%;" /></p>
<h3 id="4-3-3-划分子网的IPv4地址"><a href="#4-3-3-划分子网的IPv4地址" class="headerlink" title="4.3.3 划分子网的IPv4地址"></a>4.3.3 划分子网的IPv4地址</h3><ul>
<li>32位的子网掩码可以表明分类IP地址的<strong>主机号部分</strong>被借用了几个比特作为子网号：</li>
</ul>
<p>子网掩码使用连续的比特1来对应网络号和子网号；使用连续的比特0来对应主机号；</p>
<p>将划分子网的IPv4地址与其相应的子网掩码进行逻辑与运算就可得到IPv4地址所在子网的网络地址。</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220427153740.png" style="zoom:80%;" /></p>
<p>举个栗子：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220427154103.png" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220427154132.png" style="zoom:80%;" /></p>
<ul>
<li>默认子网掩码：指未划分子网的情况下使用的子网掩码。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220427154512.png" style="zoom:80%;" /></p>
<h3 id="4-3-4-无分类编制的IPv4地址"><a href="#4-3-4-无分类编制的IPv4地址" class="headerlink" title="4.3.4 无分类编制的IPv4地址"></a>4.3.4 无分类编制的IPv4地址</h3><ul>
<li>划分子网在一定程度上缓解了因特网在发展中遇到的困难，但是数量巨大的C类网因为其地址空间大小并没有得到充分使用，而因特网的 IP地址仍在加速消耗，整个IPv4地址面临全部耗尽的威胁。因此因特网工程任务组IETF提出采用<strong>无分类编制</strong>的方法来解决IP地址紧张的问题，同时还专门成立IPv6工作组研究新版本IP以彻底解决地址耗尽问题。</li>
<li>无分类域间路由选择CIDR（Classless Inter-Domain Routing），消除了传统的A、B、C类地址以及划分子网的概念，使用斜线记法，或称CIDR记法。在IPv4地址后面加上斜线“/”，在斜线后面写上网络前缀所占的比特数量。实际上，将网络前缀都相同的连续IP地址组成一个CIDR地址块。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220428092028.png" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220428093200.png" style="zoom:80%;" /></p>
<ul>
<li>路由聚合（构造超网） </li>
</ul>
<p>可将路由表中多条记录合成一条：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220428093419.png" style="zoom:80%;" /></p>
<p>网络前缀越长，地址块越小，路由越具体。</p>
<h2 id="4-4-IP数据报的发送和转发过程"><a href="#4-4-IP数据报的发送和转发过程" class="headerlink" title="4.4 IP数据报的发送和转发过程"></a>4.4 IP数据报的发送和转发过程</h2><ul>
<li>主要包含两个部分：1.主机发送IP数据报 2.路由器转IP数据报</li>
<li>主机发送IP数据报：</li>
</ul>
<p>判断目的主机是否与自己在同一个网络，若在同一个网络，属于直接交付；若不在同一个网络，则属于间接交付，传输主机所在网络的默认网关（路由器），由默认网关帮忙转发。</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220428151612.png" style="zoom:80%;" /></p>
<ul>
<li>路由器转发IP数据报：</li>
</ul>
<p>检查IP数据报首部是否出错，若出错则直接丢弃该IP数据报并通告源主机；若没有出错，则进行转发。</p>
<p>根据IP数据报的目的地址在路由表中查找匹配的条目，若找到匹配的条目，则转发给条目中指示的吓一跳；若找不到，则丢弃该IP数据报并通告源主机。</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220428151923.png" style="zoom:80%;" /></p>
<h2 id="4-6-路由选择协议"><a href="#4-6-路由选择协议" class="headerlink" title="4.6 路由选择协议"></a>4.6 路由选择协议</h2><ul>
<li>分为两类：静态路由选择和动态路由选择。</li>
<li>静态路由选择：由人工配置的网络路由、默认路由、特定主机路由、黑洞路由等都属于静态路由；配置方式简单、开销小，但不能及时适应网络状态的变化；一般只在小规模网络中使用。</li>
<li>动态路由选择：路由器通过路由选择协议自动获取路由信息；比较复杂、开销比较大，能较好地适应网络状态的变化；适用于大规模网络。</li>
<li>因特网所采用的路由选择协议的主要特点：</li>
</ul>
<p>自适应：动态路由选择，能较好地适应网络状态的变化；</p>
<p>分布式：路由器之间交换路由信息；</p>
<p>分层次：将整个因特网划分为许多较小的自治系统AS（Autonomous System）。</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220428152501.png" style="zoom:80%;" /></p>
<ul>
<li>路由器的基本结构：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220428152604.png" style="zoom:80%;" /></p>
<h2 id="4-7-IPv4数据报的首部格式"><a href="#4-7-IPv4数据报的首部格式" class="headerlink" title="4.7 IPv4数据报的首部格式"></a>4.7 IPv4数据报的首部格式</h2><p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220430161615.png" style="zoom:80%;" /></p>
<h2 id="4-8-网际控制保温协议ICMP"><a href="#4-8-网际控制保温协议ICMP" class="headerlink" title="4.8 网际控制保温协议ICMP"></a>4.8 网际控制保温协议ICMP</h2><ul>
<li>网际层的一个协议，目的是为了更有效地转发IP数据报和提高交付成功的机会。</li>
<li>ICMP应用：分组网间探测PING、跟踪路由traceroute。</li>
</ul>
<h2 id="4-9-虚拟专用网VPN与网络地址转换NAT"><a href="#4-9-虚拟专用网VPN与网络地址转换NAT" class="headerlink" title="4.9 虚拟专用网VPN与网络地址转换NAT"></a>4.9 虚拟专用网VPN与网络地址转换NAT</h2><h3 id="4-9-1-虚拟专用网VPN（Virtual-Private-Network）"><a href="#4-9-1-虚拟专用网VPN（Virtual-Private-Network）" class="headerlink" title="4.9.1  虚拟专用网VPN（Virtual Private Network）"></a>4.9.1  虚拟专用网VPN（Virtual Private Network）</h3><ul>
<li>利用公用的因特网作为本机构各专用网之间的通信载体，这样的专用网又称为虚拟专用网。</li>
</ul>
<p>专用（私有）地址：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220430162726.png" style="zoom:80%;" /></p>
<p>给一个内部网络中的主机分配专用地址，然后让该内部网络接入一个使用公用因特网地址的路由器，这样内部网络之间就可以通过使用公用因特网地址的路由器进行通信。</p>
<h3 id="4-9-2-网络地址转换NAT（Network-Address-Translation）"><a href="#4-9-2-网络地址转换NAT（Network-Address-Translation）" class="headerlink" title="4.9.2 网络地址转换NAT（Network Address Translation）"></a>4.9.2 网络地址转换NAT（Network Address Translation）</h3><p>对于VPN，给一个内部网络的专用地址，如何翻译成公用的因特网地址？</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220430163123.png" style="zoom:80%;" /></p>
]]></content>
      <categories>
        <category>Network</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>Network</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-3.数据链路层</title>
    <url>/2022/11/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-3-%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
    <content><![CDATA[<h1 id="3-数据链路层"><a href="#3-数据链路层" class="headerlink" title="3.数据链路层"></a>3.数据链路层</h1><h2 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h2><ul>
<li>链路：从一个结点到相邻结点的一段物理线路，而中间没有任何其他的交换结点。</li>
<li>数据链路：把实现通信协议的硬件和软件加到链路上。</li>
<li>数据链路层以帧为单位传输和处理数据。</li>
<li>数据链路层要解决的三个问题：封装成帧、差错检测、可靠传输。</li>
</ul>
<span id="more"></span>
<h2 id="3-2-封装成帧"><a href="#3-2-封装成帧" class="headerlink" title="3.2 封装成帧"></a>3.2 封装成帧</h2><ul>
<li>封装成帧：将上层交付的协议数据单元添加帧头和帧尾使之成为帧。其中帧头和帧尾包含有重要的控制信息，作用之一是帧定界。</li>
<li>透明传输是指数据链路层对上层交付的传输数据没有任何限制，就好像数据链路层不存在一样。</li>
</ul>
<p>面向字节的物理链路使用字节填充法实现透明传输；面向比特的物理链路使用比特填充的方法实现透明传输。</p>
<ul>
<li>为了提高帧的传输效率，应当使帧的数据部分尽可能大些。</li>
<li>每一种数据链路层协议都规定了帧的数据部分的长度上限，即最大传送单元MTU（Maximum Transfer Unit）。</li>
</ul>
<h2 id="3-3-差错检测"><a href="#3-3-差错检测" class="headerlink" title="3.3 差错检测"></a>3.3 差错检测</h2><ul>
<li>比特在传输过程中可能会产生差错，1变成0，0变成1，这称为比特差错。</li>
<li>奇偶校验：在待发送的数据后面添加1位奇偶校验位，使整个数据中1的个数为奇数或偶数。有奇数个位发生误码，可以检查出误码；偶数个位发生误码，检查不出误码。</li>
<li>循环冗余校验CRC（Cyclic Redundancy Check）：收发双方预定好一个生成多项式，发送方基于发送数据和生成多项式计算出差错检测码，将其添加到待传输的数据后面一起传输；接收方通过生成多项式来计算收到的而数据是否产生了误码。</li>
<li>检错码只能检测出是否出现差错并不能定位差错，因此无法纠正错误。</li>
</ul>
<h2 id="3-4-可靠传输"><a href="#3-4-可靠传输" class="headerlink" title="3.4 可靠传输"></a>3.4 可靠传输</h2><h3 id="3-4-1-基本概念"><a href="#3-4-1-基本概念" class="headerlink" title="3.4.1 基本概念"></a>3.4.1 基本概念</h3><ul>
<li>不可靠传输：仅仅丢弃有误码的帧。</li>
<li><p>可靠传输：想办法实现发送端发送什么，接收端就收到什么。</p>
</li>
<li><p>一般情况有线链路误码率较低，无须实现可靠传输；无线链路误码率高，必须实现可靠传输。</p>
</li>
<li>传输差错：比特差错、分组丢失、分组失序、分组重复。</li>
<li>可靠传输并不仅局限于数据链路层，其他各层均可选择实现可靠传输。</li>
</ul>
<h3 id="3-4-2-停止-等待协议SW（Stop-and-Wait）"><a href="#3-4-2-停止-等待协议SW（Stop-and-Wait）" class="headerlink" title="3.4.2 停止-等待协议SW（Stop-and-Wait）"></a>3.4.2 停止-等待协议SW（Stop-and-Wait）</h3><p>思想很简单，发送端收到接收端发来的上一帧确认信号才可以发送下一帧，并且加入了超时重传机制。</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220423184250.png" alt=""></p>
<h3 id="3-4-3-回退N帧协议GBN（Go-Back-N）"><a href="#3-4-3-回退N帧协议GBN（Go-Back-N）" class="headerlink" title="3.4.3 回退N帧协议GBN（Go-Back-N）"></a>3.4.3 回退N帧协议GBN（Go-Back-N）</h3><p>设置一个窗口，在窗口内的分组可以发送通过流水线的方式发送出去。接收方的通过一个窗口大小为1的接收窗口来接收。接收方每接收一个分组就向发送方发回一个对应分组的ACK。只有当发送窗口内所有分组的ACK都接收到，发送窗口才可以向前滑动。</p>
<h3 id="3-4-4-选择重传协议SR（Selective-Request）"><a href="#3-4-4-选择重传协议SR（Selective-Request）" class="headerlink" title="3.4.4 选择重传协议SR（Selective Request）"></a>3.4.4 选择重传协议SR（Selective Request）</h3><p>和回退N帧类似，但是接收方的接收窗口可以大于1。</p>
<h2 id="3-5-点对点协议PPP"><a href="#3-5-点对点协议PPP" class="headerlink" title="3.5 点对点协议PPP"></a>3.5 点对点协议PPP</h2><ul>
<li>主要由三部分组成：1.对各种协议数据报的封装方法（封装成帧）2.链路控制协议LCP，用于建立、配置以及测试数据链路的连接。 3.一套网络控制协议NCPS，其中的么额欸一个协议支持不同的网络层协议。</li>
</ul>
<h2 id="3-6-媒体接入控制-Media-Access-Control（MAC）"><a href="#3-6-媒体接入控制-Media-Access-Control（MAC）" class="headerlink" title="3.6 媒体接入控制 Media Access Control（MAC）"></a>3.6 媒体接入控制 Media Access Control（MAC）</h2><h3 id="3-6-1-基本概念"><a href="#3-6-1-基本概念" class="headerlink" title="3.6.1 基本概念"></a>3.6.1 基本概念</h3><ul>
<li>共享信道要考虑的一个问题就是如何协调多个发送和接收站点对一个共享传输媒体的占用，即媒体接入控制。</li>
<li>MAC分为两种：<ul>
<li>静态划分信道：频分多址、时分多址、码分多址</li>
<li>动态接入控制：<del>受控接入（已淘汰）</del>、随机接入</li>
</ul>
</li>
</ul>
<h3 id="3-6-2-静态划分信道"><a href="#3-6-2-静态划分信道" class="headerlink" title="3.6.2 静态划分信道"></a>3.6.2 静态划分信道</h3><ul>
<li>频分复用FDM：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220424140604.png" style="zoom:80%;" /></p>
<ul>
<li>时分复用TDM：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220424140630.png" style="zoom:80%;" /></p>
<ul>
<li>波分复用WDM：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220424140708.png" style="zoom:80%;" /></p>
<ul>
<li>码分复用CDM：</li>
</ul>
<p>每一个比特时间再划分为m个短的间隔，称为码片（Chip）。通常m取64或128，简单起见我们m取8。</p>
<p>一个站如果要发送比特1，则发送它自己的m bit码片序列；一个站如果要发送比特00，则发送他自己的m bit码片序列的二进制反码。</p>
<p>分配给每个站的码片序列必须各不相同；分配给每个站的码片序列必须相互正交（规格化内积为0）。</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220424143219.png" style="zoom:80%;" /></p>
<h3 id="3-6-3-动态接入控制-随机接入"><a href="#3-6-3-动态接入控制-随机接入" class="headerlink" title="3.6.3 动态接入控制-随机接入"></a>3.6.3 动态接入控制-随机接入</h3><ul>
<li>要解决的问题是在信道复用时， 信道上发送信息冲突的问题。</li>
<li>载波监听多址接入/碰撞检测 CSMA/CD（Carrier Sense Multiple Access/Collidion Detection）</li>
</ul>
<p>多址接入MA：多个站连接在一条总线上，竞争使用总线。</p>
<p>载波监听CS：每一个站在发送帧之前要检测一下总线上是否有其他站点在发送帧。</p>
<p>碰撞检测CD：每一个正在发送帧的站边发送边检测碰撞。</p>
<ul>
<li>载波监听多址接入/碰撞避免 CSMA/CA（Carrier Sense Multiple Access/Collidion Avoidance），一般用于无线局域网。</li>
</ul>
<h2 id="3-7-MAC地址、IP地址以及ARP协议"><a href="#3-7-MAC地址、IP地址以及ARP协议" class="headerlink" title="3.7 MAC地址、IP地址以及ARP协议"></a>3.7 MAC地址、IP地址以及ARP协议</h2><h3 id="3-7-1-MAC地址"><a href="#3-7-1-MAC地址" class="headerlink" title="3.7.1 MAC地址"></a>3.7.1 MAC地址</h3><ul>
<li>属于数据链路层的地址，当多个主机连接在同一个广播信道上，要想实现两个主机之间对的通信，则每个主机必须有一个唯一标识，即一个数据链路层地址。</li>
<li>在每个主机发送的帧中必须携带标识发送主机和接收主机的地址，由于这类地址是用于媒体接入控制MAC，因此这类地址被称为MAC地址。也称硬件地址，一般被固化在网卡中。</li>
<li>严格来说，MAC地址是对网络上个接口的唯一标识，而不是对网络上各设备的唯一标识。</li>
<li>IEEE 802局域网的MAC地址格式：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220425142818.png" style="zoom:80%;" /></p>
<h3 id="3-7-1-IP地址"><a href="#3-7-1-IP地址" class="headerlink" title="3.7.1 IP地址"></a>3.7.1 IP地址</h3><ul>
<li>IP地址属于络层的地址，是因特网上的主机和路由器所使用的地址，用于标识两部分信息：1.网络编号，标识因特网上数以百万计的网络。2.主机编号，标识同一网络上的不同主机（或路由器各接口）。</li>
<li>IP地址和MAC地址的区别？</li>
</ul>
<p>1.IP地址和MAC地址都可以区分设备，但是MAC地址不具备区分各网络的功能，而IP地址可以。</p>
<p>2.数据包转发过程中源IP地址和目的IP地址保持不变；而源MAC地址和目的MAC地址逐个链路或逐个网络改变。</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220425143310.png" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220425143328.png" style="zoom:80%;" /></p>
<p>​                                                 </p>
<h3 id="3-7-3-ARP协议"><a href="#3-7-3-ARP协议" class="headerlink" title="3.7.3 ARP协议"></a>3.7.3 ARP协议</h3><ul>
<li>ARP协议用于解决知道IP地址，如何求出MAC地址的问题。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220425143517.png" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220425143550.png" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220425143605.png" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220425143632.png" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220425143657.png" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220425143718.png" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220425143735.png" style="zoom:80%;" /></p>
<h2 id="3-8-集线器与交换机"><a href="#3-8-集线器与交换机" class="headerlink" title="3.8 集线器与交换机"></a>3.8 集线器与交换机</h2><h3 id="3-8-1-集线器"><a href="#3-8-1-集线器" class="headerlink" title="3.8.1 集线器"></a>3.8.1 集线器</h3><ul>
<li>使用集线器的以太网在逻辑上仍是一个总线网，各站共享总线资源，使用的还是CSMA/CD协议；并且只工作在物理层；一般有少量的容错能力和网络管理能力。</li>
</ul>
<p>使用双绞线和集线器HUB的星型以太网：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220425144035.png" style="zoom:80%;" /></p>
<p>使用集线器HUB在物理层扩展以太网：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220425144143.png" style="zoom:80%;" /></p>
<h3 id="3-8-2-以太网交换机"><a href="#3-8-2-以太网交换机" class="headerlink" title="3.8.2 以太网交换机"></a>3.8.2 以太网交换机</h3><ul>
<li>和集线器的区别在于，集线器给所有设备发送信息，交换机只给目标地址发送信息。交换机比集线器的优势很大，因此集线器基本被淘汰了。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220425144600.png" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220425144617.png" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220425144630.png" style="zoom:80%;" /></p>
<p>以太网交换机通常有多个接口，每个接口可直接与一台主机或另一个以太网交换机相连，一般以全双工方式工作。</p>
<p>具有并行性，能同时连通多对接口，使多对主机能同时通信，无碰撞（不适用CSMA/CD协议）。</p>
<p>工作在数据链路层（也包括物理层），它收到帧后，在帧交换表中查找目的MAC地址所对应的接口号，然后通过该接口转发帧。</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220425144734.png" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220425144748.png" style="zoom:80%;" /></p>
<h2 id="3-9-以太网交换机自学习和转发帧的流程"><a href="#3-9-以太网交换机自学习和转发帧的流程" class="headerlink" title="3.9 以太网交换机自学习和转发帧的流程"></a>3.9 以太网交换机自学习和转发帧的流程</h2><ul>
<li>以太网交换机工作在数据链路层（也包括物理层）。</li>
<li>以太网交换机收到帧后，在帧交换表中查找帧的目的MAC地址所对应的接口号，然后通过该接口转发帧。</li>
<li>以太网交换机是一种即插即用设备，刚上电启动时其内部的帧交换表是空的。随着网络中各主机间的通信，以太网交换机通过自学习算法逐渐建立起帧交换表。</li>
<li>帧交换表中的每条记录都有自己的有效时间，到期自动删除，这是因为MAC地址与交换机接口的对应关系并不是永久性的。比如交换机的接口改接了另一台主机或者主机更换了网卡。</li>
</ul>
<h2 id="3-10-以太网交换机的生成树协议STP"><a href="#3-10-以太网交换机的生成树协议STP" class="headerlink" title="3.10 以太网交换机的生成树协议STP"></a>3.10 以太网交换机的生成树协议STP</h2><ul>
<li>本节讲的是如何提高以太网的可靠性。</li>
<li>通过添加冗余链路可以提高以太网的可靠性，但是同时带来了问题—形成了网络环路。网络环路会带来以下问题：广播风暴、主机收到重复的广播帧、交换机的帧交换表震荡（漂移）。</li>
<li>因此，使用以太网交换机的生成树协议STP可以既增加冗余链路又避免网络环路。</li>
</ul>
<h2 id="3-11-虚拟局域网VLAN"><a href="#3-11-虚拟局域网VLAN" class="headerlink" title="3.11 虚拟局域网VLAN"></a>3.11 虚拟局域网VLAN</h2><h3 id="3-11-1-概述"><a href="#3-11-1-概述" class="headerlink" title="3.11.1 概述"></a>3.11.1 概述</h3><ul>
<li>当广播域过大时会带来很多问题，比如广播风暴、难以管理和维护以及潜在的安全问题。因此需要分割广播域。</li>
<li>分割广播域的方法：</li>
</ul>
<p>使用路由器可以隔离广播域，但是路由器的成本较高。</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220426143947.png" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220426144004.png" style="zoom:80%;" /></p>
<p>使用虚拟局域网VLAN（Virtual Local Area Networl）技术也可以分割广播域。VLAN将局域网内的设备分成与物理位置无关的逻辑组，这些逻辑组有某些共同的需求。</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220426144211.png" style="zoom:80%;" /></p>
<h3 id="3-11-2-实现机制"><a href="#3-11-2-实现机制" class="headerlink" title="3.11.2 实现机制"></a>3.11.2 实现机制</h3><ul>
<li>IEEE 802.1Q帧（也称Dot One Q帧）</li>
</ul>
<p>通过对以太网的MAC帧格式进行扩展，加入4字节的VLAN标记：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220426144344.png" style="zoom:80%;" /></p>
<p>当交换机收到普通的以太网帧时，会将其插入4字节的VLAN标记转变成802.1Q帧，称为“打标签”；</p>
<p>当交换机转发802.1Q帧时，<strong>可能</strong>会删除其4字节的VLAN标记转变为普通以太网帧，称为“去标签”。</p>
<ul>
<li>交换机的端口类型：Access、Trunk、Hybrid</li>
</ul>
<p>Access端口一般用于连接用户计算机，并且只能属于一个VLAN。</p>
<p>Trunk端口一般用于交换机之间或交换机与路由器之间的互联，可以属于多个VLAN。</p>
<p>Hybrid端口既可用于交换机之间或交换机与路由器之间的互联（同Trunk），也可用于交换机与用户计算机之间的互联（同Access），可以属于多个VLAN。</p>
]]></content>
      <categories>
        <category>Network</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>Network</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-5.运输层</title>
    <url>/2022/11/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-5-%E8%BF%90%E8%BE%93%E5%B1%82/</url>
    <content><![CDATA[<h1 id="5-运输层"><a href="#5-运输层" class="headerlink" title="5.运输层"></a>5.运输层</h1><h2 id="5-1-概述"><a href="#5-1-概述" class="headerlink" title="5.1 概述"></a>5.1 概述</h2><ul>
<li>之前的物理层、数据链路层以及网络层它们共同解决了主机通过异构网络互联所面临的问题，实现了主机到主机的通信。但实际上计算机网络中的通信时位于通信两段主机中的进程。</li>
<li><p>运输层任务：为运行在不同主机上的应用进程提供直接的通信服务。运输层协议又称端到端协议。</p>
</li>
<li><p>因特网的运输层为应用层提供了两种不同的运输协议，即面向连接的TCP和无连接的UDP。</p>
<span id="more"></span>
</li>
</ul>
<h2 id="5-2-端口号、复用与分用"><a href="#5-2-端口号、复用与分用" class="headerlink" title="5.2 端口号、复用与分用"></a>5.2 端口号、复用与分用</h2><ul>
<li>运行在计算机上的进程用进程标识符PID来标志，到那时不同操作系统使用不同格式的进程标识符，因此需要用统一的方法对TCP/IP体系的应用进程进行标识。</li>
<li>TCP/IP体系的运输层使用<strong>端口号</strong>来区分应用层的不同应用进程。</li>
</ul>
<p>端口号用16比特标识，取值范围0-65535。其中，熟知端口号：0-1023，用于TCP/IP体系中最重要的一些应用协议，例如FTP使用21/20，HTTP使用80，DNS使用53；登记端口号：1024-49151；短暂端口号：49152-65535，留给客户进程选择暂时使用。</p>
<p>端口号只具有本地意义，只是为了标识本计算机应用层中的各进程，在因特网中，不同计算机中的相同端口号是没有联系的。</p>
<ul>
<li>发送方的复用和接收方的分用：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220503152757.png" style="zoom:80%;" /></p>
<ul>
<li>运输层熟知端口号：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220503152843.png" style="zoom:80%;" /></p>
<h2 id="5-3-UDP和TCP的对比"><a href="#5-3-UDP和TCP的对比" class="headerlink" title="5.3 UDP和TCP的对比"></a>5.3 UDP和TCP的对比</h2><p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220503153002.png" style="zoom:80%;" /></p>
<ul>
<li><p>UDP支持单播、多播以及广播，也就是支持一对一，一对多，多对一和多对多交互通信；TCP仅支持单播，也就是只能一对一通信。</p>
</li>
<li><p>UDP是面向应用报文的；TCP是面向字节流的。</p>
</li>
<li>UDP向上层提供无连接不可靠传输服务（适用于IP电话、视频会议等实时应用）；TCP向上层提供面向连接的可靠传输服务（适用于要求可靠传输的应用，例如文件传输）。</li>
<li>UDP用户数据报首部仅8字节；TCP报文段首部最小20字节，最大60字节。</li>
</ul>
<h2 id="5-4-TCP的流量控制"><a href="#5-4-TCP的流量控制" class="headerlink" title="5.4 TCP的流量控制"></a>5.4 TCP的流量控制</h2><ul>
<li>一般来说，我们希望数据发的更快一些，但是如果发送方的数据发送的过快，接收方就可能来不及接收，就会造成数据的丢失。所以要进行流量控制，让发送方的发送速率不要太快，要让接收方来得及接收。利用滑动窗口机制可以实现流量控制。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220503153802.png" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220503153829.png" style="zoom:80%;" /></p>
<h2 id="5-5-TCP的拥塞控制"><a href="#5-5-TCP的拥塞控制" class="headerlink" title="5.5 TCP的拥塞控制"></a>5.5 TCP的拥塞控制</h2><ul>
<li>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络性能就要变坏，这种情况就叫做拥塞。</li>
<li>有四种基本拥塞控制算法，细节略去：慢开始、拥塞避免、快重传、快恢复。</li>
</ul>
<h2 id="5-6-TCP超时重传时间的选择"><a href="#5-6-TCP超时重传时间的选择" class="headerlink" title="5.6 TCP超时重传时间的选择"></a>5.6 TCP超时重传时间的选择</h2><ul>
<li>超时重传时间不能太久也不能太短，一般应该略大于往返时间。</li>
<li>如何设置超时重传时间？一般根据往返时间计算得出，是有公式的，并且随着时间的变化超时重传时间计算出来也是不一样的，具体怎么计算的细节略去。</li>
</ul>
<h2 id="5-7-TCP可靠传输的实现"><a href="#5-7-TCP可靠传输的实现" class="headerlink" title="5.7 TCP可靠传输的实现"></a>5.7 TCP可靠传输的实现</h2><ul>
<li>TCP基于以字节为单位的滑动窗口来实现可靠传输。</li>
</ul>
<p>发送方和接收方均设置滑动窗口，并且分别设置窗口大小。发送方滑动窗口内的字节代表可以发送，接收方滑动窗口内的字节代表可以接收。</p>
<p>接收方必须有累计确认和捎带确认机制。</p>
<p>TCP的通信是全双工通信。</p>
<h2 id="5-8-TCP的运输连接管理"><a href="#5-8-TCP的运输连接管理" class="headerlink" title="5.8 TCP的运输连接管理"></a>5.8 TCP的运输连接管理</h2><ul>
<li>TCP是面向连接的协议，它基于运输连接来传送TCP报文段。</li>
<li>TCP运输连接的建立和释放是每一次面向连接的通信中必不可少的过程。</li>
<li>TCP的运输连接有三个阶段：1.建立TCP连接 2.数据传送 3.释放TCP连接</li>
<li>TCP的运输连接管理就是使运输连接的建立和释放都能正常地运行。</li>
</ul>
<h3 id="5-8-1-TCP的连接建立—三次握手"><a href="#5-8-1-TCP的连接建立—三次握手" class="headerlink" title="5.8.1 TCP的连接建立—三次握手"></a>5.8.1 TCP的连接建立—三次握手</h3><ul>
<li>连接建立主要解决三个问题：1.使TCP双方能够确知对方的存在；2.使TCP双方能够协商一些参数；3.使TCP双方能够对运输实体资源进行分配。</li>
<li>三次握手过程：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220504191701.png" style="zoom:80%;" /></p>
<p>第一次握手：客户端向服务器发送TCP连接数据报，代表客户端想要建立连接，其中要将SYN设置为1，代表是在建立连接，并且将seq初始化一个x值。</p>
<p>第二次握手：服务器像客户端发送TCP连接数据报，代表服务器想要建立连接，其中将SYN设置为1，代表是在建立连接；将ACK设为1代表数据报中含有ack；将seq初始化一个y值，将ack设置为x+1。</p>
<p>第三次握手：客户端像服务器发送TCP普通数据报，代表服务器的TCP连接数据报已收到，其中ACK为1，代表存在ack，将seq设置为x+1，ack设置为y+1。</p>
<ul>
<li>能不能取消第三次握手，只采用两次握手？</li>
</ul>
<p>当然是不能的，不然大家就说两次握手不说三次握手了（啊不是）。确实是不能，但是为啥不能？</p>
<p>现在假设我们只采用两次握手，那么考虑下图这种情况：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220504192408.png" style="zoom:80%;" /></p>
<p>假设第一次握手由于网络原因很久才会到达服务器，而在它到达之前，客户端已经重发了第一次握手并且已经和服务器完成了连接建立，完成了数据传输，完成了释放连接，一切都已经结束。这时，服务器收到了原本的第一次握手，这时服务器向客户端发起第二次握手，但是由于客户端已经关闭了不会理睬，那么服务器就会一直向客户端发送第二次握手，实在是浪费资源。（服务器属实是舔🐶了）。</p>
<h3 id="5-8-2-TCP的连接释放—四次挥手"><a href="#5-8-2-TCP的连接释放—四次挥手" class="headerlink" title="5.8.2 TCP的连接释放—四次挥手"></a>5.8.2 TCP的连接释放—四次挥手</h3><p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220504193108.png" style="zoom:80%;" /></p>
<p>第一次挥手：客户端发送TCP释放连接数据报，代表客户端没有数据要向服务器发送了，其中将FIN位设置为1，代表是释放连接；将ACK设置为1，代表存在ack；将seq设置为u，将ack设置为v。</p>
<p>第二次挥手：服务器发送TCP普通数据报，代表服务器收到客户端的释放连接数据报，其中将ACK设置为1，代表存在ack；将seq设置为v，将ack设置为u+1。</p>
<p>在这中间，如果服务器还有数据要发送给客户端，那么将继续发送给客户端，奉献自己最后的一点爱。</p>
<p>第三次挥手：服务器发送TCP释放连接数据报，代表服务器没有数据要向服务器发送了，其中将FIN位设置为1，代表是释放连接；将ACK设置为1，代表存在ack；将seq设置为w，将ack设置为u+1。</p>
<p>第四次挥手：客户端发送TCP普通数据报，代表客户端收到服务器的释放连接数据报，其中将ACK设置为1，代表存在ack；将seq设置为u+1，将ack设置为w+1。</p>
<p>在服务器接收到第四次挥手后就关闭连接，而客户端等待2MSL时间后也关闭连接。</p>
<ul>
<li>为什么客户端要等待2MSL时间后在关闭连接？可不可以不等待，在发出第四次挥手后就立刻关闭呢？</li>
</ul>
<p>不行。假设客户端立刻关闭连接的话，假如客户端发起的第四次挥手丢失了， 那么服务器由于舔🐶属性（啊不是）会一直等待客户端的第四次挥手，如果等不到，就会反复地向客户端发送第三次挥手，但是由于客户端已关闭，无法相应服务器的第三次挥手，就无法进入关闭状态。所以当客户端等待2MSL时间，在这个时间段内如果收到服务器的第三次挥手就会重发第四次挥手。</p>
<ul>
<li>当客户端出现故障时，服务器端如何才能知道呢？</li>
</ul>
<p>TCP服务器进程没收到一次TCP客户端进程的数据，就重新设置并启动保活计时器（2小时定时）。</p>
<p>若保活计时器定时周期内未收到TCP客户端发来的数据，则当保活计时器到时后，TCP服务器进程就向TCP客户进程发送一个探测报文段，以后则每个75秒钟发送一次。若一连发送10个探测报文段后仍无TCP客户端进程的响应，TCP服务器进程就认为TCP客户进程所在主机出了故障，接着就关闭这个连接。</p>
<h2 id="5-9-TCP报文段的首部格式"><a href="#5-9-TCP报文段的首部格式" class="headerlink" title="5.9 TCP报文段的首部格式"></a>5.9 TCP报文段的首部格式</h2><p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220504194635.png" style="zoom:80%;" /></p>
]]></content>
      <categories>
        <category>Network</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>Network</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络-6.应用层</title>
    <url>/2022/11/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-6-%E5%BA%94%E7%94%A8%E5%B1%82/</url>
    <content><![CDATA[<h1 id="6-应用层"><a href="#6-应用层" class="headerlink" title="6.应用层"></a>6.应用层</h1><h2 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h2><ul>
<li>各层解决的问题：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220505193051.png" style="zoom:80%;" /></p>
<span id="more"></span>
<h2 id="6-2-客户-服务器方式（C-S方式）和对等方式（P2P方式）"><a href="#6-2-客户-服务器方式（C-S方式）和对等方式（P2P方式）" class="headerlink" title="6.2 客户/服务器方式（C/S方式）和对等方式（P2P方式）"></a>6.2 客户/服务器方式（C/S方式）和对等方式（P2P方式）</h2><h3 id="6-2-1-客户-服务器方式（C-S方式）"><a href="#6-2-1-客户-服务器方式（C-S方式）" class="headerlink" title="6.2.1 客户/服务器方式（C/S方式）"></a>6.2.1 客户/服务器方式（C/S方式）</h3><ul>
<li><p>客户和服务器是指通信中所设计的两个应用进程。服务器总是处于运行状态，并等待客户的服务请求。服务器具有固定端口号，而运行服务器的主机也具有固定的IP地址。</p>
</li>
<li><p>C/S方式通常是服务集中型的，也就是说应用服务集中在网络中比客户计算机少得多的服务器计算机上。常会出现服务器计算机跟不上众多客户机请求的情况，因此常用集群构建一个强大的虚拟服务器。</p>
</li>
</ul>
<h3 id="6-2-2-对等方式（P2P方式）"><a href="#6-2-2-对等方式（P2P方式）" class="headerlink" title="6.2.2 对等方式（P2P方式）"></a>6.2.2 对等方式（P2P方式）</h3><ul>
<li>没有固定的服务请求者和服务提供者，分布在网格边缘各端系统中的应用进程是对等的，被称为对等放。对等方直接通信，每个对等放既是服务的请求者，又是服务的提供者。</li>
<li>P2P是服务分散型的，服务不是集中在少数几个服务器计算机中，而是分散在大量对等计算机中。</li>
<li>P2P最突出的特性之一就是可扩展性，系统性能不会因规模的增大而降低。</li>
<li>P2P具有成本上的优势，因为不需要庞大的服务器设施和服务器带宽。</li>
</ul>
<h2 id="6-3-动态主机配置协议DHCP"><a href="#6-3-动态主机配置协议DHCP" class="headerlink" title="6.3 动态主机配置协议DHCP"></a>6.3 动态主机配置协议DHCP</h2><ul>
<li><p>DHCP可以为局域网中的各主机配置以下信息：IP地址、子网掩码、默认网关、DNS服务器。</p>
</li>
<li><p>工作流程：</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220505200507.png" style="zoom:80%;" /></p>
<ul>
<li>DHCP中继代理</li>
</ul>
<p>当我们不希望在网络中设置太多的DHCP服务器时，就采用DHCP中继代理，也就是说在路由器中配置DHCP服务器的IP地址使之成为DHCP中继代理。</p>
<h2 id="6-4-域名系统DNS（Domain-Name-System）"><a href="#6-4-域名系统DNS（Domain-Name-System）" class="headerlink" title="6.4 域名系统DNS（Domain Name System）"></a>6.4 域名系统DNS（Domain Name System）</h2><ul>
<li>关于DNS，可以看看<a href="http://blog.foursevenlove.top/?p=160这里的1.3节。这里偷个懒不再写了。">http://blog.foursevenlove.top/?p=160这里的1.3节。这里偷个懒不再写了。</a></li>
</ul>
<h2 id="6-5-文件传送协议FTP"><a href="#6-5-文件传送协议FTP" class="headerlink" title="6.5 文件传送协议FTP"></a>6.5 文件传送协议FTP</h2><ul>
<li>将某台计算机中的文件通过网络传送到可能相距很远的另一台计算机中，是一项基本的网络应用，即文件传送。</li>
<li>文件传送协议FTP（File Transfer Protocol）是因特网上使用得最广泛得文件传送协议。FTP提供交互式的访问，允许客户指明文件的类型与格式（如指明是否使用ASCII码），并允许文件具有存取权限。FTP屏蔽了各计算机系统的细节，因而适用于在各异构网络中任意计算机之间传送文件。</li>
<li>工作原理：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220506154952.png" style="zoom:80%;" /></p>
<h2 id="6-6-电子邮件"><a href="#6-6-电子邮件" class="headerlink" title="6.6 电子邮件"></a>6.6 电子邮件</h2><ul>
<li>电子邮件采用客户/服务器方式。</li>
<li><p>三个主要组成构件：用户代理、邮件服务器以及电子邮件所需的协议。</p>
</li>
<li><p>用户代理：用户与电子邮件系统的接口，又称为电子邮件客户端软件。</p>
</li>
<li><p>邮件服务器：电子邮件系统的基础设施，因特网上的所有ISP都有邮件服务器，其功能是发送和接收邮件，同时还要负责维护用户的邮箱。</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220506160148.png" style="zoom:80%;" /></p>
<ul>
<li>协议：</li>
</ul>
<p>简单邮件传送协议SMTP（Simple Mail Transfer Protocol）基本工作原理：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220506160306.png" style="zoom:80%;" /></p>
<p>SMTP只能传送ASCII码文本数据，不能传送可执行文件或其他的二进制对象。未来解决SMTP传送非ASCII码文本的问题，提出了多用途英特网邮件扩展MIME（Multipurpose Internet Mail Extensions）。</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220506161028.png" style="zoom:80%;" /></p>
<p>常见的邮件读取协议：</p>
<p>邮局协议POP（Post Office Protocol），POP3是其第三个版本，是因特网正式标准，基于TCP连接的客户/服务器方式，使用熟知端口110。</p>
<p>因特网邮件访问协议IMAP（Internet Message Access Protocol），只是因特网建议标准，基于TCP连接的客户/服务器方式，使用熟知端口143。</p>
<ul>
<li>基于万维网的电子邮件：</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220506161821.png" style="zoom:80%;" /></p>
<h2 id="6-7-万维网WWW"><a href="#6-7-万维网WWW" class="headerlink" title="6.7 万维网WWW"></a>6.7 万维网WWW</h2><ul>
<li>万维网WWW（World Wide Web）并非某种特殊的计算机网络。它是一个大规模的、联机式的信息储藏所，是运行在因特网上的一个分布式应用。利用网页之间的超链接将不同网站的网页链接成一张逻辑上的信息网。使用统一资源定位符URL来指明因特网上任何种类资源的位置。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220506162056.png" style="zoom:80%;" /></p>
<ul>
<li>超文本传输协议HTTP（Hyper Text Transfer Protocol）</li>
</ul>
<p>HTTP定义了浏览器（即万维网客户进程）怎样向万维网服务器请求万维网文档，以及万维网服务器怎样把万维网文档传送给浏览器。</p>
<p>HTTP/1.0 采用非持续链接方式，每次浏览器要请求一个文件都要与服务器建立TCP连接，当收到响应后就立即关闭连接。</p>
<p>HTTP/1.1采用持续连接方式，在该方式下，万维网服务器在发送响应后仍然保持这条连接，使同ing一个客户（浏览器）和该服务器之间可以继续在这条连接上传送后续的HTTP请求报文和响应报文。这并不局限于传送同一个页面上引用的对象，只要这些文档在同一个服务器上就行。为了进一步提高效率，该方式还可以使用流水线方式工作。</p>
<p>HTTP报文格式：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220506162609.png" style="zoom:80%;" /></p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220506162625.png" style="zoom:80%;" /></p>
<ul>
<li>使用Cookie在服务器上记录用户信息</li>
</ul>
<p>早期的万维网应用非常简单，仅仅是用户查看存放在不同服务器上的各种静态的文档。因此HTTP被设计为一种无状态的协议。但是现在往往很多应用都需要万维网服务器能够识别用户。</p>
<p>Cookie提供了一种机制能够使万维网能够记住用户，也就是说Cookie对无状态的HTTP状态化。</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220506162918.png" style="zoom:80%;" /></p>
<ul>
<li>万维网缓存与代理服务器</li>
</ul>
<p>可以使用缓存机制提高万维网效率。万维网缓存又称Web缓存，可位于客户机，也可位于中间系统上，位于中间系统上的Web缓存又称代理服务器。Web缓存把最近一些请求和响应暂存在本地磁盘中。当新请求到达时，若发现这个请求与暂存的请求相同，就返回暂存的响应。当然，缓存是有过期时间的，过期后需要重新去服务器访问。</p>
]]></content>
      <categories>
        <category>Network</category>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>Network</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-V2-28-对称的二叉树</title>
    <url>/2022/11/13/%E5%89%91%E6%8C%87offer-V2-28-%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="剑指offer-V2-28-对称的二叉树"><a href="#剑指offer-V2-28-对称的二叉树" class="headerlink" title="剑指offer-V2-28-对称的二叉树"></a>剑指offer-V2-28-对称的二叉树</h1><p><a href="">原题点这里</a></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202211131238226.png" alt=""></p>
<span id="more"></span>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202211131238762.png" alt=""></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202211131239631.png" alt=""></p>
<p>如图，对称的二叉树应该满足这些条件：</p>
<ol>
<li>对称节点（两个2，称之为2.1和2.2）的Val相同。</li>
<li>对称节点2.1的左子树和2.2的右子树应该满足对称关系。</li>
<li>对称节点2.1的右子树和2.2的左子树应该满足对称关系。</li>
</ol>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isSymmetric</span><span class="params">(root *TreeNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> recur(root, root)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recur</span><span class="params">(l, r *TreeNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> l == <span class="literal">nil</span> &amp;&amp; r == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> l == <span class="literal">nil</span> || r == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> l.Val != r.Val &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> recur(l.Left, r.Right) &amp;&amp; recur(l.Right, r.Left)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>offer</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-V2-27-二叉树的镜像</title>
    <url>/2022/11/13/%E5%89%91%E6%8C%87offer-V2-27-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F/</url>
    <content><![CDATA[<h1 id="剑指offer-V2-27-二叉树的镜像"><a href="#剑指offer-V2-27-二叉树的镜像" class="headerlink" title="剑指offer-V2-27-二叉树的镜像"></a>剑指offer-V2-27-二叉树的镜像</h1><p><a href="https://leetcode.cn/problems/er-cha-shu-de-jing-xiang-lcof/description/?favorite=xb9nqhhg">原题点这里</a></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202211131234423.png" alt=""></p>
<span id="more"></span>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>递归思想。假设对于左子树和右子树都已经得到镜像结果了，那么现在要做的就是，原左子树用右子树的镜像代替，右子树用左子树的镜像代替。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> TreeNode <span class="keyword">struct</span> &#123;</span><br><span class="line">	Val   <span class="type">int</span></span><br><span class="line">	Left  *TreeNode</span><br><span class="line">	Right *TreeNode</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mirrorTree</span><span class="params">(root *TreeNode)</span></span> *TreeNode &#123;</span><br><span class="line">	<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	left := mirrorTree(root.Left)</span><br><span class="line">	right := mirrorTree(root.Right)</span><br><span class="line">	root.Left = right</span><br><span class="line">	root.Right = left</span><br><span class="line">	<span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>offer</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>offer</tag>
      </tags>
  </entry>
  <entry>
    <title>K8S修炼之路-2.筑基期-kube-apiserver</title>
    <url>/2022/11/14/K8S%E4%BF%AE%E7%82%BC%E4%B9%8B%E8%B7%AF-2-%E7%AD%91%E5%9F%BA%E6%9C%9F-kube-apiserver/</url>
    <content><![CDATA[<h1 id="kube-apiserver"><a href="#kube-apiserver" class="headerlink" title="kube-apiserver"></a>kube-apiserver</h1><p>在kubernetes架构里，分为master节点和worker节点，在不同节点上有不同的组件。<br><span id="more"></span><br>master节点的主要组件：</p>
<ul>
<li>etcd</li>
<li>kube-apiserver</li>
<li>kube-scheduler</li>
<li>kube-controller-manager</li>
</ul>
<p>worker节点的主要组件：</p>
<ul>
<li>kubelet</li>
<li>kube-proxy</li>
<li>container runtime</li>
</ul>
<p>之前已经了解了etcd的原理以及在kubernetes中的应用，etcd作为k8s的数据库，到底是谁在操纵这个数据库？答案就是本篇的主题，kube-apiserver。事实上，kube-apiserver不仅在操纵着etcd，而且还是唯一一个能够直接和etcd通信的组件。</p>
<p>我们可以用很多种方式来访问一个k8s集群，比如kubectl、各种语言的client，一般可能最常用的就是使用kubectl。那么在用kubeclt和集群交互时，本质上是在调用k8s提供的API。比如当<code>kubectl apply -f xxx.yaml</code>时，kubectl会做很多处理，校验之后转变成要调用k8s的API，然后发送给集群。实际上集群在接收API请求的时候，就是API server大显身手的时候。</p>
<p>可以认为API server就是一个集群的gateway，简单来说，其用于处理REST请求，验证请求，更新etcd中相应的object。当API server收到一个请求后，并不是直接就执行该请求，这中间要经过很多步骤，一般来讲至少要经过Authentication、Authorization和Admission Control。个人认为目前的修炼阶段或许不需要了解这三个过程的具体细节，只需要了解每个阶段做了什么事情就可以。</p>
<ul>
<li>对于Authentication，验证一个请求的发起者是否合法，也就是这个请求到底是谁发起的，这个用户是否合法。该阶段处理的是身份的问题。</li>
<li>对于Authorization，在已经验证用户合法后，还要验证该用户具有哪些权限，有没有权限发起这个请求。该阶段处理的是权限的问题 。</li>
<li>对于Admission Control，是资源对象保存到 <code>etcd</code> 之前的最后一个堡垒，封装了一系列额外的检查以确保操作不会产生意外或负面结果。和前面两个操作不同，前两个操作是为了判断用户的身份和权限能不能够发起这次请求，而对于Admission Control也就是准入控制，判断的是这次请求的内容会不会对集群产生什么负面影响。在准入控制阶段，要经过一个准入控制链，在准入控制链下有一系列的准入控制器，用于进行验证。</li>
</ul>
<p>如果上述三个基本步骤都没有问题的话，那么API server就可以操作etcd了。</p>
<p>大致的流程是这样：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220614001735.png" style="zoom:80%;" /></p>
<ol>
<li>用户申请创建一个pod，kubectl向API server发起请求。</li>
<li>API server验证请求后操作数据库。</li>
<li>etcd告诉API server操作结果。</li>
<li>Scheduler发现有新的资源请求了。</li>
<li>Scheduler决定把这个pod放在哪里运行并且把结果返回给API server。</li>
<li>API server把结果写到etcd。</li>
<li>etcd告诉API server操作结果。</li>
<li>API server通知对应节点中的kubelet来活了。</li>
<li>kubelet通知docker daemon来活了，docker创建容器。</li>
<li>kubelet蒋pod状态返回API server。</li>
<li>API server将状态写入etcd。</li>
</ol>
]]></content>
      <categories>
        <category>k8s</category>
        <category>kube-ladder</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>kube-ladder</tag>
      </tags>
  </entry>
  <entry>
    <title>K8S修炼之路-1. 炼气期</title>
    <url>/2022/11/14/K8S%E4%BF%AE%E7%82%BC%E4%B9%8B%E8%B7%AF-1-%E7%82%BC%E6%B0%94%E6%9C%9F/</url>
    <content><![CDATA[<h1 id="K8S修炼之路-1-炼气期"><a href="#K8S修炼之路-1-炼气期" class="headerlink" title="K8S修炼之路-1. 炼气期"></a>K8S修炼之路-1. 炼气期</h1><h2 id="修炼须知及目标"><a href="#修炼须知及目标" class="headerlink" title="修炼须知及目标"></a>修炼须知及目标</h2><p>本阶段为k8s修炼之路的开始阶段，不求学会太深奥的原理，只要明白为啥需要k8s以及k8s的基本使用即可。目标如下：</p>
<ul>
<li>安装 Kubernetes 环境</li>
<li>Kubernetes 基本概念和使用方法<br><span id="more"></span>s</li>
</ul>
<h2 id="修炼内容"><a href="#修炼内容" class="headerlink" title="修炼内容"></a>修炼内容</h2><h3 id="1-修炼环境"><a href="#1-修炼环境" class="headerlink" title="1. 修炼环境"></a>1. 修炼环境</h3><h4 id="1-1-kubectl"><a href="#1-1-kubectl" class="headerlink" title="1.1 kubectl"></a>1.1 kubectl</h4><p>kubectl是一个命令行工具，用于和k8s集群中的资源进行交互，安装参考<a href="https://kubernetes.io/zh/docs/tasks/tools/install-kubectl-linux/">https://kubernetes.io/zh/docs/tasks/tools/install-kubectl-linux/</a></p>
<p>kubectl命令较多，使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl -h</span></span><br></pre></td></tr></table></figure>
<p>查看帮助，并且在实战中学习。</p>
<h4 id="1-2-minikube"><a href="#1-2-minikube" class="headerlink" title="1.2 minikube"></a>1.2 minikube</h4><p>minikube是一个极简版的k8s集群，运行在一个机器上，仅包含一个master节点和一个node节点。使用minikube省去了搭建k8s集群的步骤，是入门时使用k8s的非常方便的途径。安装参考<a href="https://minikube.sigs.k8s.io/docs/start/">https://minikube.sigs.k8s.io/docs/start/</a></p>
<p>安装完成后，使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">minikube start</span></span><br><span class="line">😄  minikube v1.2.0 on darwin (amd64)</span><br><span class="line">🔥  Creating virtualbox VM (CPUs=2, Memory=2048MB, Disk=20000MB) ...</span><br><span class="line">🐳  Configuring environment for Kubernetes v1.15.0 on Docker 18.09.6</span><br><span class="line">💾  Downloading kubeadm v1.15.0</span><br><span class="line">💾  Downloading kubelet v1.15.0</span><br><span class="line">🚜  Pulling images ...</span><br><span class="line">🚀  Launching Kubernetes ...</span><br><span class="line">⌛  Verifying: apiserver proxy etcd scheduler controller dns</span><br><span class="line">🏄  Done! kubectl is now configured to use &quot;minikube&quot;</span><br></pre></td></tr></table></figure>
<p>命令可以启动集群。</p>
<p>使用以下命令验证安装：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get nodes</span></span><br><span class="line">NAME       STATUS   ROLES    AGE    VERSION</span><br><span class="line">minikube   Ready    master   4m5s   v1.15.0</span><br></pre></td></tr></table></figure>
<p>常用命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">进入集群节点</span></span><br><span class="line">minikube ssh</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看节点 IP</span></span><br><span class="line">minikube ip</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">停止集群</span></span><br><span class="line">minikube stop</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除集群</span></span><br><span class="line">minikube delete</span><br></pre></td></tr></table></figure>
<p>在这个过程中，不出意外应该会有很多意外，擅用google是修炼路上的重要辅助。</p>
<h3 id="2-操纵基本资源"><a href="#2-操纵基本资源" class="headerlink" title="2. 操纵基本资源"></a>2. 操纵基本资源</h3><h4 id="2-1-kubectl-基本用法"><a href="#2-1-kubectl-基本用法" class="headerlink" title="2.1 kubectl 基本用法"></a>2.1 kubectl 基本用法</h4><h5 id="kubectl-version"><a href="#kubectl-version" class="headerlink" title="kubectl version"></a>kubectl version</h5><p>使用以下命令查看k8s版本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl version</span></span><br><span class="line">Client Version: version.Info&#123;Major:&quot;1&quot;, Minor:&quot;23&quot;, GitVersion:&quot;v1.23.5&quot;, GitCommit:&quot;c285e781331a3785a7f436042c65c5641ce8a9e9&quot;, GitTreeState:&quot;clean&quot;, BuildDate:&quot;2022-03-16T15:58:47Z&quot;, GoVersion:&quot;go1.17.8&quot;, Compiler:&quot;gc&quot;, Platform:&quot;linux/amd64&quot;&#125;</span><br><span class="line">Server Version: version.Info&#123;Major:&quot;1&quot;, Minor:&quot;23&quot;, GitVersion:&quot;v1.23.3&quot;, GitCommit:&quot;816c97ab8cff8a1c72eccca1026f7820e93e0d25&quot;, GitTreeState:&quot;clean&quot;, BuildDate:&quot;2022-01-25T21:19:12Z&quot;, GoVersion:&quot;go1.17.6&quot;, Compiler:&quot;gc&quot;, Platform:&quot;linux/amd64&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，kubectl 客户端的版本是 v1.23.5，kubernetes 集群的版本是 v1.23.3。同时，该命令还会输出 kubernetes 编译信息。</p>
<h5 id="kubectl-cluster-info"><a href="#kubectl-cluster-info" class="headerlink" title="kubectl cluster-info"></a>kubectl cluster-info</h5><p>使用以下命令查看集群信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl cluster-info</span></span><br><span class="line">Kubernetes control plane is running at https://192.168.58.2:8443</span><br><span class="line">CoreDNS is running at https://192.168.58.2:8443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy</span><br><span class="line"></span><br><span class="line">To further debug and diagnose cluster problems, use &#x27;kubectl cluster-info dump&#x27;.</span><br></pre></td></tr></table></figure>
<h5 id="kubectl-command-format"><a href="#kubectl-command-format" class="headerlink" title="kubectl command format"></a>kubectl command format</h5><p>kubectl 命令的基本格式是 <code>kubectl &lt;action&gt; &lt;resource&gt;</code>，其中 <code>action</code> 可以是 <code>create</code>, <code>delete</code>, <code>get</code> 等等，<code>resource</code> 可以使用 <code>kubectl api-resources</code> 获得完整列表。</p>
<h5 id="kubectl-config-file"><a href="#kubectl-config-file" class="headerlink" title="kubectl config file"></a>kubectl config file</h5><p>kubectl通过读取配置文件与集群进行交互，默认配置文件路径是 <code>~/.kube/config</code>，内容可能如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">&amp; cat ~/.kube/config</span><br><span class="line">apiVersion: v1</span><br><span class="line">clusters:</span><br><span class="line">- cluster:</span><br><span class="line">    certificate-authority: /root/.minikube/ca.crt</span><br><span class="line">    extensions:</span><br><span class="line">    - extension:</span><br><span class="line">        last-update: Mon, 23 May 2022 00:23:49 CST</span><br><span class="line">        provider: minikube.sigs.k8s.io</span><br><span class="line">        version: v1.25.2</span><br><span class="line">      name: cluster_info</span><br><span class="line">    server: https://192.168.58.2:8443</span><br><span class="line">  name: minikube</span><br><span class="line">contexts:</span><br><span class="line">- context:</span><br><span class="line">    cluster: minikube</span><br><span class="line">    extensions:</span><br><span class="line">    - extension:</span><br><span class="line">        last-update: Mon, 23 May 2022 00:23:49 CST</span><br><span class="line">        provider: minikube.sigs.k8s.io</span><br><span class="line">        version: v1.25.2</span><br><span class="line">      name: context_info</span><br><span class="line">    namespace: default</span><br><span class="line">    user: minikube</span><br><span class="line">  name: minikube</span><br><span class="line">current-context: minikube</span><br><span class="line">kind: Config</span><br><span class="line">preferences: &#123;&#125;</span><br><span class="line">users:</span><br><span class="line">- name: minikube</span><br><span class="line">  user:</span><br><span class="line">    client-certificate: /root/.minikube/profiles/minikube/client.crt</span><br><span class="line">    client-key: /root/.minikube/profiles/minikube/client.key</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>这里有三个重要的顶级概念: <code>clusters</code>, <code>users</code> 和 <code>contexts</code>。</p>
<p>我们使用的集群名为 <code>minikube</code>，其服务器地址为 <code>https://192.168.99.100:8443</code>，其认证证书位于 <code>$&#123;HOME&#125;/.minikube/ca.crt</code>。</p>
<p>当我们使用该 kubeconfig 发送请求时，我们充当用户 <code>minikube</code> (确切地说，真正的用户名来自证书通用名，但是我们暂时跳过它)。</p>
<p>最后，<code>context</code> 是各种配置的组合，例如，存在两个 <code>context</code>，一个用于集群 <code>minikube</code> 以及用户 <code>minikube</code>，另一个用于集群 <code>example</code> 和用户 <code>minikube</code>，即这意味着用户 <code>minikube</code> 可以同时访问 <code>minikube</code> 和 <code>example</code> 集群。</p>
<h4 id="2-2-Node"><a href="#2-2-Node" class="headerlink" title="2.2 Node"></a>2.2 Node</h4><p>k8s是主从架构，master是主节点，node是从节点。节点node可以是物理机也可以是虚拟机，一个node包含若干个Pod。</p>
<h5 id="Node-information"><a href="#Node-information" class="headerlink" title="Node information"></a>Node information</h5><p>查看有哪些节点：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get nodes</span></span><br><span class="line">NAME       STATUS   ROLES                  AGE   VERSION</span><br><span class="line">minikube   Ready    control-plane,master   8d    v1.23.3</span><br></pre></td></tr></table></figure>
<p>这里 minikube 节点即是 master 也是 node。</p>
<h5 id="Node-details"><a href="#Node-details" class="headerlink" title="Node details"></a>Node details</h5><p>查看节点详细信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl describe nodes minikube</span></span><br></pre></td></tr></table></figure>
<h4 id="2-3-Namespace"><a href="#2-3-Namespace" class="headerlink" title="2.3 Namespace"></a>2.3 Namespace</h4><p>namespace和docker中的类似，用于隔离资源，类似于一个分组。不同namespace中的资源名字可以相同，同一namespace下的资源不能同名。使用namespace达到了共享 kubernetes 集群资源的目的。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get ns</span></span><br><span class="line">NAME                   STATUS   AGE</span><br><span class="line">default                Active   8d</span><br><span class="line">kube-node-lease        Active   8d</span><br><span class="line">kube-public            Active   8d</span><br><span class="line">kube-system            Active   8d</span><br><span class="line">kubernetes-dashboard   Active   8d</span><br><span class="line">tutorial               Active   2d4h</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl describe ns tutorial</span></span><br><span class="line">Name:         tutorial</span><br><span class="line">Labels:       kubernetes.io/metadata.name=tutorial</span><br><span class="line">Annotations:  &lt;none&gt;</span><br><span class="line">Status:       Active</span><br><span class="line"></span><br><span class="line">No resource quota.</span><br><span class="line"></span><br><span class="line">No LimitRange resource.</span><br></pre></td></tr></table></figure>
<h4 id="2-4-Pod-amp-Deployment"><a href="#2-4-Pod-amp-Deployment" class="headerlink" title="2.4 Pod &amp; Deployment"></a>2.4 Pod &amp; Deployment</h4><p>通过image可以创建container，而pod就是container的运行环境。一个节点可以有多个pod，一个pod内可以有多个container，container之间共享底层资源。</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220531191140.png" style="zoom:80%;" /></p>
<p>在生产环境中，一般不直接操作pod，而是操作deployment，二者之间有啥区别？</p>
<p>通过创建deployment，可以更方便地管理pod，具体来说：</p>
<p>对于pod：</p>
<ol>
<li>如果die了，那就die了。也就是说无容错能力，这也就是为什么生产环境不直接创建pod。</li>
<li>对于一个特定的创建pod的yml文件，只能创建一个pod。如果想创建多个相同配置的pod，也需要写多份pod的yml文件。</li>
</ol>
<p>对于deployment：</p>
<ol>
<li>可以定义我们预期的pod的状态，比如有几个pod。这样当一个pod die了，deplyment会自动创建一个新的pod，使整体情况达到我们的预期。</li>
</ol>
<p><strong>Create Deployment</strong></p>
<p>通过以下命令创建deployment：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl apply -f resources/deployment_nginx.yaml -n tutorial</span></span><br><span class="line">deployment.apps/nginx-deployment created</span><br></pre></td></tr></table></figure>
<p>在执行以上命令后，k8s在集群中寻找一台满足需求的机器运行节点，然后该节点上的 agent 启动该应用。</p>
<p>-n 代表指定 namespace</p>
<p><strong>Get Deployment</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pods -n tutorial</span></span><br><span class="line">NAME                     READY   STATUS    RESTARTS   AGE</span><br><span class="line">nginx-646b46d648-hbwg2   1/1     Running   0          101s</span><br></pre></td></tr></table></figure>
<p><strong>Get Pods</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pods -n tutorial</span></span><br><span class="line">NAME                     READY   STATUS    RESTARTS   AGE</span><br><span class="line">nginx-646b46d648-hbwg2   1/1     Running   0          101s</span><br></pre></td></tr></table></figure>
<p>更多信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pods -n tutorial -o wide</span></span><br><span class="line">NAME                     READY   STATUS    RESTARTS   AGE     IP            NODE       NOMINATED NODE   READINESS GATES</span><br><span class="line">nginx-646b46d648-hbwg2   1/1     Running   0          2m23s   172.17.0.11   minikube   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure>
<p><strong>Get Pod Logs</strong></p>
<p>当我们部署要应用之后，可以通过 <code>kubectl logs &lt;pod name&gt;</code> 和 <code>kubectl exec &lt;pod name&gt;</code> 与 Pod 交互。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl logs nginx-646b46d648-hbwg2 -n tutorial</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-- 用于区分本地终端命令和容器中执行的命令</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl <span class="built_in">exec</span> nginx-646b46d648-hbwg2 -n tutorial -- <span class="built_in">ls</span> -l</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">使用 ctrl + d 可以退出远程终端</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl <span class="built_in">exec</span> -it nginx-646b46d648-hbwg2 -n tutorial bash</span></span><br></pre></td></tr></table></figure>
<h4 id="2-5-Service"><a href="#2-5-Service" class="headerlink" title="2.5 Service"></a>2.5 Service</h4><p>kubernetes service 有以下几个作用：</p>
<ul>
<li>提供固定的 IP。由于 Pod 可以随时启停，Pod IP 可能随时都会变化，例如上面 nginx pod 重启之后 IP 可能不再是 172.17.0.11。Service 为 Pods 提供的固定 IP，其他服务可以通过 Service IP 找到提供服务的 Pods。</li>
<li>提供负载均衡。Service 由多个 Pods 组成，kubernetes 对组成 Service 的 Pods 提供的负载均衡方案，例如随机访问、基于 Client IP 的 session affinity。</li>
<li>服务发现。集群中其他服务可以通过 Service 名字访问后端服务（DNS），也可以通过环境变量访问。</li>
</ul>
<p>下图是 kubernetes Pods, Service 的典型关系。下图有两个 Deployment: A 和 B。其中 Deployment A 创建了一个 Pods（黄色），Deployment B 创建了三个 Pod（绿色）。我们可以创建两个 Service: A 和 B。 Service A 管理由 Deployment A 创建的 Pods，Service B 管理 Deployment B 创建的 Pods。可以看到， Service A 和 Service B 都有自己独立的 IP。无论他们所管理的容器如何变化， Service 的 IP 都不会变化。</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220531193849.png" style="zoom:80%;" /></p>
<p><strong>Create service</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl expose deployment nginx --port 80 -n tutorial</span></span><br><span class="line">service &quot;nginx&quot; exposed</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get svc nginx -n tutorial</span></span><br><span class="line">NAME    TYPE        CLUSTER-IP    EXTERNAL-IP   PORT(S)   AGE</span><br><span class="line">nginx   ClusterIP   10.96.6.136   &lt;none&gt;        80/TCP    15s</span><br></pre></td></tr></table></figure>
<p>可以看到，nginx这个svc，CLUSTER-IP是10.96.6.136，也就是说如果想访问这个svc下的pod，可以直接访问pod的ip或者这个svc的ip 10.96.6.136。</p>
<p>查看更多信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl describe svc nginx -n tutorial</span></span><br><span class="line">Name:              nginx</span><br><span class="line">Namespace:         tutorial</span><br><span class="line">Labels:            run=nginx</span><br><span class="line">Annotations:       &lt;none&gt;</span><br><span class="line">Selector:          run=nginx</span><br><span class="line">Type:              ClusterIP</span><br><span class="line">IP:                10.96.6.136</span><br><span class="line">Port:              &lt;unset&gt;  80/TCP</span><br><span class="line">TargetPort:        80/TCP</span><br><span class="line">Endpoints:         172.17.0.11:80</span><br><span class="line">Session Affinity:  None</span><br><span class="line">Events:            &lt;none&gt;</span><br></pre></td></tr></table></figure>
<p>可以看到Endpoints这里，172.17.0.11:80是在这个svc下的pod的ip，验证一下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pods -o wide -n tutorial</span></span><br><span class="line">NAME                     READY   STATUS    RESTARTS   AGE   IP            NODE       NOMINATED NODE   READINESS GATES</span><br><span class="line">nginx-646b46d648-hbwg2   1/1     Running   0          14m   172.17.0.11   minikube   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure>
<p>关于几个port：</p>
<ul>
<li>Port: service的port</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220531200853.png" style="zoom:80%;" /></p>
<ul>
<li>TargetPort: 容器的port</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220531200923.png" style="zoom:80%;" /></p>
<ul>
<li>NodePort: node的port</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220531200954.png" style="zoom:80%;" /></p>
<p><strong>Query service</strong></p>
<p>创建 Service 后，我们可以在主机上直接访问该 Service。下面两条命令实际上访问的都是同一个后端。第一个命令通过 Service IP 访问，第二个命令通过 Pod IP 访问。</p>
<p>通过 Service IP 访问：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ minikube ssh</span><br><span class="line">$ curl 10.96.6.136</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>通过 Pod IP 访问：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ minikube ssh</span><br><span class="line">$ curl 172.17.0.11</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>上面的命令创建了一个名为 nginx 的 Service，并使用 80 作为服务端口。这里，我们的 nginx 容器监听的是容器的 80 端口，该端口是 Pod IP 所监听的端口；我们可以在 Service 上使用不同的端口。例如，若我们想暴露的服务端口是 8080 端口，需要使用 port 和 targetPort 选项。</p>
<p>首先，删除已经创建的 Service：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ kubectl delete svc nginx -n tutorial</span><br><span class="line">service &quot;nginx&quot; deleted</span><br></pre></td></tr></table></figure>
<p>之后，创建 Service：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ kubectl expose deployment nginx --port 8080 --target-port 80 -n tutorial</span><br><span class="line">service &quot;nginx&quot; exposed</span><br></pre></td></tr></table></figure>
<p>尝试用 8080 端口访问服务</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ kubectl get svc nginx -n tutorial</span><br><span class="line">NAME    TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)    AGE</span><br><span class="line">nginx   ClusterIP   10.98.125.20   &lt;none&gt;        8080/TCP   6s</span><br><span class="line"></span><br><span class="line">$ minikube ssh</span><br><span class="line">$ curl 10.98.125.20:8080</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p><strong>NodePort service</strong></p>
<p>上述创建的 Service 只能被集群内部的节点和 Pod 访问，并不能被外部访问。我们可以通过两种方式暴露服务：<code>NodePort</code> 和 <code>LoadBalancer</code>。<code>NodePort</code> 通过在每个节点打开一个端口对外提供服务，<code>LoadBalancer</code> 通过创建一个外部负载均衡器（例如公有云负载均衡器）来对外提供服务。这里我们尝试使用 <code>NodePort</code>。</p>
<p>首先，删除已有的 Service：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ kubectl delete svc nginx -n tutorial</span><br><span class="line">service &quot;nginx&quot; deleted</span><br></pre></td></tr></table></figure>
<p>通过 NodePort 暴露服务，注意这里使用了 <code>--type NodePort</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ kubectl expose deployment nginx --port 80 --type NodePort -n tutorial</span><br><span class="line">service &quot;nginx&quot; exposed</span><br></pre></td></tr></table></figure>
<p>查看 Service 的细节：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ kubectl get svc nginx -n tutorial</span><br><span class="line">NAME    TYPE       CLUSTER-IP     EXTERNAL-IP   PORT(S)        AGE</span><br><span class="line">nginx   NodePort   10.107.97.57   &lt;none&gt;        80:32542/TCP   5s</span><br><span class="line">$ kubectl describe svc nginx -n tutorial</span><br><span class="line">Name:                     nginx</span><br><span class="line">Namespace:                tutorial</span><br><span class="line">Labels:                   run=nginx</span><br><span class="line">Annotations:              &lt;none&gt;</span><br><span class="line">Selector:                 run=nginx</span><br><span class="line">Type:                     NodePort</span><br><span class="line">IP:                       10.107.97.57</span><br><span class="line">Port:                     &lt;unset&gt;  80/TCP</span><br><span class="line">TargetPort:               80/TCP</span><br><span class="line">NodePort:                 &lt;unset&gt;  32542/TCP</span><br><span class="line">Endpoints:                172.17.0.11:80</span><br><span class="line">Session Affinity:         None</span><br><span class="line">External Traffic Policy:  Cluster</span><br><span class="line">Events:                   &lt;none&gt;</span><br></pre></td></tr></table></figure>
<p>从以上输出可以看到，nginx 服务打开了节点的 32542 端口（每个节点），我们可以通过 <code>NodeIP:NodePort</code> 访问服务。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ curl $(minikube ip):32542</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">...</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h4 id="2-6-Label"><a href="#2-6-Label" class="headerlink" title="2.6 Label"></a>2.6 Label</h4><p>Service 通过 selector &amp; label 来选取它所管理的 Pod，同样 Deployment 也是通过 selector &amp; label 选取它所管理的 Pod。因为我们是通过 Deployment 创建的 Pod，因此 Deployment 的 selector 一定是匹配 Pod 的 label。如果我们想让 Service 选择与 Deployment 相同的 Pods，我们需要将 Service 的 selector 设为与 Deployment 相同。在上面的实验中，我们使用 <code>kubectl expose deployment nginx</code> 的时候，kubernetes 默认将 Service 的 selector 设置成与 Deployment 相同的 selector。下图对 label 做了详细的标注。</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220531205504.png" style="zoom:80%;" /></p>
<p>从下面的输出可以看到，上述创建的 Deployment 和 Service 的 Selector 都是 <code>run=nginx</code>。Pod 具有 Label <code>pod-template-hash=646b46d648,run=nginx</code>，因此他们都选中了 <code>nginx-646b46d648-hbwg2</code> 这个 Pod （只要 Pod label 的子集满足即可；这里的 <code>pod-template-hash=646b46d648</code> Label 是 kubernetes 自动创建）。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl describe deployment nginx -n tutorial</span></span><br><span class="line">Name:                   nginx</span><br><span class="line">Namespace:              tutorial</span><br><span class="line">CreationTimestamp:      Fri, 28 Jun 2019 14:56:58 +0800</span><br><span class="line">Labels:                 run=nginx</span><br><span class="line">Annotations:            deployment.kubernetes.io/revision: 1</span><br><span class="line">Selector:               run=nginx</span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl describe svc nginx -n tutorial</span></span><br><span class="line">Name:                   nginx</span><br><span class="line">Namespace:              tutorial</span><br><span class="line">Labels:                 run=nginx</span><br><span class="line">Annotations:            &lt;none&gt;</span><br><span class="line">Selector:               run=nginx</span><br><span class="line">...</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl describe pods nginx-646b46d648-hbwg2 -n tutorial</span></span><br><span class="line">Name:           nginx-646b46d648-hbwg2</span><br><span class="line">Namespace:      tutorial</span><br><span class="line">Priority:       0</span><br><span class="line">Node:           minikube/10.0.2.15</span><br><span class="line">Start Time:     Fri, 28 Jun 2019 14:56:59 +0800</span><br><span class="line">Labels:         pod-template-hash=646b46d648</span><br><span class="line">                run=nginx</span><br></pre></td></tr></table></figure>
<p><strong>Label operations</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过 -l 指定标签</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pods -l run=nginx -n tutorial</span></span><br><span class="line">NAME                     READY   STATUS    RESTARTS   AGE</span><br><span class="line">nginx-646b46d648-hbwg2   1/1     Running   0          26m</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">给某个pod打标签</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pods -n tutorial</span></span><br><span class="line">NAME                     READY   STATUS    RESTARTS   AGE</span><br><span class="line">nginx-646b46d648-hbwg2   1/1     Running   0          26m</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl label pod nginx-646b46d648-hbwg2 app=v1 -n tutorial</span></span><br><span class="line">pod/nginx-646b46d648-hbwg2 labeled</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl describe pods nginx-646b46d648-hbwg2 -n tutorial</span></span><br><span class="line">Name:           nginx-646b46d648-hbwg2</span><br><span class="line">Namespace:      tutorial</span><br><span class="line">Priority:       0</span><br><span class="line">Node:           minikube/10.0.2.15</span><br><span class="line">Start Time:     Fri, 28 Jun 2019 14:56:59 +0800</span><br><span class="line">Labels:         app=v1</span><br><span class="line">                pod-template-hash=646b46d648</span><br><span class="line">                run=nginx</span><br><span class="line">Annotations:    &lt;none&gt;</span><br><span class="line">Status:         Running</span><br><span class="line">IP:             172.17.0.11</span><br><span class="line">Controlled By:  ReplicaSet/nginx-646b46d648</span><br></pre></td></tr></table></figure>
<h4 id="2-7-Deployment-Operations"><a href="#2-7-Deployment-Operations" class="headerlink" title="2.7 Deployment Operations"></a>2.7 Deployment Operations</h4><p>k8s相比于docker的一个有点就是，弹性伸缩非常的方便。并且k8s自带更新策略，也就是说当一个deployment有多个pod时，k8s会按照一定地策略来对pod做更新。</p>
<p>下图中，Deployment A 有一个 Pod 在运行，Service A 管理该 Pod。</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220531225842.png" style="zoom:80%;" /></p>
<p>通过调整 Deployment 的副本数量，我们可以将 Pod 的数量调整到 4 个。与此同时，Service 会感知到同样 label 的 Pod 被扩容到了 4 个，会将流量导到所有 Pod（而不是只有最开始的 Pod）。</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220531225917.png" style="zoom:80%;" /></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl apply -f resources/deployment_nginx -n tutorial</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl expose deployment nginx --port 80 --name=nginx -n tutorial</span></span><br></pre></td></tr></table></figure>
<p>接下来，我们可以通过 <code>kubectl scale</code> 子命令将 Pod 数量扩容到四个：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get deployments -n tutorial</span></span><br><span class="line">NAME    READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">nginx   1/1     1            1           13s</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl scale deployments nginx --replicas=4 -n tutorial</span></span><br><span class="line">deployment.extensions/nginx scaled</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get deployments -n tutorial</span></span><br><span class="line">NAME    READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">nginx   4/4     4            4           49s</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pods -n tutorial -o wide</span></span><br><span class="line">NAME                    READY   STATUS    RESTARTS   AGE   IP            NODE       NOMINATED NODE   READINESS GATES</span><br><span class="line">nginx-d6b94d6f6-lggxr   1/1     Running   0          28s   172.17.0.11   minikube   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">nginx-d6b94d6f6-lkr8m   1/1     Running   0          59s   172.17.0.8    minikube   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">nginx-d6b94d6f6-npntj   1/1     Running   0          28s   172.17.0.13   minikube   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">nginx-d6b94d6f6-rh42k   1/1     Running   0          28s   172.17.0.12   minikube   &lt;none&gt;           &lt;none&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">svc也产生相应变化</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl describe service nginx -n tutorial</span></span><br><span class="line">Name:              nginx</span><br><span class="line">Namespace:         tutorial</span><br><span class="line">Labels:            run=nginx</span><br><span class="line">Annotations:       &lt;none&gt;</span><br><span class="line">Selector:          run=nginx</span><br><span class="line">Type:              ClusterIP</span><br><span class="line">IP:                10.103.221.162</span><br><span class="line">Port:              &lt;unset&gt;  80/TCP</span><br><span class="line">TargetPort:        80/TCP</span><br><span class="line">Endpoints:         172.17.0.11:80,172.17.0.12:80,172.17.0.13:80 + 1 more...</span><br><span class="line">Session Affinity:  None</span><br><span class="line">Events:            &lt;none&gt;</span><br></pre></td></tr></table></figure>
<p>同样可以进行缩容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl scale deployments nginx --replicas=2 -n tutorial</span></span><br><span class="line">deployment.extensions/nginx scaled</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pods -n tutorial</span></span><br><span class="line">NAME                    READY   STATUS    RESTARTS   AGE</span><br><span class="line">nginx-d6b94d6f6-lkr8m   1/1     Running   0          4m58s</span><br><span class="line">nginx-d6b94d6f6-rh42k   1/1     Running   0          4m27s</span><br></pre></td></tr></table></figure>
<p><strong>Update deployment</strong></p>
<p>接下来，我们将了解 kubernetes 如何进行应用更新。见下图，我们目前有四个运行中的应用：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220531230239.png" style="zoom:80%;" /></p>
<p>当我们更新容器镜像时，kubernetes 会启动一个新 Pod 并关闭一个老 Pod。下图中，紫色的 Pod 为 kubernetes 新创建的 Pod，淡绿色 Pod 为老 Pod。Service 会停止向老 Pod 导流。</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220531230311.png" style="zoom:80%;" /></p>
<p>第一个 Pod 更新成功后，Deployment 会更新第二个 Pod。如下图所示，紫色两个 Pod 为 Deployment 创建的新 Pod。</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220531230341.png" alt=""><br>最后，Deployment 将所有的 Pod 都更新完毕。</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220531230410.png" style="zoom:80%;" /></p>
<p><strong>Update via setting image</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl <span class="built_in">set</span> image deployments nginx nginx=cargo.caicloud.io/caicloud/nginx:1.9.3 -n tutorial</span></span><br><span class="line">deployment.extensions/nginx image updated</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pods -n tutorial</span></span><br><span class="line">NAME                     READY   STATUS              RESTARTS   AGE</span><br><span class="line">nginx-d6b94d6f6-lkr8m    0/1     Terminating         0          5m58s</span><br><span class="line">nginx-d6b94d6f6-rh42k    1/1     Running             0          5m27s</span><br><span class="line">nginx-86d4667764-gxwkb   1/1     Running             0          4s</span><br><span class="line">nginx-86d4667764-hr6r7   0/1     ContainerCreating   0          2s</span><br></pre></td></tr></table></figure>
<p>分析一下上述命令，<code>kubectl set image</code> 将 Deployment 中的 nginx 镜像版本改为 1.9.3；运行该命令之后，发现 kubernetes 删掉了一个现有的 Pod，然后重新启动了两个新的 Pod（我们可以从一串数字中看出，”86d4667764” 是新 Pod 的 Hash 值，”d6b94d6f6” 是老 Pod 的 Hash 值）。等待一段时间后再次查询 Pods，发现所有新的 Pods 已经上线。整个过程中，我们都可以尝试去访问 nginx 服务，注意其版本的变化。</p>
<p><strong>Deployment rollout</strong></p>
<p>rollout 子命令可以用来查询部署的状态，以及回滚等操作。使用 <code>kubectl rollout status</code> 可以查询部署的状态。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl rollout status deployment nginx -n tutorial</span></span><br><span class="line">deployment &quot;nginx&quot; successfully rolled out</span><br></pre></td></tr></table></figure>
<p>首先，当前 nginx 处于 1.9.3 版本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl $(minikube ip):31658/version</span></span><br><span class="line">&lt;html&gt;</span><br><span class="line">...</span><br><span class="line">&lt;hr&gt;&lt;center&gt;nginx/1.9.3&lt;/center&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>上面的状态说明之前部署的 Deployment 已经正常部署了。如果我们想要回滚到之前的版本，可以使用 <code>kubectl rollout undo</code> 命令。</p>
<p>接下来使用回滚操作：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl rollout undo deployment nginx -n tutorial</span></span><br><span class="line">deployment.extensions/nginx rolled back</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pods -n tutorial</span></span><br><span class="line">NAME                     READY   STATUS    RESTARTS   AGE</span><br><span class="line">nginx-646b46d648-7c457   1/1     Running   0          9s</span><br><span class="line">nginx-646b46d648-9wpdp   1/1     Running   0          6s</span><br></pre></td></tr></table></figure>
<p>使用 rollout undo 之后，nginx 的版本回到了 set image 之前的版本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">curl $(minikube ip):31658/version</span></span><br><span class="line">&lt;html&gt;</span><br><span class="line">...</span><br><span class="line">&lt;hr&gt;&lt;center&gt;nginx/1.9.7&lt;/center&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h4 id="2-8-Yaml-Json-File"><a href="#2-8-Yaml-Json-File" class="headerlink" title="2.8 Yaml/Json File"></a>2.8 Yaml/Json File</h4><p>之前我们都是通过 kubectl 提供的快捷命令来创建、管理资源。实际上，对于 kubernetes 而言，所有的操作都是以 yaml 文件为主。我们之前所使用的命令，只是方便用户快速修改 yaml 中经常需要修改的字段。接下来，我们学习 kubernetes yaml/json 文件格式和使用方法。</p>
<p>首先，kubernetes yaml 文件的基本格式如下代码所示（这里展示的是一个 Pod 的 yaml 文件，并且有部分裁剪）。kubernetes yaml 整体分为 5 个部分：apiVersion, kind, metadata, spec, status；其中 apiVersion 表明当前 kubernetes API 的分组；kind 表明当前操作的资源类型； metadata 是资源的元数据，对于每种资源都是固定的，例如资源的名字，所处的 namespace, label 等；spec 是用户对资源的 “说明书”，即用户对资源的各种配置信息；status 是资源当前的状态，kubernetes 会尽最大努力使 spec 和 status 相匹配。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">creationTimestamp:</span> <span class="string">&quot;2019-06-28T08:16:45Z&quot;</span></span><br><span class="line">  <span class="attr">generateName:</span> <span class="string">nginx-646b46d648-</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-646b46d648-7c457</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">tutorial</span></span><br><span class="line">  <span class="attr">ownerReferences:</span></span><br><span class="line">  <span class="attr">resourceVersion:</span> <span class="string">&quot;28549&quot;</span></span><br><span class="line">  <span class="attr">selfLink:</span> <span class="string">/api/v1/namespaces/tutorial/pods/nginx-646b46d648-7c457</span></span><br><span class="line">  <span class="attr">uid:</span> <span class="string">e4312b93-9570-45a9-b981-8b26644f096c</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">  <span class="attr">dnsPolicy:</span> <span class="string">ClusterFirst</span></span><br><span class="line">  <span class="attr">enableServiceLinks:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">nodeName:</span> <span class="string">minikube</span></span><br><span class="line">  <span class="attr">priority:</span> <span class="number">0</span></span><br><span class="line">  <span class="attr">restartPolicy:</span> <span class="string">Always</span></span><br><span class="line">  <span class="attr">schedulerName:</span> <span class="string">default-scheduler</span></span><br><span class="line">  <span class="attr">securityContext:</span> &#123;&#125;</span><br><span class="line">  <span class="attr">serviceAccount:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">serviceAccountName:</span> <span class="string">default</span></span><br><span class="line">  <span class="attr">terminationGracePeriodSeconds:</span> <span class="number">30</span></span><br><span class="line">  <span class="attr">tolerations:</span></span><br><span class="line">  <span class="attr">volumes:</span></span><br><span class="line"><span class="attr">status:</span></span><br><span class="line">  <span class="attr">conditions:</span></span><br><span class="line">  <span class="attr">containerStatuses:</span></span><br><span class="line">  <span class="attr">hostIP:</span> <span class="number">10.0</span><span class="number">.2</span><span class="number">.15</span></span><br><span class="line">  <span class="attr">phase:</span> <span class="string">Running</span></span><br><span class="line">  <span class="attr">podIP:</span> <span class="number">172.17</span><span class="number">.0</span><span class="number">.8</span></span><br><span class="line">  <span class="attr">qosClass:</span> <span class="string">Burstable</span></span><br><span class="line">  <span class="attr">startTime:</span> <span class="string">&quot;2019-06-28T08:16:46Z&quot;</span></span><br></pre></td></tr></table></figure>
<p><strong>Get resource yaml</strong></p>
<p>用户可以通过 kubectl get -o yaml 来获取已经部署的资源的 Yaml 文件，我们可以尝试获取之前通过 <code>kubectl apply</code>, <code>kubectl expose</code> 等命令部署的 Deployment 和 Service。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pods nginx-646b46d648-7c457 -n tutorial -o yaml</span></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  creationTimestamp: &quot;2019-06-28T08:16:45Z&quot;</span><br><span class="line">  generateName: nginx-646b46d648-</span><br><span class="line">...</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - image: cargo.caicloud.io/caicloud/nginx:1.9.7</span><br><span class="line">    imagePullPolicy: IfNotPresent</span><br><span class="line">    name: nginx</span><br><span class="line">    resources:</span><br><span class="line">      limits:</span><br><span class="line">        cpu: 200m</span><br><span class="line">        memory: 512Mi</span><br><span class="line">      requests:</span><br><span class="line">        cpu: 100m</span><br><span class="line">        memory: 256Mi</span><br><span class="line">...</span><br><span class="line">status:</span><br><span class="line">  hostIP: 10.0.2.15</span><br><span class="line">  phase: Running</span><br><span class="line">  podIP: 172.17.0.8</span><br><span class="line">  qosClass: Burstable</span><br><span class="line">  startTime: &quot;2019-06-28T08:16:46Z&quot;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get svc nginx -n tutorial -o yaml</span></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  creationTimestamp: &quot;2019-06-28T08:13:20Z&quot;</span><br><span class="line">  labels:</span><br><span class="line">    run: nginx</span><br><span class="line">  name: nginx</span><br><span class="line">  namespace: tutorial</span><br><span class="line">  resourceVersion: &quot;28252&quot;</span><br><span class="line">  selfLink: /api/v1/namespaces/tutorial/services/nginx</span><br><span class="line">  uid: 4586f1da-59bf-4c9c-90fb-1d4974a0e04e</span><br><span class="line">spec:</span><br><span class="line">  clusterIP: 10.103.177.222</span><br><span class="line">  externalTrafficPolicy: Cluster</span><br><span class="line">  ports:</span><br><span class="line">  - nodePort: 31658</span><br><span class="line">    port: 80</span><br><span class="line">    protocol: TCP</span><br><span class="line">    targetPort: 80</span><br><span class="line">  selector:</span><br><span class="line">    run: nginx</span><br><span class="line">  sessionAffinity: None</span><br><span class="line">  type: NodePort</span><br><span class="line">status:</span><br><span class="line">  loadBalancer: &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>通过修改yaml文件可以修改资源的信息，这里不过多展开，即用即查。</p>
<h4 id="2-9-Events"><a href="#2-9-Events" class="headerlink" title="2.9 Events"></a>2.9 Events</h4><p>Kubernetes events 显示了 kubernetes 集群中所有的事件。不同于其他资源，kubernetes events 并不是由用户创建的资源，而是由 kubernetes 系统组件创建，用以提示用户集群发生的各种事件。我们可以通过 kubectl get 命令来查询集群的事件。默认情况下，event 会有 TTL，超过 TTL 之后 kubernetes 会将事件删掉。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get events -n tutorial</span></span><br><span class="line">LAST SEEN   TYPE     REASON              OBJECT                        MESSAGE</span><br><span class="line">12m         Normal   Scheduled           pod/nginx-646b46d648-7c457    Successfully assigned tutorial/nginx-646b46d648-7c457 to minikube</span><br><span class="line">12m         Normal   Pulled              pod/nginx-646b46d648-7c457    Container image &quot;cargo.caicloud.io/caicloud/nginx:1.9.7&quot; already present on machine</span><br><span class="line">12m         Normal   Created             pod/nginx-646b46d648-7c457    Created container nginx</span><br><span class="line">12m         Normal   Started             pod/nginx-646b46d648-7c457    Started container nginx</span><br><span class="line">50m         Normal   Scheduled           pod/nginx-646b46d648-8kbk9    Successfully assigned tutorial/nginx-646b46d648-8kbk9 to minikube</span><br><span class="line">50m         Normal   Pulled              pod/nginx-646b46d648-8kbk9    Container image &quot;cargo.caicloud.io/caicloud/nginx:1.9.7&quot; already present on machine</span><br><span class="line">50m         Normal   Created             pod/nginx-646b46d648-8kbk9    Created container nginx</span><br><span class="line">50m         Normal   Started             pod/nginx-646b46d648-8kbk9    Started container nginx</span><br><span class="line">49m         Normal   Killing             pod/nginx-646b46d648-8kbk9    Stopping container nginx</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>Event 与资源是相联系的，因此单独查询 Event 并不是非常有用，我们可以通过获取资源的详细信息来查看 Event 信息。例如， <code>kubectl describe pod &lt;pod name&gt;</code> 会返回 Pod 的 event 信息。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl describe pod nginx -n tutorial</span></span><br><span class="line">Name:         nginx</span><br><span class="line">Namespace:    tutorial</span><br><span class="line">Priority:     0</span><br><span class="line">Node:         minikube/10.0.2.15</span><br><span class="line">Start Time:   Fri, 28 Jun 2019 16:25:42 +0800</span><br><span class="line">Labels:       &lt;none&gt;</span><br><span class="line">...</span><br><span class="line">Events:</span><br><span class="line">  Type    Reason     Age                   From               Message</span><br><span class="line">  ----    ------     ----                  ----               -------</span><br><span class="line">  Normal  Scheduled  4m20s                 default-scheduler  Successfully assigned tutorial/nginx to minikube</span><br><span class="line">  Normal  Pulled     3m22s                 kubelet, minikube  Container image &quot;cargo.caicloud.io/caicloud/nginx:1.9.7&quot; already present on machine</span><br><span class="line">  Normal  Pulled     101s (x2 over 4m19s)  kubelet, minikube  Container image &quot;cargo.caicloud.io/caicloud/nginx:1.9.3&quot; already present on machine</span><br><span class="line">  Normal  Created    101s (x3 over 4m19s)  kubelet, minikube  Created container nginx</span><br><span class="line">  Normal  Started    101s (x3 over 4m18s)  kubelet, minikube  Started container nginx</span><br><span class="line">  Normal  Killing    101s (x2 over 3m23s)  kubelet, minikube  Container nginx definition changed, will be restarted</span><br></pre></td></tr></table></figure>
<h4 id="2-10-Pod-Lifecycle"><a href="#2-10-Pod-Lifecycle" class="headerlink" title="2.10 Pod Lifecycle"></a>2.10 Pod Lifecycle</h4><p>Pod 生命周期主要包括：</p>
<ul>
<li>Pod Phase</li>
<li>Pod Condition</li>
<li>Restart Policy</li>
<li>Container probes</li>
</ul>
<p>用户可以通过 <code>kubectl describe pods</code> 查看以上所有信息。Pod Phase 和 Pod Condition 比较简单，我们可以实时看到 kubernetes 的反馈。这里我们主要实践 Restart Policy 和 Container probes。</p>
<p><strong>Restart policy</strong></p>
<p>Restart Policy 指定当 Pod 内容器出错或执行完毕后，是否重启。下面的 Pod 使用了 debian 镜像，该镜像并不会长期运行，因此如果我们直接创建，kubernetes 会认为 Pod 出错。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl create -f resources/debian.yaml -n tutorial</span></span><br><span class="line">pod/debian created</span><br></pre></td></tr></table></figure>
<p>注，若提示资源不足，可以删掉现有的 Deployment 或 Pod 资源。创建之后，等待 kubernetes 拉取镜像。几分钟后， kubernetes 提示 redis-django 进入 Crash 状态，且有多次重启：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pods -n tutorial</span></span><br><span class="line">NAME                     READY   STATUS             RESTARTS   AGE</span><br><span class="line">debian                   0/1     CrashLoopBackOff   1          32s</span><br><span class="line">nginx                    1/1     Running            2          14m</span><br><span class="line">nginx-646b46d648-7c457   1/1     Running            0          23m</span><br><span class="line">nginx-646b46d648-9wpdp   1/1     Running            0          23m</span><br></pre></td></tr></table></figure>
<p>现在，我们为该 Pod 添加 Restart Policy，使 kubernetes 不再不断重启 debian 容器，从而得到以下结果：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl delete pods debian -n tutorial</span></span><br><span class="line">pod &quot;debian&quot; deleted</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl create -f resources/debian_never_restart.yaml -n tutorial</span></span><br><span class="line">pod &quot;debian&quot; created</span><br></pre></td></tr></table></figure>
<p>debian 容器变成 <code>Completed</code> 状态：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pods -n tutorial</span></span><br><span class="line">NAME                     READY   STATUS      RESTARTS   AGE</span><br><span class="line">debian                   0/1     Completed   0          33s</span><br><span class="line">nginx                    1/1     Running     2          15m</span><br><span class="line">nginx-646b46d648-7c457   1/1     Running     0          24m</span><br><span class="line">nginx-646b46d648-9wpdp   1/1     Running     0          24m</span><br></pre></td></tr></table></figure>
<p><strong>Container probes</strong></p>
<p>Container probes 分为两种：LivenessProbe 和 ReadinessProbe。Liveness 检查应用是否依然健康无错，若有错，则 kubernetes 会根据 policy 重启或仅更新状态。ReadinessCheck 检查应用是否可以对外提供服务，若应用 Readiness 检查不通过，则 kubernetes 会将 Pod 从服务池中剔除。两者的使用方法都相同，这里我们来看看 Container probes。</p>
<p>打开 <a href="https://github.com/caicloud/kube-ladder/blob/master/tutorials/resources/pod_health.yaml">pod_health.yaml</a>，可以看到里面定义了 livenessProbe。当我们运行创建该 Pod 的时候，kubernetes 就开始为我们监控该 Pod 的 liveness 信息。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl delete pods nginx -n tutorial</span></span><br><span class="line">pod &quot;nginx&quot; deleted</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl create -f resources/pod_health.yaml -n tutorial</span></span><br><span class="line">pod &quot;nginx&quot; created</span><br></pre></td></tr></table></figure>
<p>Pod 会一直处于 Running 状态：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pods -n tutorial</span></span><br><span class="line">NAME                     READY     STATUS    RESTARTS   AGE</span><br><span class="line">nginx                    1/1     Running     0          7s</span><br><span class="line">nginx-646b46d648-7c457   1/1     Running     0          29m</span><br><span class="line">nginx-646b46d648-9wpdp   1/1     Running     0          29m</span><br></pre></td></tr></table></figure>
<p>我们可以分别尝试将 livenessProbe 的 http 80 端口改为 8080，观察 Pod 的状态。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl delete pods nginx -n tutorial</span></span><br><span class="line">pod &quot;nginx&quot; deleted</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl create -f resources/pod_unhealth.yaml -n tutorial</span></span><br><span class="line">pod &quot;nginx&quot; created</span><br></pre></td></tr></table></figure>
<p>Pod 会首先处于 Running 状态，但是在经过一段时间之后，Pod 会变为 Crash 状态，事件里会汇报健康检查错误：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl describe pod nginx -n tutorial</span></span><br><span class="line">Name:         nginx</span><br><span class="line">Namespace:    tutorial</span><br><span class="line">Priority:     0</span><br><span class="line">Node:         minikube/10.0.2.15</span><br><span class="line">Start Time:   Fri, 28 Jun 2019 16:46:22 +0800</span><br><span class="line">Labels:       app=nginx</span><br><span class="line">Annotations:  &lt;none&gt;</span><br><span class="line">Status:       Running</span><br><span class="line">IP:           172.17.0.11</span><br><span class="line">Containers:</span><br><span class="line">  nginx:</span><br><span class="line">    ...</span><br><span class="line">    Liveness:     http-get http://:8080/ delay=5s timeout=1s period=5s #success=1 #failure=3</span><br><span class="line">...</span><br><span class="line">Events:</span><br><span class="line">  Type     Reason     Age              From               Message</span><br><span class="line">  ----     ------     ----             ----               -------</span><br><span class="line">  Normal   Scheduled  14s              default-scheduler  Successfully assigned tutorial/nginx to minikube</span><br><span class="line">  Normal   Pulled     13s              kubelet, minikube  Container image &quot;cargo.caicloud.io/caicloud/nginx:1.9.7&quot; already present on machine</span><br><span class="line">  Normal   Created    13s              kubelet, minikube  Created container nginx</span><br><span class="line">  Normal   Started    13s              kubelet, minikube  Started container nginx</span><br><span class="line">  Warning  Unhealthy  3s (x2 over 8s)  kubelet, minikube  Liveness probe failed: Get http://172.17.0.11:8080/: dial tcp 172.17.0.11:8080: connect: connection refused</span><br></pre></td></tr></table></figure>
<h4 id="2-11-ConfigMap-amp-Secret"><a href="#2-11-ConfigMap-amp-Secret" class="headerlink" title="2.11 ConfigMap &amp; Secret"></a>2.11 ConfigMap &amp; Secret</h4><p>ConfigMap 是 kubernetes 用来管理配置信息的资源类型。我们通过单独创建 ConfigMap，再将 ConfigMap 挂载到 Pod 内的方式分离配置和应用。我们通过一个实验来学习如何正确使用 ConfigMap。</p>
<p>创建 ConfigMap 可以通过 yaml 文件，也可以从文件直接创建。通过 yaml 文件的方式与创建其他资源类似。这里，我们采用文件的方式。在 <code>resources</code> 目录下，有两个文件：<a href="https://github.com/caicloud/kube-ladder/blob/master/tutorials/resources/game.properties">game.properties</a> 和 <a href="https://github.com/caicloud/kube-ladder/blob/master/tutorials/resources/ui.properties">ui.properties</a>。我们通过 kubectl 命令创建：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl create configmap game-config --from-file=resources/game.properties --from-file=resources/ui.properties -n tutorial</span></span><br><span class="line">configmap/game-config created</span><br></pre></td></tr></table></figure>
<p>创建之后，通过 kubectl get configmap 来查看创建的 ConfigMap：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get configmap game-config -o wide -n tutorial</span></span><br><span class="line">NAME          DATA      AGE</span><br><span class="line">game-config   2         2m</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl describe configmap game-config -n tutorial</span></span><br><span class="line">Name:         game-config</span><br><span class="line">Namespace:    tutorial</span><br><span class="line">Labels:       &lt;none&gt;</span><br><span class="line">Annotations:  &lt;none&gt;</span><br><span class="line"></span><br><span class="line">Data</span><br><span class="line">====</span><br><span class="line">game.properties:</span><br><span class="line">----</span><br><span class="line">enemies=aliens</span><br><span class="line">lives=3</span><br><span class="line">enemies.cheat=true</span><br><span class="line">enemies.cheat.level=noGoodRotten</span><br><span class="line">secret.code.passphrase=UUDDLRLRBABAS</span><br><span class="line">secret.code.allowed=true</span><br><span class="line">secret.code.lives=30</span><br><span class="line">ui.properties:</span><br><span class="line">----</span><br><span class="line">color.good=purple</span><br><span class="line">color.bad=yellow</span><br><span class="line">allow.textmode=true</span><br><span class="line">how.nice.to.look=fairlyNice</span><br><span class="line">Events:  &lt;none&gt;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看详情</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get configmap game-config -o yaml -n tutorial</span></span><br><span class="line">apiVersion: v1</span><br><span class="line">data:</span><br><span class="line">  game.properties: |-</span><br><span class="line">    enemies=aliens</span><br><span class="line">    lives=3</span><br><span class="line">    enemies.cheat=true</span><br><span class="line">    enemies.cheat.level=noGoodRotten</span><br><span class="line">    secret.code.passphrase=UUDDLRLRBABAS</span><br><span class="line">    secret.code.allowed=true</span><br><span class="line">    secret.code.lives=30</span><br><span class="line">  ui.properties: |-</span><br><span class="line">    color.good=purple</span><br><span class="line">    color.bad=yellow</span><br><span class="line">    allow.textmode=true</span><br><span class="line">    how.nice.to.look=fairlyNice</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  creationTimestamp: &quot;2019-06-28T08:49:20Z&quot;</span><br><span class="line">  name: game-config</span><br><span class="line">  namespace: tutorial</span><br><span class="line">  resourceVersion: &quot;31335&quot;</span><br><span class="line">  selfLink: /api/v1/namespaces/tutorial/configmaps/game-config</span><br><span class="line">  uid: 134781b7-5565-4037-b0b2-be42767255a0</span><br></pre></td></tr></table></figure>
<p>创建 ConfigMap 之后，我们可以创建 Pod 来使用该 ConfigMap：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl create -f resources/pod_configmap.yaml -n tutorial</span></span><br><span class="line">pod/pod-configmap created</span><br></pre></td></tr></table></figure>
<p>查看：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pods -n tutorial</span></span><br><span class="line">NAME                     READY     STATUS             RESTARTS   AGE</span><br><span class="line">pod-configmap            0/1       Completed          0          2m</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl logs pod-configmap -n tutorial</span></span><br><span class="line">enemies=aliens</span><br><span class="line">lives=3</span><br><span class="line">enemies.cheat=true</span><br><span class="line">enemies.cheat.level=noGoodRotten</span><br><span class="line">secret.code.passphrase=UUDDLRLRBABAS</span><br><span class="line">secret.code.allowed=true</span><br><span class="line">secret.code.lives=30color.good=purple</span><br><span class="line">color.bad=yellow</span><br><span class="line">allow.textmode=true</span><br><span class="line">how.nice.to.look=fairlyNice</span><br></pre></td></tr></table></figure>
<p>这里我们看到了通过挂载文件的方式使用 configmap，kubernetes 同时也支持通过环境变量的方式使用 configmap。此外，Secret 的使用方式与 Configmap 类似，但内容会被加密。</p>
<h2 id="修炼感想"><a href="#修炼感想" class="headerlink" title="修炼感想"></a>修炼感想</h2><p>本阶段主要学会如何访问各种资源即可，切记不要试图去理解k8s的架构，因为太过庞大，贸然学习容易被反噬！切记！在炼气期所学，皆是一些花拳绣腿，如何做出一些动作。但是这些招式打出去软绵无力，毫无内功。在接下来的修炼之路上，要不断修炼内容，明白原理，这样在面对敌人时方可游刃有余。</p>
]]></content>
      <categories>
        <category>k8s</category>
        <category>kube-ladder</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>kube-ladder</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-V2-29-顺时针打印矩阵</title>
    <url>/2022/11/14/%E5%89%91%E6%8C%87offer-V2-29-%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<h1 id="剑指offer-V2-29-顺时针打印矩阵"><a href="#剑指offer-V2-29-顺时针打印矩阵" class="headerlink" title="剑指offer-V2-29-顺时针打印矩阵"></a>剑指offer-V2-29-顺时针打印矩阵</h1><p><a href="https://leetcode.cn/problems/shun-shi-zhen-da-yin-ju-zhen-lcof/description/?favorite=xb9nqhhg">原题点这里</a></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202211141017019.png" alt=""></p>
<span id="more"></span>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>设置上下左右边界，每次添加完一行或者一列时，更新边界。</p>
<h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>正常模拟，当把所有元素都访问到时跳出循环。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">spiralOrder</span><span class="params">(matrix [][]<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(matrix) == <span class="number">0</span> || <span class="built_in">len</span>(matrix[<span class="number">0</span>]) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	right := <span class="built_in">len</span>(matrix[<span class="number">0</span>]) - <span class="number">1</span></span><br><span class="line">	bottom := <span class="built_in">len</span>(matrix) - <span class="number">1</span></span><br><span class="line">	left := <span class="number">0</span></span><br><span class="line">	top := <span class="number">0</span></span><br><span class="line">	ret := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> i := left; i &lt;= right; i++ &#123;</span><br><span class="line">			ret = <span class="built_in">append</span>(ret, matrix[top][i])</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> top++; top &gt; bottom &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> i := top; i &lt;= bottom; i++ &#123;</span><br><span class="line">			ret = <span class="built_in">append</span>(ret, matrix[i][right])</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> right--; right &lt; left &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> i := right; i &gt;= left; i-- &#123;</span><br><span class="line">			ret = <span class="built_in">append</span>(ret, matrix[bottom][i])</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> bottom--; bottom &lt; top &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> i := bottom; i &gt;= top; i-- &#123;</span><br><span class="line">			ret = <span class="built_in">append</span>(ret, matrix[i][left])</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> left++; left &gt; right &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">spiralOrder</span><span class="params">(matrix [][]<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(matrix) == <span class="number">0</span> || <span class="built_in">len</span>(matrix[<span class="number">0</span>]) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 四个方向分别对应：右、下、左、上</span></span><br><span class="line">	dirs := [][]<span class="type">int</span>&#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;&#125;</span><br><span class="line">	dirInx := <span class="number">0</span></span><br><span class="line">	visited := <span class="number">10000</span></span><br><span class="line">	ret := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">var</span> isIdxValid <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span></span><br><span class="line">	isIdxValid = <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> i &gt;= <span class="number">0</span> &amp;&amp; i &lt; <span class="built_in">len</span>(matrix) &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; j &lt; <span class="built_in">len</span>(matrix[<span class="number">0</span>])</span><br><span class="line">	&#125;</span><br><span class="line">	i, j := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">	ret = <span class="built_in">append</span>(ret, matrix[i][j])</span><br><span class="line">	matrix[i][j] = visited</span><br><span class="line">	cnt := <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> cnt &lt; <span class="built_in">len</span>(matrix)*<span class="built_in">len</span>(matrix[<span class="number">0</span>]) &#123;</span><br><span class="line">		dir := dirs[dirInx]</span><br><span class="line">		nI, nJ := i+dir[<span class="number">0</span>], j+dir[<span class="number">1</span>]</span><br><span class="line">		<span class="keyword">if</span> !isIdxValid(nI, nJ) || matrix[nI][nJ] == visited &#123;</span><br><span class="line">			dirInx = (dirInx + <span class="number">1</span>) % <span class="number">4</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			i, j = nI, nJ</span><br><span class="line">			ret = <span class="built_in">append</span>(ret, matrix[i][j])</span><br><span class="line">			matrix[i][j] = visited</span><br><span class="line">			cnt++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>offer</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-V2-30-包含min函数的栈</title>
    <url>/2022/11/14/%E5%89%91%E6%8C%87offer-V2-30-%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88/</url>
    <content><![CDATA[<h1 id="剑指offer-V2-30-包含min函数的栈"><a href="#剑指offer-V2-30-包含min函数的栈" class="headerlink" title="剑指offer-V2-30-包含min函数的栈"></a>剑指offer-V2-30-包含min函数的栈</h1><p><a href="https://leetcode.cn/problems/bao-han-minhan-shu-de-zhan-lcof/description/?favorite=xb9nqhhg">原题点这里</a></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202211141042947.png" alt=""></p>
<span id="more"></span>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>使用两个栈，一个栈正常用于保存数据，另一个栈用于保存非严格降序。入栈时，数据栈正常入栈，如果当前元素小于等于降序栈栈顶元素，降序栈入栈；出栈时，如果降序栈栈顶元素等于数据栈栈顶元素，降序栈出栈，数据栈正常出栈。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MinStack <span class="keyword">struct</span> &#123;</span><br><span class="line">	stack []<span class="type">int</span></span><br><span class="line">	desc  []<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** initialize your data structure here. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span></span> MinStack &#123;</span><br><span class="line">	<span class="keyword">return</span> MinStack&#123;</span><br><span class="line">		stack: <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>),</span><br><span class="line">		desc:  <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span></span> Push(x <span class="type">int</span>) &#123;</span><br><span class="line">	this.stack = <span class="built_in">append</span>(this.stack, x)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(this.desc) == <span class="number">0</span> || x &lt;= this.desc[<span class="built_in">len</span>(this.desc)<span class="number">-1</span>] &#123;</span><br><span class="line">		this.desc = <span class="built_in">append</span>(this.desc, x)</span><br><span class="line">		<span class="keyword">return</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span></span> Pop() &#123;</span><br><span class="line">	tmp := this.stack[<span class="built_in">len</span>(this.stack)<span class="number">-1</span>]</span><br><span class="line">	<span class="keyword">if</span> tmp == this.desc[<span class="built_in">len</span>(this.desc)<span class="number">-1</span>] &#123;</span><br><span class="line">		this.desc = this.desc[:<span class="built_in">len</span>(this.desc)<span class="number">-1</span>]</span><br><span class="line">	&#125;</span><br><span class="line">	this.stack = this.stack[:<span class="built_in">len</span>(this.stack)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span></span> Top() <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> this.stack[<span class="built_in">len</span>(this.stack)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MinStack)</span></span> Min() <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> this.desc[<span class="built_in">len</span>(this.desc)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MinStack object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * obj := Constructor();</span></span><br><span class="line"><span class="comment"> * obj.Push(x);</span></span><br><span class="line"><span class="comment"> * obj.Pop();</span></span><br><span class="line"><span class="comment"> * param_3 := obj.Top();</span></span><br><span class="line"><span class="comment"> * param_4 := obj.Min();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>offer</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>offer</tag>
      </tags>
  </entry>
  <entry>
    <title>K8S修炼之路-2.筑基期-Etcd in Kubernetes</title>
    <url>/2022/11/14/K8S%E4%BF%AE%E7%82%BC%E4%B9%8B%E8%B7%AF-2-%E7%AD%91%E5%9F%BA%E6%9C%9F-Etcd-in-Kubernetes/</url>
    <content><![CDATA[<h1 id="Etcd-in-Kubernetes"><a href="#Etcd-in-Kubernetes" class="headerlink" title="Etcd in Kubernetes"></a>Etcd in Kubernetes</h1><p>本阶段学习etcd与kubernetes，简单来说kubernetes可以看作一个应用，任何一个应用都要有数据库，kubernetes也不例外，而etcd就是kubernetes的数据库。</p>
<p>虽然etcd作为数据库是kubernetes的核心，但是在生产环境中并不直接和etcd打交道，而是通过API来操作资源。</p>
<p>这篇心法将介绍，etcd是如何工作的、工作流程及原理如何，以及在kubernetes中如何用到了etcd。<br><span id="more"></span></p>
<h2 id="1-k8s为啥要etcd？"><a href="#1-k8s为啥要etcd？" class="headerlink" title="1. k8s为啥要etcd？"></a>1. k8s为啥要etcd？</h2><p>一个Kuberbetes的集群从high level的层面来说，有三种不同类别的control-plane processes：</p>
<ul>
<li><strong>Centralized controllers</strong>：比如secheduler，controller-manager以及third-party controllers，用来配置pods和其他资源。</li>
<li><strong>Node-specific processes</strong>：最重要的一个是kubelet，用于处理根据配置来创建pod。</li>
<li><strong>API server</strong>：用来协调control plane processes和nodes。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220606164628.png" style="zoom:80%;" /></p>
<p>每一个node都有kubelet，相当于是一个包工头，负责创建容器、挂载卷等任务。API是内部controller来联系kubelet的中介。</p>
<p>关于API server，其实工作量很少。当一个用户调用API时，API server:</p>
<ol>
<li>（用RBAC）来决定这次API调用是否被授权。</li>
<li>可能通过改变 webhook 更改 API 调用的负载。</li>
<li>判断负载是否有效。</li>
<li>将API负载持久化，并且返回请求信息。</li>
<li>可能会通知 API 端点的订阅者对象已更改。</li>
</ol>
<p>现在假设使用如下命令来部署三个Pod:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl apply -f deployment.yaml</span></span><br></pre></td></tr></table></figure>
<p>之后API server就会接收到这条请求，然后验证请求合法性，接着会将该deployment的定义保存到etcd中。</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220606170311.png" style="zoom:80%;" /></p>
<p>之后发生的任何事情都是由controllers以及node-specific processes来完成的，比如根据deployment决定需要运行哪些pod，每一个pod要调度运行在哪一个node上，设置networking等等。</p>
<p>在etcd中添加了该deployment之后，controller manager就会注意到来了新的资源。</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220606170753.png" style="zoom:80%;" /></p>
<p>然后Deployment and ReplicaSet controllers会在etcd中保存pods的信息。</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220606170846.png" style="zoom:80%;" /></p>
<p>从架构上抽象地来讲，API server就是一个CRUD的应用，对于这种应用来讲，总要有个数据库的支撑，那就是etcd了。</p>
<h2 id="2-为什么选择etcd"><a href="#2-为什么选择etcd" class="headerlink" title="2. 为什么选择etcd?"></a>2. 为什么选择etcd?</h2><p>数据库千千万，为何kubernetes选择了etcd作为数据库？能不能用Mysql或者PostgreSQL？答案是可以的，mysql或pg并不能最好的满足k8s的需求。问题就来了，k8s需要什么样的数据库呢？</p>
<h3 id="2-1-Consistency"><a href="#2-1-Consistency" class="headerlink" title="2.1 Consistency"></a>2.1 Consistency</h3><p>k8s的集群是分布式的，因此API server要求数据库必须保持强一致性。</p>
<h3 id="2-2-Availability"><a href="#2-2-Availability" class="headerlink" title="2.2 Availability"></a>2.2 Availability</h3><p>如果API server down了，那么整个k8s control plane就down了，因此数据库需要高可用。尽管不可能达到100%可用，但要尽量缩短downtime。</p>
<h3 id="2-3-Consistent-Performance"><a href="#2-3-Consistent-Performance" class="headerlink" title="2.3 Consistent Performance"></a>2.3 Consistent Performance</h3><p>API server可能同一时刻会接收到大量请求，因此性能也很重要。</p>
<h3 id="2-4-Change-Notification"><a href="#2-4-Change-Notification" class="headerlink" title="2.4 Change Notification"></a>2.4 Change Notification</h3><p>由于 API  server充当许多不同类型客户端之间的集中协调器，因此当数据库发生改变时，需要notification。</p>
<h3 id="2-5-Other-considerations"><a href="#2-5-Other-considerations" class="headerlink" title="2.5 Other considerations"></a>2.5 Other considerations</h3><p>上面是API server数据库需要的，下面这些是它不需要的：</p>
<ul>
<li><strong>Large Datasets</strong>：API server只保存pods等object的metadata，因此就算是一个很大的集群，metadata加起来可能会有几百兆，多一点几个G，但绝对达不到TB的量级。</li>
<li><strong>Complex Queries：</strong> k8s的API访问模式相对固定，一般通过类型，namespace或者name来获取，因此不需要很复杂的query。</li>
</ul>
<p>对于传统数据库来说，通常会在large datasets和complex queries上做很多优化，往往忽略了高可用和性能，而这恰恰不是k8s需要的，所以并不适合k8s。</p>
<h2 id="3-Etcd到底是啥？"><a href="#3-Etcd到底是啥？" class="headerlink" title="3 Etcd到底是啥？"></a>3 Etcd到底是啥？</h2><p><a href="https://etcd.io/">Etcd</a>，是一个强一致性、分布式的key-value数据库。</p>
<ul>
<li><strong>强一致性</strong>：etcd具有严格的可串行化，这意味着一致的全局事件排序。也就是说，在一个客户端完成写之后，其余客户端读到的一定是写过之后的新值。</li>
<li><strong>分布式</strong>：和传统数据库不一样，etcd是设计成为不同node服务的数据库，也就是说有着高可用性。</li>
<li><strong>key-value</strong>：etcd的数据模型比较简单，采用key-value存储。</li>
</ul>
<p>除此之外，etcd一个最不一样的地方在于，k8s需要大量使用change notifications。etcd可以让客户端知道，哪一个或哪几个key发生了变化。</p>
<p>因为这些特性，k8s选择了etcd。当然了，不只etcd有这些特性，像<a href="https://zookeeper.apache.org/">Apache ZooKeeper</a> 和 <a href="https://www.consul.io/">HashiCorpConsul</a>也有着相同特性。</p>
<h2 id="4-Etcd原理"><a href="#4-Etcd原理" class="headerlink" title="4 Etcd原理"></a>4 Etcd原理</h2><p>etcd之所以能够保持强一致性和高可用，是因为Raft算法。Raft算法解决的问题：多个独立的进程访问同一个数据的问题。这个问题叫做distributed consensus，相应的揭发还有一种叫Paxos算法，但是比较复杂并且实现起来困难。那Raft的优点就是简单理解，实现方便。关于Raft算法的流程以及原理可以参考这里，<a href="http://thesecretlivesofdata.com/raft/">http://thesecretlivesofdata.com/raft/</a> ，按照这个图理解一遍应该就没问题了。 </p>
<p>通过上面链接中的动画演示，我们应该明白etcd集群中节点有哪些状态，节点间如何选举Leader，有了leader之后如何进行进行保持数据一致性的写操作。</p>
<p>简单总结一下Raft的流程：</p>
<p>首先应该明白在任意时刻，一个etcd集群应该有一个Leader，然后数据写操作应该是这么个流程：</p>
<ol>
<li>首先客户端向etcd集群中的任一节点发送写请求。</li>
<li>如果该节点恰好是leader，那么执行该写操作，并且将此次更新同步到其他节点的日志，日志更新后，在执行真正的写操作。</li>
<li>如果该节点是follower，那么要先将该请求转发到Leader，然后参考步骤2。</li>
<li>写操作完成后，向客户端返回ACK。</li>
</ol>
<p>如果etcd集群的leader由于某种原因掉线了，那么就要进行新一轮的选举，并且在大多数节点同意之后，才能选举成功。</p>
<p>etcd尽可能的保持了节点的可用，也就是说允许有节点是不可用的，那么底线在哪里？答案是看情况，大致可以参考：</p>
<p><img src="https://raw.githubusercontent.com/foursevenlove/gitResource/master/Typora20220606221330.png" style="zoom:80%;" /></p>
<p>通过观察可以看出，并不是说总节点数越多，可用性就越强。当节点数为3和4时，都只最多允许一个节点不可用，也就是说可用性是一样的。因此，etcd集群中节点数目通常采取奇数。</p>
<p>那么一个集群中应该设置多少个节点？答案还是看情况，这是一个tradeofff，可以说当节点数增加，有可能提高可用性，但是为了保持一致性，性能就会下降。一般来讲设置3个或5个。</p>
<h2 id="5-Etcd使用"><a href="#5-Etcd使用" class="headerlink" title="5. Etcd使用"></a>5. Etcd使用</h2><h3 id="5-1-安装及基本使用"><a href="#5-1-安装及基本使用" class="headerlink" title="5.1 安装及基本使用"></a>5.1 安装及基本使用</h3><p>Etcd提供了下载脚本，<a href="https://github.com/etcd-io/etcd/releases/，只要拷贝命令放在脚本里执行就好：">https://github.com/etcd-io/etcd/releases/，只要拷贝命令放在脚本里执行就好：</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ETCD_VER=v3.5.4</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">choose either URL</span></span><br><span class="line">GOOGLE_URL=https://storage.googleapis.com/etcd</span><br><span class="line">GITHUB_URL=https://github.com/etcd-io/etcd/releases/download</span><br><span class="line">DOWNLOAD_URL=$&#123;GOOGLE_URL&#125;</span><br><span class="line"></span><br><span class="line">rm -f /tmp/etcd-$&#123;ETCD_VER&#125;-linux-amd64.tar.gz</span><br><span class="line">rm -rf /tmp/etcd-download-test &amp;&amp; mkdir -p /tmp/etcd-download-test</span><br><span class="line"></span><br><span class="line">curl -L $&#123;DOWNLOAD_URL&#125;/$&#123;ETCD_VER&#125;/etcd-$&#123;ETCD_VER&#125;-linux-amd64.tar.gz -o /tmp/etcd-$&#123;ETCD_VER&#125;-linux-amd64.tar.gz</span><br><span class="line">tar xzvf /tmp/etcd-$&#123;ETCD_VER&#125;-linux-amd64.tar.gz -C /tmp/etcd-download-test --strip-components=1</span><br><span class="line">rm -f /tmp/etcd-$&#123;ETCD_VER&#125;-linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line">/tmp/etcd-download-test/etcd --version</span><br><span class="line">/tmp/etcd-download-test/etcdctl version</span><br><span class="line">/tmp/etcd-download-test/etcdutl version</span><br></pre></td></tr></table></figure>
<p>装好之后其实装了三个东西：</p>
<ul>
<li><strong>etcd</strong>：用于运行etcd server</li>
<li><strong>etcdctl</strong>：用于和server进行交互</li>
<li><strong>etcdutl</strong>：用于备份之类的操作</li>
</ul>
<p>直接使用etcd命令就可以启动一个单节点的etcd集群：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./etcd</span></span><br><span class="line">...</span><br><span class="line">&#123;&quot;level&quot;:&quot;info&quot;,&quot;caller&quot;:&quot;etcdserver/server.go:2027&quot;,&quot;msg&quot;:&quot;published local member...&quot; &#125;</span><br><span class="line">&#123;&quot;level&quot;:&quot;info&quot;,&quot;caller&quot;:&quot;embed/serve.go:98&quot;,&quot;msg&quot;:&quot;ready to serve client requests&quot;&#125;</span><br><span class="line">&#123;&quot;level&quot;:&quot;info&quot;,&quot;caller&quot;:&quot;etcdmain/main.go:47&quot;,&quot;msg&quot;:&quot;notifying init daemon&quot;&#125;</span><br><span class="line">&#123;&quot;level&quot;:&quot;info&quot;,&quot;caller&quot;:&quot;etcdmain/main.go:53&quot;,&quot;msg&quot;:&quot;successfully notified init daemon&quot;&#125;</span><br><span class="line">&#123;&quot;level&quot;:&quot;info&quot;,&quot;caller&quot;:&quot;embed/serve.go:140&quot;,&quot;msg&quot;:&quot;serving client traff...&quot;,&quot;address&quot;:&quot;127.0.0.1:2379&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>观察发现可以通过127.0.0.1:2379和集群进行交互。</p>
<p>需要注意的是，etcd的V2和V3差别很大，因此在使用<strong>etcdctl</strong>时需要指定使用的是哪个版本。通过环境变量来指定版本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">export</span> ETCDCTL_API=3</span></span><br></pre></td></tr></table></figure>
<p>接着就可以使用etcdctl来读写数据了：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./etcdctl put foo bar</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./etcdctl get foo</span></span><br><span class="line">foo</span><br><span class="line">bar</span><br></pre></td></tr></table></figure>
<p><code>etdctl get</code>会打印key和value，如果只想打印value可以加上<code>--print-value-only</code>。</p>
<p>可以加<code>-write-out=json</code>看到更详细的信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./etcdctl get --write-out=json foo</span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;header&quot;: &#123;</span><br><span class="line">    &quot;cluster_id&quot;: 14841639068965180000,</span><br><span class="line">    &quot;member_id&quot;: 10276657743932975000,</span><br><span class="line">    &quot;revision&quot;: 2,</span><br><span class="line">    &quot;raft_term&quot;: 2</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;kvs&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;key&quot;: &quot;Zm9v&quot;,</span><br><span class="line">      &quot;create_revision&quot;: 2,</span><br><span class="line">      &quot;mod_revision&quot;: 2,</span><br><span class="line">      &quot;version&quot;: 1,</span><br><span class="line">      &quot;value&quot;: &quot;YmFy&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;count&quot;: 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>观察看到，打印出来的信息是base64编码的。</p>
<p>打印出来的信息啥意思呢？</p>
<ul>
<li><code>version：1</code></li>
<li><code>revision:2</code></li>
<li><code>create_revision：2</code></li>
<li><code>mod_revision：2</code></li>
</ul>
<p>根据<a href="https://etcd.io/docs/v3.5/learning/api/">etcd documentation</a>，</p>
<p><code>version</code> 作用域为 key, 某一个 key 的修改次数(从创建到删除)；</p>
<p><code>revision</code>作用域为集群，逻辑时间戳，全局单调递增，任何 key 修改都会使其自增；</p>
<p><code>create_revision</code>作用域为 key, 等于创建这个 key 时的 Revision, 直到删除前都保持不变</p>
<p><code>mod_revision</code>作用域为 key, 等于修改这个 key 时的 Revision, 只要这个 key 更新都会改变。</p>
<p>当修改值之后，打印信息变化如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./etcdctl put foo baz</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./etcdctl get --write-out=json foo</span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;header&quot;: &#123;</span><br><span class="line">    &quot;cluster_id&quot;: 14841639068965180000,</span><br><span class="line">    &quot;member_id&quot;: 10276657743932975000,</span><br><span class="line">    &quot;revision&quot;: 3,</span><br><span class="line">    &quot;raft_term&quot;: 2</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;kvs&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;key&quot;: &quot;Zm9v&quot;,</span><br><span class="line">      &quot;create_revision&quot;: 2,</span><br><span class="line">      &quot;mod_revision&quot;: 3,</span><br><span class="line">      &quot;version&quot;: 2,</span><br><span class="line">      &quot;value&quot;: &quot;YmF6&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;count&quot;: 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>etcd并且支持查看旧版本数据，使用<code>--rev</code>参数来指定集群的版本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./etcdctl get foo --rev=2 --print-value-only</span></span><br><span class="line">bar</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./etcdctl get foo --rev=3 --print-value-only</span></span><br><span class="line">baz</span><br></pre></td></tr></table></figure>
<p>删除数据：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">/etcdctl del foo</span></span><br><span class="line">1</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./etcdctl get foo</span></span><br></pre></td></tr></table></figure>
<p>删除后返回的1代表删除key数量。</p>
<p>但是删除并不是永久的，还是可以通过<code>--rev</code>参数来查看旧版本数据。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./etcdctl get foo --rev=3 --print-value-only</span></span><br><span class="line">baz</span><br></pre></td></tr></table></figure>
<h3 id="5-2-多值返回"><a href="#5-2-多值返回" class="headerlink" title="5.2 多值返回"></a>5.2 多值返回</h3><p>etcd的一个特性就是可以一次返回多个value。</p>
<p>首先创建一些数据：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./etcdctl put myprefix/key1 thing1</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./etcdctl put myprefix/key2 thing2</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./etcdctl put myprefix/key3 thing3</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./etcdctl put myprefix/key4 thing4</span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
<p>一次访问多个值：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./etcdctl get myprefix/key2 myprefix/key4</span></span><br><span class="line">myprefix/key2</span><br><span class="line">thing2</span><br><span class="line">myprefix/key3</span><br><span class="line">thing3</span><br></pre></td></tr></table></figure>
<p>可以通过<code>--prefix</code>来指定key的前缀：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./etcdctl get --prefix myprefix/</span></span><br><span class="line">myprefix/key1</span><br><span class="line">thing1</span><br><span class="line">myprefix/key2</span><br><span class="line">thing2</span><br><span class="line">myprefix/key3</span><br><span class="line">thing3</span><br><span class="line">myprefix/key4</span><br><span class="line">thing4</span><br></pre></td></tr></table></figure>
<h3 id="5-3-监听修改"><a href="#5-3-监听修改" class="headerlink" title="5.3 监听修改"></a>5.3 监听修改</h3><p>首先在一个终端输入以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./etcdctl watch --prefix myprefix/</span></span><br></pre></td></tr></table></figure>
<p>然后在另一个终端修改一些数据：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./etcdctl put myprefix/key1 anewthing</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./etcdctl put myprefix/key5 thing5</span></span><br><span class="line">OK</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./etcdctl del myprefix/key5</span></span><br><span class="line">1</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./etcdctl put notmyprefix/key thing</span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
<p>接着在第一个终端观察变化：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">PUT</span><br><span class="line">myprefix/key1</span><br><span class="line">anewthing</span><br><span class="line">PUT</span><br><span class="line">myprefix/key5</span><br><span class="line">thing5</span><br><span class="line">DELETE</span><br><span class="line">myprefix/key5</span><br></pre></td></tr></table></figure>
<p>可以看到，因为监听了myprefix的数据，因此在第一个终端打印出了修改，而前缀notmyprefix并没有打印信息。</p>
<p>并且watch也可以加<code>--rev</code>参数来查看历史版本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./etcdctl watch --rev=2 foo</span></span><br><span class="line">PUT</span><br><span class="line">foo</span><br><span class="line">bar</span><br><span class="line">PUT</span><br><span class="line">foo</span><br><span class="line">baz</span><br><span class="line">DELETE</span><br><span class="line">foo</span><br></pre></td></tr></table></figure>
<h3 id="5-4-多节点etcd集群"><a href="#5-4-多节点etcd集群" class="headerlink" title="5.4 多节点etcd集群"></a>5.4 多节点etcd集群</h3><p>目前未知，集群中只有一个节点，甚至不能称之为一个集群。现在我们来启动一个三节点的集群，来看看到底是怎么高可用的。</p>
<p>首先为三个节点创建数据保存的文件夹：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">mkdir</span> -p /tmp/etcd/data&#123;1..3&#125;</span></span><br></pre></td></tr></table></figure>
<p>启动集群时，我们必须知道其中每一个节点的IP地址以及端口，这样节点之间才能相互通信。</p>
<p>对于三个节点，客户端的端口也就是客户端可以连接的端口设置为2379，3379和4379，peer端口也就是node之间通信的端口设置为2380，3380以及4380。</p>
<p>通过一下命令启动第一个节点：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./etcd --data-dir=/tmp/etcd/data1 --name node1 \</span><br><span class="line">  --initial-advertise-peer-urls http://127.0.0.1:2380 \</span><br><span class="line">  --listen-peer-urls http://127.0.0.1:2380 \</span><br><span class="line">  --advertise-client-urls http://127.0.0.1:2379 \</span><br><span class="line">  --listen-client-urls http://127.0.0.1:2379 \</span><br><span class="line">  --initial-cluster node1=http://127.0.0.1:2380,node2=http://127.0.0.1:3380,node3=http://127.0.0.1:4380 \</span><br><span class="line">  --initial-cluster-state new \</span><br><span class="line">  --initial-cluster-token mytoken</span><br></pre></td></tr></table></figure>
<p>其中几个参数：</p>
<ul>
<li><code>--name</code>：指定了节点的名字</li>
<li><code>--listen-peer-urls</code>和<code>--initial-advertise-peer-urls</code>：指定节点之间的通信地址和端口</li>
<li><code>--advertise-client-urls</code>和<code>--listen-client-urls</code>指定客户端与节点通信的地址和端口</li>
<li><code>--initial-cluster-token</code>指定一个集群中节点公用的token</li>
<li><code>--initial-cluster</code>指定集群中所有节点，这样才能找到其他节点</li>
</ul>
<p>同理在新的终端中启动第二个和第三个节点：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./etcd --data-dir=/tmp/etcd/data2 --name node2 \</span><br><span class="line">  --initial-advertise-peer-urls http://127.0.0.1:3380 \</span><br><span class="line">  --listen-peer-urls http://127.0.0.1:3380 \</span><br><span class="line">  --advertise-client-urls http://127.0.0.1:3379 \</span><br><span class="line">  --listen-client-urls http://127.0.0.1:3379 \</span><br><span class="line">  --initial-cluster node1=http://127.0.0.1:2380,node2=http://127.0.0.1:3380,node3=http://127.0.0.1:4380 \</span><br><span class="line">  --initial-cluster-state new \</span><br><span class="line">  --initial-cluster-token mytoken</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ </span><br><span class="line">bash</span><br><span class="line">./etcd --data-dir=/tmp/etcd/data3 --name node3 \</span><br><span class="line">  --initial-advertise-peer-urls http://127.0.0.1:4380 \</span><br><span class="line">  --listen-peer-urls http://127.0.0.1:4380 \</span><br><span class="line">  --advertise-client-urls http://127.0.0.1:4379 \</span><br><span class="line">  --listen-client-urls http://127.0.0.1:4379 \</span><br><span class="line">  --initial-cluster node1=http://127.0.0.1:2380,node2=http://127.0.0.1:3380,node3=http://127.0.0.1:4380 \</span><br><span class="line">  --initial-cluster-state new \</span><br><span class="line">  --initial-cluster-token mytoken</span><br></pre></td></tr></table></figure>
<p>启动之后，就可以使用etcdctl加上<code>--endpoint</code>参数来和节点通信，这里的endpoint就是启动时<code>--listen-client-urls</code>指定的地址。</p>
<p>首先查看所有节点：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">export</span> ENDPOINTS=127.0.0.1:2379,127.0.0.1:3379,127.0.0.1:4379</span><br><span class="line">$ ./etcdctl --endpoints=<span class="variable">$ENDPOINTS</span> member list --write-out=table</span><br><span class="line">+------------------+---------+-------+-----------------------+-----------------------+------------+</span><br><span class="line">|        ID        | STATUS  | NAME  |      PEER ADDRS       |     CLIENT ADDRS      | IS LEARNER |</span><br><span class="line">+------------------+---------+-------+-----------------------+-----------------------+------------+</span><br><span class="line">| 3c969067d90d0e6c | started | node1 | http://127.0.0.1:2380 | http://127.0.0.1:2379 |      <span class="literal">false</span> |</span><br><span class="line">| 5c5501077e83a9ee | started | node3 | http://127.0.0.1:4380 | http://127.0.0.1:4379 |      <span class="literal">false</span> |</span><br><span class="line">| a2f3309a1583fba3 | started | node2 | http://127.0.0.1:3380 | http://127.0.0.1:3379 |      <span class="literal">false</span> |</span><br><span class="line">+------------------+---------+-------+-----------------------+-----------------------+------------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>读写数据：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./etcdctl --endpoints=<span class="variable">$ENDPOINTS</span> put mykey myvalue</span><br><span class="line">OK</span><br><span class="line">$ ./etcdctl --endpoints=<span class="variable">$ENDPOINTS</span> get mykey</span><br><span class="line">mykey</span><br><span class="line">myvalue</span><br></pre></td></tr></table></figure>
<p>现在假设一个节点down了咋办？我们在第一个终端中ctrl+c，然后查看节点：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./etcdctl --endpoints=<span class="variable">$ENDPOINTS</span> member list --write-out=table</span><br><span class="line">+------------------+---------+-------+-----------------------+-----------------------+------------+</span><br><span class="line">|        ID        | STATUS  | NAME  |      PEER ADDRS       |     CLIENT ADDRS      | IS LEARNER |</span><br><span class="line">+------------------+---------+-------+-----------------------+-----------------------+------------+</span><br><span class="line">| 3c969067d90d0e6c | started | node1 | http://127.0.0.1:2380 | http://127.0.0.1:2379 |      <span class="literal">false</span> |</span><br><span class="line">| 5c5501077e83a9ee | started | node3 | http://127.0.0.1:4380 | http://127.0.0.1:4379 |      <span class="literal">false</span> |</span><br><span class="line">| a2f3309a1583fba3 | started | node2 | http://127.0.0.1:3380 | http://127.0.0.1:3379 |      <span class="literal">false</span> |</span><br><span class="line">+------------------+---------+-------+-----------------------+-----------------------+------------+</span><br></pre></td></tr></table></figure>
<p>可以看到，就算杀掉了第一个节点，还是能看到三个节点。其实<code>meber list</code>列出了所有节点，可以采用<code>endpoint status</code>产看节点状态：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./etcdctl --endpoints=<span class="variable">$ENDPOINTS</span> endpoint status --write-out=table</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;level&quot;</span>: <span class="string">&quot;warn&quot;</span>,</span><br><span class="line">  <span class="string">&quot;ts&quot;</span>: <span class="string">&quot;2021-06-23T15:43:40.378-0700&quot;</span>,</span><br><span class="line">  <span class="string">&quot;logger&quot;</span>: <span class="string">&quot;etcd-client&quot;</span>,</span><br><span class="line">  <span class="string">&quot;caller&quot;</span>: <span class="string">&quot;v3/retry_interceptor.go:62&quot;</span>,</span><br><span class="line">  <span class="string">&quot;msg&quot;</span>: <span class="string">&quot;retrying of unary invoker failed&quot;</span>,</span><br><span class="line">  <span class="string">&quot;target&quot;</span>: <span class="string">&quot;etcd-endpoints://0xc000454700/#initially=[127.0.0.1:2379;127.0.0.1:3379;127.0.0.1:4379]&quot;</span>,</span><br><span class="line">  <span class="string">&quot;attempt&quot;</span>: 0,</span><br><span class="line">  <span class="string">&quot;error&quot;</span>: <span class="string">&quot;rpc error: code = DeadlineExceeded ... connect: connection refused\&quot;&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">Failed to get the status of endpoint 127.0.0.1:2379 (context deadline exceeded)</span><br><span class="line">+----------------+------------------+-----------+------------+--------+</span><br><span class="line">|    ENDPOINT    |        ID        | IS LEADER | IS LEARNER | ERRORS |</span><br><span class="line">+----------------+------------------+-----------+------------+--------+</span><br><span class="line">| 127.0.0.1:3379 | a2f3309a1583fba3 |      <span class="literal">true</span> |      <span class="literal">false</span> |        |</span><br><span class="line">| 127.0.0.1:4379 | 5c5501077e83a9ee |     <span class="literal">false</span> |      <span class="literal">false</span> |        |</span><br><span class="line">+----------------+------------------+-----------+------------+--------+</span><br></pre></td></tr></table></figure>
<p>这时，集群还在work吗？应该吧，因为大多数节点还是健康的。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./etcdctl --endpoints=<span class="variable">$ENDPOINTS</span> get mykey</span><br><span class="line">mykey</span><br><span class="line">myvalue</span><br><span class="line">$ ./etcdctl --endpoints=<span class="variable">$ENDPOINTS</span> put mykey newvalue</span><br><span class="line">OK</span><br><span class="line">$ ./etcdctl --endpoints=<span class="variable">$ENDPOINTS</span> get mykey</span><br><span class="line">mykey</span><br><span class="line">newvalue</span><br></pre></td></tr></table></figure>
<p>看起来一切正常。现在我们再重启使用第一条命令启动第一个节点的话，会发现它立马又重新加入了集群：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./etcdctl --endpoints=<span class="variable">$ENDPOINTS</span> endpoint status --write-out=table</span><br><span class="line">+----------------+------------------+-----------+------------+--------+</span><br><span class="line">|    ENDPOINT    |        ID        | IS LEADER | IS LEARNER | ERRORS |</span><br><span class="line">+----------------+------------------+-----------+------------+--------+</span><br><span class="line">| 127.0.0.1:2379 | 3c969067d90d0e6c |     <span class="literal">false</span> |      <span class="literal">false</span> |        |</span><br><span class="line">| 127.0.0.1:3379 | a2f3309a1583fba3 |      <span class="literal">true</span> |      <span class="literal">false</span> |        |</span><br><span class="line">| 127.0.0.1:4379 | 5c5501077e83a9ee |     <span class="literal">false</span> |      <span class="literal">false</span> |        |</span><br><span class="line">+----------------+------------------+-----------+------------+--------+</span><br></pre></td></tr></table></figure>
<p>万一两个节点都不可用了呢？现在杀掉第一个和第二个节点，再查看状态：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./etcdctl --endpoints=<span class="variable">$ENDPOINTS</span> endpoint status --write-out=table</span><br><span class="line">&#123;<span class="string">&quot;level&quot;</span>:<span class="string">&quot;warn&quot;</span>,<span class="string">&quot;ts&quot;</span>:<span class="string">&quot;2021-06-23T15:47:05.803-0700&quot;</span>,<span class="string">&quot;logger&quot;</span>:<span class="string">&quot;etcd-client&quot;</span>,<span class="string">&quot;caller&quot;</span>:<span class="string">&quot;v3/retry_i ...&#125;</span></span><br><span class="line"><span class="string">Failed to get the status of endpoint 127.0.0.1:2379 (context deadline exceeded)</span></span><br><span class="line"><span class="string">&#123;&quot;</span>level<span class="string">&quot;:&quot;</span>warn<span class="string">&quot;,&quot;</span>ts<span class="string">&quot;:&quot;</span>2021-06-23T15:47:10.805-0700<span class="string">&quot;,&quot;</span>logger<span class="string">&quot;:&quot;</span>etcd-client<span class="string">&quot;,&quot;</span><span class="built_in">caller</span><span class="string">&quot;:&quot;</span>v3/retry_i ...&#125;</span><br><span class="line">Failed to get the status of endpoint 127.0.0.1:3379 (context deadline exceeded)</span><br><span class="line">+----------------+------------------+-----------+------------+-----------------------+</span><br><span class="line">|    ENDPOINT    |        ID        | IS LEADER | IS LEARNER |        ERRORS         |</span><br><span class="line">+----------------+------------------+-----------+------------+-----------------------+</span><br><span class="line">| 127.0.0.1:4379 | 5c5501077e83a9ee |     <span class="literal">false</span> |      <span class="literal">false</span> | etcdserver: no leader |</span><br><span class="line">+----------------+------------------+-----------+------------+-----------------------+</span><br></pre></td></tr></table></figure>
<p>可以看到报错信息是没有leader，这时尝试读写数据：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./etcdctl --endpoints=<span class="variable">$ENDPOINTS</span> get mykey</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;level&quot;</span>: <span class="string">&quot;warn&quot;</span>,</span><br><span class="line">  <span class="string">&quot;ts&quot;</span>: <span class="string">&quot;2021-06-23T15:48:31.987-0700&quot;</span>,</span><br><span class="line">  <span class="string">&quot;logger&quot;</span>: <span class="string">&quot;etcd-client&quot;</span>,</span><br><span class="line">  <span class="string">&quot;caller&quot;</span>: <span class="string">&quot;v3/retry_interceptor.go:62&quot;</span>,</span><br><span class="line">  <span class="string">&quot;msg&quot;</span>: <span class="string">&quot;retrying of unary invoker failed&quot;</span>,</span><br><span class="line">  <span class="string">&quot;target&quot;</span>: <span class="string">&quot;etcd-endpoints://0xc0001da000/#initially=[127.0.0.1:2379;127.0.0.1:3379;127.0.0.1:4379]&quot;</span>,</span><br><span class="line">  <span class="string">&quot;attempt&quot;</span>: 0,</span><br><span class="line">  <span class="string">&quot;error&quot;</span>: <span class="string">&quot;rpc error: code = Unknown desc = context deadline exceeded&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">$ ./etcdctl --endpoints=<span class="variable">$ENDPOINTS</span> put mykey anewervalue</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;level&quot;</span>: <span class="string">&quot;warn&quot;</span>,</span><br><span class="line">  <span class="string">&quot;ts&quot;</span>: <span class="string">&quot;2021-06-23T15:49:04.539-0700&quot;</span>,</span><br><span class="line">  <span class="string">&quot;logger&quot;</span>: <span class="string">&quot;etcd-client&quot;</span>,</span><br><span class="line">  <span class="string">&quot;caller&quot;</span>: <span class="string">&quot;v3/retry_interceptor.go:62&quot;</span>,</span><br><span class="line">  <span class="string">&quot;msg&quot;</span>: <span class="string">&quot;retrying of unary invoker failed&quot;</span>,</span><br><span class="line">  <span class="string">&quot;target&quot;</span>: <span class="string">&quot;etcd-endpoints://0xc000432a80/#initially=[127.0.0.1:2379;127.0.0.1:3379;127.0.0.1:4379]&quot;</span>,</span><br><span class="line">  <span class="string">&quot;attempt&quot;</span>: 0,</span><br><span class="line">  <span class="string">&quot;error&quot;</span>: <span class="string">&quot;rpc error: code = DeadlineExceeded desc = context deadline exceeded&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">Error: context deadline exceeded</span><br></pre></td></tr></table></figure>
<p>这时如果重新启动两个节点，马上一切又恢复了正常：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./etcdctl --endpoints=<span class="variable">$ENDPOINTS</span> endpoint status --write-out=table</span><br><span class="line">+----------------+------------------+-----------+------------+--------+</span><br><span class="line">|    ENDPOINT    |        ID        | IS LEADER | IS LEARNER | ERRORS |</span><br><span class="line">+----------------+------------------+-----------+------------+--------+</span><br><span class="line">| 127.0.0.1:2379 | 3c969067d90d0e6c |     <span class="literal">false</span> |      <span class="literal">false</span> |        |</span><br><span class="line">| 127.0.0.1:3379 | a2f3309a1583fba3 |     <span class="literal">false</span> |      <span class="literal">false</span> |        |</span><br><span class="line">| 127.0.0.1:4379 | 5c5501077e83a9ee |      <span class="literal">true</span> |      <span class="literal">false</span> |        |</span><br><span class="line">+----------------+------------------+-----------+------------+--------+</span><br><span class="line">$ ./etcdctl --endpoints=<span class="variable">$ENDPOINTS</span> get mykey</span><br><span class="line">mykey</span><br><span class="line">newvalue</span><br></pre></td></tr></table></figure>
<p>可以看到就算有downtime，也是没有数据丢失的。</p>
<h2 id="6-Etcd-in-k8s"><a href="#6-Etcd-in-k8s" class="headerlink" title="6. Etcd in k8s"></a>6. Etcd in k8s</h2><p>现在我们了解了etcd的基本使用，那么就来看看在k8s中etcd的使用吧。</p>
<p>这里我们采用minikube集群，连接minikube集群并且装上etcd：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ minikube start</span><br><span class="line">$ minikube ssh</span><br><span class="line">$ curl -LO https://mirrors.huaweicloud.com/etcd/v3.5.0/etcd-v3.5.0-linux-amd64.tar.gz</span><br><span class="line">$ tar xzvf etcd-v3.5.0-linux-amd64.tar.gz</span><br><span class="line">$ <span class="built_in">cd</span> etcd-v3.5.0-linux-amd64</span><br></pre></td></tr></table></figure>
<p>之后的步骤有一点不同，minikube的部署采用TLS验证，因此每次请求都要提供TLS的证书和keys。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="built_in">export</span> ETCDCTL=$(<span class="built_in">cat</span> &lt;&lt;<span class="string">EOF</span></span><br><span class="line"><span class="string">sudo ETCDCTL_API=3 ./etcdctl --cacert /var/lib/minikube/certs/etcd/ca.crt </span></span><br><span class="line"><span class="string">  --cert /var/lib/minikube/certs/etcd/healthcheck-client.crt </span></span><br><span class="line"><span class="string">  --key /var/lib/minikube/certs/etcd/healthcheck-client.key</span></span><br><span class="line"><span class="string">EOF</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>此处使用的证书和密钥是由 minikube 在 Kubernetes 集群引导期间生成的。它们是为与 etcd 健康检查一起使用而设计的，但它们也适用于调试。</p>
<p>查看节点：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="variable">$ETCDCTL</span> member list --write-out=table</span><br><span class="line">+------------------+---------+----------+---------------------------+---------------------------+------------+</span><br><span class="line">|        ID        | STATUS  |   NAME   |        PEER ADDRS         |       CLIENT ADDRS        | IS LEARNER |</span><br><span class="line">+------------------+---------+----------+---------------------------+---------------------------+------------+</span><br><span class="line">| aec36adc501070cc | started | minikube | https://192.168.49.2:2380 | https://192.168.49.2:2379 |      <span class="literal">false</span> |</span><br><span class="line">+------------------+---------+----------+---------------------------+---------------------------+------------+</span><br></pre></td></tr></table></figure>
<p>可以看到，minikube只有一个etcd节点。</p>
<p>Kubernetes API 是如何在etcd中保存数据的呢？所有k8s的数据都有<code>/registry</code>前缀：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="variable">$ETCDCTL</span> get --prefix /registry | <span class="built_in">wc</span> -l</span><br><span class="line">5882</span><br></pre></td></tr></table></figure>
<p>和pod有关的数据有着<code>/registry/pods</code>前缀：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="variable">$ETCDCTL</span> get --prefix /registry/pods | <span class="built_in">wc</span> -l</span><br><span class="line">412</span><br></pre></td></tr></table></figure>
<p>一般命名格式是这样：<code>/registry/pods/&lt;namespace&gt;/&lt;pod-name&gt;</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="variable">$ETCDCTL</span> get --prefix /registry/pods/kube-system/ --keys-only | grep scheduler</span><br><span class="line">/registry/pods/kube-system/kube-scheduler-minikube</span><br></pre></td></tr></table></figure>
<p><code>--keys-only</code>只打印key。</p>
<p>实际数据长啥样呢？？</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="variable">$ETCDCTL</span> get /registry/pods/kube-system/kube-scheduler-minikube | <span class="built_in">head</span> -6</span><br><span class="line">/registry/pods/kube-system/kube-scheduler-minikube</span><br><span class="line">k8s</span><br><span class="line"></span><br><span class="line">v1Pod�</span><br><span class="line">�</span><br><span class="line">kube-scheduler-minikube�</span><br><span class="line">                        kube-system<span class="string">&quot;*<span class="variable">$f8e4441d</span>-fb03-4c98-b48b-61a42643763a2��نZ</span></span><br></pre></td></tr></table></figure>
<p>可以看到是一堆乱码，因为k8s API是以二进制形式保存数据的。如果像查看json形式的话，应该用API而不是直接访问etcd。</p>
<p>可以采用watch来监听<code>default</code> ns的变化：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ <span class="variable">$ETCDCTL</span> watch --prefix /registry/pods/default/ --write-out=json</span><br></pre></td></tr></table></figure>
<p>然后在另一个终端：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ kubectl run --namespace=default --image=nginx nginx</span><br><span class="line">pod/nginx created</span><br></pre></td></tr></table></figure>
<p>可以看到在第一个终端：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;Header&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;cluster_id&quot;</span>: 18038207397139143000,</span><br><span class="line">    <span class="string">&quot;member_id&quot;</span>: 12593026477526643000,</span><br><span class="line">    <span class="string">&quot;revision&quot;</span>: 935,</span><br><span class="line">    <span class="string">&quot;raft_term&quot;</span>: 2</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;Events&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;kv&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;key&quot;</span>: <span class="string">&quot;L3JlZ2lzdHJ5L3BvZHMvZGVmYXVsdC9uZ2lueA==&quot;</span>,</span><br><span class="line">        <span class="string">&quot;create_revision&quot;</span>: 935,</span><br><span class="line">        <span class="string">&quot;mod_revision&quot;</span>: 935,</span><br><span class="line">        <span class="string">&quot;version&quot;</span>: 1,</span><br><span class="line">        <span class="string">&quot;value&quot;</span>: <span class="string">&quot;azh...ACIA&quot;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;CompactRevision&quot;</span>: 0,</span><br><span class="line">  <span class="string">&quot;Canceled&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="string">&quot;Created&quot;</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再次说明，在生产环境中并不会直接和etcd打交道，而是通过API来访问。可以预想的是，API底部也是通过etcd来读写数据的。</p>
<h2 id="7-替换etcd"><a href="#7-替换etcd" class="headerlink" title="7.替换etcd"></a>7.替换etcd</h2><p>在k8s中使用了etcd，但是在某些场合下比如测试环境或者嵌入式环境，我们想要轻量级，那etcd就不合适了。那么，就可以使用<a href="https://k3s.io/">k3s</a>，并且使用你想使用的数据库。</p>
]]></content>
      <categories>
        <category>k8s</category>
        <category>kube-ladder</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>kube-ladder</tag>
      </tags>
  </entry>
  <entry>
    <title>GitLab CI/CD之Runner</title>
    <url>/2022/11/14/GitLab-CI-CD%E4%B9%8BRunner/</url>
    <content><![CDATA[<h1 id="GitLab-CI-CD之Runner"><a href="#GitLab-CI-CD之Runner" class="headerlink" title="GitLab CI/CD之Runner"></a>GitLab CI/CD之Runner</h1><h2 id="1-什么是Runner以及为什么需要Runner？"><a href="#1-什么是Runner以及为什么需要Runner？" class="headerlink" title="1.什么是Runner以及为什么需要Runner？"></a>1.什么是Runner以及为什么需要Runner？</h2><ul>
<li><a href="https://docs.gitlab.com/runner/">官方解释</a>：</li>
</ul>
<blockquote>
<p>GitLab Runner is an application that works with GitLab CI/CD to run jobs in a pipeline.</p>
</blockquote>
<ul>
<li><p>几个概念：</p>
<ul>
<li>GitLab Job：流水线的最小单元，每个job中可能包含一条或多条待执行的命令。</li>
<li>GitLab Runner：与Gitlab CI/CD一起工作，用于运行流水线中的job一种应用。</li>
<li>Runner Executor：每一个Runner都会定义一个Executor，Executor其实就是job的运行环境，GitLab中可以使用如下不同的Executor：Shell、SSH、Docker、Kubernetes等等。</li>
</ul>
</li>
<li><p>Runner到底是做什么用的？</p>
<p>在GitLab项目中，我们定义了 <strong>.gitlab-ci.yml</strong> 文件。<strong>.gitlab-ci.yml</strong>文件中又定义了在执行CI/CD流水线时我们想去运行的stage，以及在每个stage中需要做什么事情。那么GitLab Runner 会将项目克隆下来并且读取 <strong>.gitlab-ci.yml</strong>文件，去执行我们在文件中定义的那些job。</p>
<span id="more"></span>
<h2 id="2-Runner有哪几种类型？"><a href="#2-Runner有哪几种类型？" class="headerlink" title="2.Runner有哪几种类型？"></a>2.Runner有哪几种类型？</h2></li>
<li><p><a href="https://docs.gitlab.com/ee/ci/runners/runners_scope.html#shared-runners">Shared runners</a> ：在GitLab的所有Group和Project中都可用。</p>
</li>
<li><a href="https://docs.gitlab.com/ee/ci/runners/runners_scope.html#group-runners">Group runners</a>：对于某个Group中的所有项目和子Group可用。</li>
<li><a href="https://docs.gitlab.com/ee/ci/runners/runners_scope.html#specific-runners">Specific runners</a> ：和一些特定的Project绑定，一般一对一。</li>
</ul>
<h2 id="3-常见的配置runner的方式"><a href="#3-常见的配置runner的方式" class="headerlink" title="3.常见的配置runner的方式"></a>3.常见的配置runner的方式</h2><ul>
<li>Runner安装方式有很多，详见<a href="https://docs.gitlab.com/runner/install/index.html">官网文档</a>，这里以docker方式安装为例。</li>
</ul>
<h3 id="3-1-拉镜像、启容器"><a href="#3-1-拉镜像、启容器" class="headerlink" title="3.1 拉镜像、启容器"></a>3.1 拉镜像、启容器</h3><ul>
<li>这一步是为了在服务器上安装Runner，以配置本地volume为例：</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run -d --name gitlab-runner --restart always \</span><br><span class="line">  -v /srv/gitlab-runner/config:/etc/gitlab-runner \</span><br><span class="line">  -v /var/run/docker.sock:/var/run/docker.sock \</span><br><span class="line">  gitlab/gitlab-runner:latest</span><br></pre></td></tr></table></figure>
<h2 id="3-2-注册Runner"><a href="#3-2-注册Runner" class="headerlink" title="3.2 注册Runner"></a>3.2 注册Runner</h2><ul>
<li>这一步是为了将服务器上的Runner和项目绑定。</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker run --<span class="built_in">rm</span> -it -v /srv/gitlab-runner/config:/etc/gitlab-runner gitlab/gitlab-runner register</span><br></pre></td></tr></table></figure>
<ul>
<li><p>输入命令后依次输入如下内容：</p>
<ul>
<li><p>GitLab instance URL </p>
</li>
<li><p>token</p>
</li>
<li><p>description</p>
</li>
<li><p><a href="https://docs.gitlab.com/ee/ci/runners/configure_runners.html#use-tags-to-control-which-jobs-a-runner-can-run">tags</a></p>
</li>
<li><p>optional maintenance</p>
</li>
<li><a href="https://docs.gitlab.com/runner/executors/index.html">runner executor</a>，如果这里使用docker，我们还要输入项目所需要使用的默认镜像。</li>
</ul>
</li>
</ul>
<h3 id="3-3-重启容器"><a href="#3-3-重启容器" class="headerlink" title="3.3 重启容器"></a>3.3 重启容器</h3><ul>
<li>这一步是为了使配置生效。</li>
</ul>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">docker restart gitlab-runner</span><br></pre></td></tr></table></figure>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://docs.gitlab.com/runner/">https://docs.gitlab.com/runner/</a></p>
<p><a href="https://docs.gitlab.com/runner/install/index.html">https://docs.gitlab.com/runner/install/index.html</a></p>
<p><a href="https://docs.gitlab.com/ee/ci/runners/runners_scope.html">https://docs.gitlab.com/ee/ci/runners/runners_scope.html</a></p>
<p><a href="https://docs.gitlab.com/runner/register/index.html#docker">https://docs.gitlab.com/runner/register/index.html#docker</a></p>
<p><a href="https://medium.com/devops-with-valentine/a-brief-guide-to-gitlab-ci-runners-and-executors-a81b9b8bf24e">https://medium.com/devops-with-valentine/a-brief-guide-to-gitlab-ci-runners-and-executors-a81b9b8bf24e</a></p>
<p><a href="https://stackoverflow.com/questions/47281209/what-is-gitlab-runner">https://stackoverflow.com/questions/47281209/what-is-gitlab-runner</a></p>
]]></content>
      <categories>
        <category>DevOps</category>
        <category>runner</category>
      </categories>
      <tags>
        <tag>DevOps</tag>
        <tag>runner</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-V2-31.栈的压入、弹出序列</title>
    <url>/2022/11/15/%E5%89%91%E6%8C%87offer-V2-31-%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h1 id="剑指offer-V2-31-栈的压入、弹出序列"><a href="#剑指offer-V2-31-栈的压入、弹出序列" class="headerlink" title="剑指offer-V2-31.栈的压入、弹出序列"></a>剑指offer-V2-31.栈的压入、弹出序列</h1><p><a href="https://leetcode.cn/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof/description/">原题点这里</a></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202211151045670.png" alt=""></p>
<span id="more"></span>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>用一个辅助栈s，先按照pushed数组的顺序入栈s，接着循环出栈，循环条件是：当s栈顶元素等于poped栈底元素。最后返回结果为s长度是否为0。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">validateStackSequences</span><span class="params">(pushed []<span class="type">int</span>, popped []<span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(pushed) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	stack := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">	idx1, idx2 := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> idx1 &lt; <span class="built_in">len</span>(pushed) &#123;</span><br><span class="line">		stack = <span class="built_in">append</span>(stack, pushed[idx1])</span><br><span class="line">		idx1++</span><br><span class="line">		<span class="keyword">for</span> <span class="built_in">len</span>(stack) &gt; <span class="number">0</span> &amp;&amp; stack[<span class="built_in">len</span>(stack)<span class="number">-1</span>] == popped[idx2] &#123;</span><br><span class="line">			idx2++</span><br><span class="line">			stack = stack[:<span class="built_in">len</span>(stack)<span class="number">-1</span>]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(stack) == <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>offer</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-V2-32- I. 从上到下打印二叉树</title>
    <url>/2022/11/15/%E5%89%91%E6%8C%87offer-V2-32-I-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="剑指offer-V2-32-I-从上到下打印二叉树"><a href="#剑指offer-V2-32-I-从上到下打印二叉树" class="headerlink" title="剑指offer-V2-32- I. 从上到下打印二叉树"></a>剑指offer-V2-32- I. 从上到下打印二叉树</h1><p><a href="https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/description/">原题点这里</a></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202211151049434.png" alt=""></p>
<span id="more"></span>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>使用队列层次遍历。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">levelOrder</span><span class="params">(root *TreeNode)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	queue := <span class="built_in">make</span>([]*TreeNode, <span class="number">0</span>)</span><br><span class="line">	queue = <span class="built_in">append</span>(queue, root)</span><br><span class="line">	ret := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(queue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		tmp := queue[<span class="number">0</span>]</span><br><span class="line">		queue = queue[<span class="number">1</span>:]</span><br><span class="line">		ret = <span class="built_in">append</span>(ret, tmp.Val)</span><br><span class="line">		<span class="keyword">if</span> tmp.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">			queue = <span class="built_in">append</span>(queue, tmp.Left)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> tmp.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">			queue = <span class="built_in">append</span>(queue, tmp.Right)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>offer</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-V2-32-II-从上到下打印二叉树</title>
    <url>/2022/11/16/%E5%89%91%E6%8C%87offer-V2-32-II-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="剑指offer-V2-32-II-从上到下打印二叉树-II"><a href="#剑指offer-V2-32-II-从上到下打印二叉树-II" class="headerlink" title="剑指offer-V2-32-II-从上到下打印二叉树 II"></a>剑指offer-V2-32-II-从上到下打印二叉树 II</h1><p><a href="https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/?favorite=xb9nqhhg">原题点这里</a></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202211161907372.png" alt=""></p>
<span id="more"></span>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>和层次遍历略有不同，普通层次遍历是一个队列，这里要变成两个队列，一个是当前层级队列，一个是下一层级队列。因为答案的返回值是一个二维数组，每一层放到一个数组里面。所以每一次先遍历当前层级队列，然后将其中所有元素的孩子入队下一层级队列，最后将下一层级队列设置为当前层级队列。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">levelOrder</span><span class="params">(root *TreeNode)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	ret := <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="comment">// 当前层队列</span></span><br><span class="line">	curQueue := <span class="built_in">make</span>([]*TreeNode, <span class="number">0</span>)</span><br><span class="line">	curQueue = <span class="built_in">append</span>(curQueue, root)</span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(curQueue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		<span class="comment">// 下一层队列</span></span><br><span class="line">		childQueue := <span class="built_in">make</span>([]*TreeNode, <span class="number">0</span>)</span><br><span class="line">		<span class="comment">// 当前层的结果</span></span><br><span class="line">		curRet := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">		<span class="comment">// 遍历当前层</span></span><br><span class="line">		<span class="keyword">for</span> <span class="built_in">len</span>(curQueue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">			tmp := curQueue[<span class="number">0</span>]</span><br><span class="line">			curQueue = curQueue[<span class="number">1</span>:]</span><br><span class="line">			<span class="comment">// 添加当前层结果</span></span><br><span class="line">			curRet = <span class="built_in">append</span>(curRet, tmp.Val)</span><br><span class="line">			<span class="keyword">if</span> tmp.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">				childQueue = <span class="built_in">append</span>(childQueue, tmp.Left)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> tmp.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">				childQueue = <span class="built_in">append</span>(childQueue, tmp.Right)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 把当前层结果加入最终结果</span></span><br><span class="line">		ret = <span class="built_in">append</span>(ret, curRet)</span><br><span class="line">		<span class="comment">// 把下一层定义为当前层</span></span><br><span class="line">		curQueue = childQueue</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>offer</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-V2-32 - III-从上到下打印二叉树</title>
    <url>/2022/11/16/%E5%89%91%E6%8C%87offer-V2-32-III-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="剑指offer-V2-32-III-从上到下打印二叉树"><a href="#剑指offer-V2-32-III-从上到下打印二叉树" class="headerlink" title="剑指offer-V2-32 - III-从上到下打印二叉树"></a>剑指offer-V2-32 - III-从上到下打印二叉树</h1><p><a href="https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/description/?favorite=xb9nqhhg">原题点这里</a></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202211161927874.png" alt=""></p>
<span id="more"></span>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>和32-II差不多，只是在偶数层将这一层结果倒序打印出来。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">levelOrder2</span><span class="params">(root *TreeNode)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	ret := <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">	curQueue := <span class="built_in">make</span>([]*TreeNode, <span class="number">0</span>)</span><br><span class="line">	curQueue = <span class="built_in">append</span>(curQueue, root)</span><br><span class="line">	flag := <span class="literal">true</span></span><br><span class="line">	<span class="keyword">for</span> <span class="built_in">len</span>(curQueue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">		nextQueue := <span class="built_in">make</span>([]*TreeNode, <span class="number">0</span>)</span><br><span class="line">		curRet := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">for</span> <span class="built_in">len</span>(curQueue) &gt; <span class="number">0</span> &#123;</span><br><span class="line">			tmp := curQueue[<span class="number">0</span>]</span><br><span class="line">			curRet = <span class="built_in">append</span>(curRet, tmp.Val)</span><br><span class="line">			curQueue = curQueue[<span class="number">1</span>:]</span><br><span class="line">			<span class="keyword">if</span> tmp.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">				nextQueue = <span class="built_in">append</span>(nextQueue, tmp.Left)</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> tmp.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">				nextQueue = <span class="built_in">append</span>(nextQueue, tmp.Right)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> flag = !flag; flag &#123;</span><br><span class="line">			<span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(curRet)<span class="number">-1</span>; i &lt; j; i, j = i+<span class="number">1</span>, j<span class="number">-1</span> &#123;</span><br><span class="line">				curRet[i], curRet[j] = curRet[j], curRet[i]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		ret = <span class="built_in">append</span>(ret, curRet)</span><br><span class="line">		curQueue = nextQueue</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>offer</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-V2-33-二叉搜索树的后序遍历序列</title>
    <url>/2022/11/17/%E5%89%91%E6%8C%87offer-V2-33-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h1 id="剑指offer-V2-33-二叉搜索树的后序遍历序列"><a href="#剑指offer-V2-33-二叉搜索树的后序遍历序列" class="headerlink" title="剑指offer-V2-33-二叉搜索树的后序遍历序列"></a>剑指offer-V2-33-二叉搜索树的后序遍历序列</h1><p><a href="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof/description/">原题点这里</a></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202211171005997.png" alt=""></p>
<span id="more"></span>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>递归，后序遍历的最后一个元素为根结点的值，将数组除了最后一个元素之外分成两个部分，一部分是我们假设的左子树部分，其中所有元素值都小于根节点；另一部分是假设的右子树部分，其中所有元素值都大于根结点。对于 第一部分，一般是成立的，因为我们通过遍历找到第一个大于根结点值的下标，以其为界分为两部分。但是假设的右子树中可能存在值小于根结点的情况，这种情况就不属于后序遍历。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">verifyPostorder</span><span class="params">(postorder []<span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(postorder) &lt;= <span class="number">2</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> verify(postorder, <span class="number">0</span>, <span class="built_in">len</span>(postorder)<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">verify</span><span class="params">(postorder []<span class="type">int</span>, left, right <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> left &gt;= right &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	idx := left</span><br><span class="line">	root := postorder[right]</span><br><span class="line">	<span class="keyword">for</span> postorder[idx] &lt; root &amp;&amp; idx &lt; right &#123;</span><br><span class="line">		idx++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := idx + <span class="number">1</span>; i &lt; right; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> postorder[i] &lt; root &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> verify(postorder, left, idx<span class="number">-1</span>) &amp;&amp; verify(postorder, idx, right<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>offer</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-V2-34-二叉树中和为某一值的路径</title>
    <url>/2022/11/17/%E5%89%91%E6%8C%87offer-V2-34-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
    <content><![CDATA[<h1 id="剑指offer-V2-34-二叉树中和为某一值的路径"><a href="#剑指offer-V2-34-二叉树中和为某一值的路径" class="headerlink" title="剑指offer-V2-34-二叉树中和为某一值的路径"></a>剑指offer-V2-34-二叉树中和为某一值的路径</h1><p><a href="https://leetcode.cn/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/?favorite=xb9nqhhg">原题点这里</a></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202211171010213.png" alt=""></p>
<span id="more"></span>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202211171010461.png" alt=""></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>深度优先，递归+回溯。通过这种方式判断每一条路径，如果此时已经到了叶子结点，判断这条路径的cnt是否等于target，如果等于加入结果；如果不等于，向上层返回然后回溯。注意，在将一条路径加入最终结果ret时，要重新复制一份数组，不然如果后续修改了path，ret中的结果也会跟着修改。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">pathSum</span><span class="params">(root *TreeNode, target <span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	ret := <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode, cnt <span class="type">int</span>, path []<span class="type">int</span>)</span></span></span><br><span class="line">	dfs = <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode, cnt <span class="type">int</span>, path []<span class="type">int</span>)</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> root.Left == <span class="literal">nil</span> &amp;&amp; root.Right == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> cnt == target &#123;</span><br><span class="line">				ret = <span class="built_in">append</span>(ret, <span class="built_in">append</span>([]<span class="type">int</span>(<span class="literal">nil</span>), path...))</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> root.Left != <span class="literal">nil</span> &#123;</span><br><span class="line">			path = <span class="built_in">append</span>(path, root.Left.Val)</span><br><span class="line">			dfs(root.Left, cnt+root.Left.Val, path)</span><br><span class="line">			path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> root.Right != <span class="literal">nil</span> &#123;</span><br><span class="line">			path = <span class="built_in">append</span>(path, root.Right.Val)</span><br><span class="line">			dfs(root.Right, cnt+root.Right.Val, path)</span><br><span class="line">			path = path[:<span class="built_in">len</span>(path)<span class="number">-1</span>]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	dfs(root, root.Val, <span class="built_in">append</span>([]<span class="type">int</span>&#123;&#125;, root.Val))</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>offer</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-V2-35-复杂链表的复制</title>
    <url>/2022/11/18/%E5%89%91%E6%8C%87offer-V2-35-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6/</url>
    <content><![CDATA[<h1 id="剑指offer-V2-35-复杂链表的复制"><a href="#剑指offer-V2-35-复杂链表的复制" class="headerlink" title="剑指offer-V2-35-复杂链表的复制"></a>剑指offer-V2-35-复杂链表的复制</h1><p><a href="https://leetcode.cn/problems/fu-za-lian-biao-de-fu-zhi-lcof/description/">原题点这里</a></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202211181019328.png" alt=""></p>
<span id="more"></span>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202211181019197.png" alt=""></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202211181019180.png" alt=""></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>先把链表当作普通链表，构建一条只有next的新链表。对于random，可以采用哈希表来做，key是原链表中节点，value是新链表中节点。再遍历原链表，对于每一个节点的random，在哈希表中找到其对应的节点，在新链表里连上。</p>
<h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>原地复制，不需要使用哈希表。先原地复制一份原链表，使其结构变为：1-&gt;1new-&gt;2-&gt;2new….，于是便可以连接其random节点，最后做一下链表拆分。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">	Val    <span class="type">int</span></span><br><span class="line">	Next   *Node</span><br><span class="line">	Random *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">copyRandomList</span><span class="params">(head *Node)</span></span> *Node &#123;</span><br><span class="line">	<span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	ret := &amp;Node&#123;Val: head.Val&#125;</span><br><span class="line">	p1, p2 := head.Next, ret</span><br><span class="line">	<span class="comment">// key是原链表节点，value对应新链表节点</span></span><br><span class="line">	m := <span class="built_in">make</span>(<span class="keyword">map</span>[*Node]*Node, <span class="number">0</span>)</span><br><span class="line">	m[head] = ret</span><br><span class="line">	<span class="keyword">for</span> p1 != <span class="literal">nil</span> &#123;</span><br><span class="line">		p2.Next = &amp;Node&#123;Val: p1.Val&#125;</span><br><span class="line">		m[p1] = p2.Next</span><br><span class="line">		p1 = p1.Next</span><br><span class="line">		p2 = p2.Next</span><br><span class="line">	&#125;</span><br><span class="line">	p1, p2 = head, ret</span><br><span class="line">	<span class="keyword">for</span> p1 != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> p1.Random != <span class="literal">nil</span> &#123;</span><br><span class="line">			tmp, _ := m[p1.Random]</span><br><span class="line">			p2.Random = tmp</span><br><span class="line">		&#125;</span><br><span class="line">		p1 = p1.Next</span><br><span class="line">		p2 = p2.Next</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Node <span class="keyword">struct</span> &#123;</span><br><span class="line">	Val    <span class="type">int</span></span><br><span class="line">	Next   *Node</span><br><span class="line">	Random *Node</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">copyRandomList</span><span class="params">(head *Node)</span></span> *Node &#123;</span><br><span class="line">	<span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	p1 := head</span><br><span class="line">	<span class="comment">// 复制原链表的next</span></span><br><span class="line">	<span class="keyword">for</span> p1 != <span class="literal">nil</span> &#123;</span><br><span class="line">		dummy := &amp;Node&#123;Val: p1.Val&#125;</span><br><span class="line">		dummy.Next = p1.Next</span><br><span class="line">		p1.Next = dummy</span><br><span class="line">		p1 = p1.Next.Next</span><br><span class="line">	&#125;</span><br><span class="line">	p1 = head</span><br><span class="line">	<span class="comment">// 复制原链表的random</span></span><br><span class="line">	<span class="keyword">for</span> p1 != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> p1.Random != <span class="literal">nil</span> &#123;</span><br><span class="line">			dummy1 := p1.Next</span><br><span class="line">			dummy2 := p1.Random.Next</span><br><span class="line">			dummy1.Random = dummy2</span><br><span class="line">		&#125;</span><br><span class="line">		p1 = p1.Next.Next</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 分割链表</span></span><br><span class="line">	ret := head.Next</span><br><span class="line">	p1 = head.Next</span><br><span class="line">	pre := head</span><br><span class="line">	<span class="keyword">for</span> p1.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">		pre.Next = pre.Next.Next</span><br><span class="line">		p1.Next = p1.Next.Next</span><br><span class="line">		pre = pre.Next</span><br><span class="line">		p1 = p1.Next</span><br><span class="line">	&#125;</span><br><span class="line">	pre.Next = <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>offer</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-V2-36-二叉搜索树与双向链表</title>
    <url>/2022/11/18/%E5%89%91%E6%8C%87offer-V2-36-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="剑指offer-V2-36-二叉搜索树与双向链表"><a href="#剑指offer-V2-36-二叉搜索树与双向链表" class="headerlink" title="剑指offer-V2-36-二叉搜索树与双向链表"></a>剑指offer-V2-36-二叉搜索树与双向链表</h1><p><a href="https://leetcode.cn/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof/description/">原题点这里</a></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202211181029460.png" alt=""></p>
<span id="more"></span>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202211181029727.png" alt=""></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>因为要构建升序的链表，而一棵二叉搜索树的中序遍历就是升序的，因此这道题采用中序遍历可解。分别设置head、pre、cur节点，head节点指向二叉搜索树中最左下角的节点。cur节点代表当前遍历到的节点，pre节点代表上一个遍历的节点，因此就可以将cur节点和pre节点连接起来。最后需要将head节点和遍历结束后的pre节点连接即可。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> val;</span><br><span class="line">  <span class="keyword">public</span> Node left;</span><br><span class="line">  <span class="keyword">public</span> Node right;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> _val)</span> &#123;</span><br><span class="line">    val = _val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> _val,Node _left,Node _right)</span> &#123;</span><br><span class="line">    val = _val;</span><br><span class="line">    left = _left;</span><br><span class="line">    right = _right;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="type">Node</span> <span class="variable">head</span> <span class="operator">=</span> <span class="literal">null</span>,pre = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">public</span> Node <span class="title function_">treeToDoublyList</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">null</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dfs(root);</span><br><span class="line">    head.left = pre;</span><br><span class="line">    pre.right = head;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(Node cur)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(cur == <span class="literal">null</span>)    <span class="keyword">return</span>;</span><br><span class="line">    dfs(cur.left);</span><br><span class="line">    <span class="keyword">if</span>(head == <span class="literal">null</span>)    head = cur;</span><br><span class="line">    <span class="keyword">else</span>    pre.right = cur;</span><br><span class="line">    cur.left = pre;</span><br><span class="line">    pre = cur;</span><br><span class="line">    dfs(cur.right);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>offer</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-V2-37-序列化二叉树</title>
    <url>/2022/11/21/%E5%89%91%E6%8C%87offer-V2-37-%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="剑指offer-V2-37-序列化二叉树"><a href="#剑指offer-V2-37-序列化二叉树" class="headerlink" title="剑指offer-V2-37-序列化二叉树"></a>剑指offer-V2-37-序列化二叉树</h1><p><a href="https://leetcode.cn/problems/xu-lie-hua-er-cha-shu-lcof/description/?favorite=xb9nqhhg">原题点这里</a></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202211211332891.png" alt=""></p>
<span id="more"></span>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>可以看出序列化得到的结果，实际上就是二叉树的层次遍历的结果，只是对于空节点的值是null。因此序列化时只需要按照层次遍历来遍历二叉树，遇到叶子节点，将其左右子树的val设置成null。这样就把一棵二叉树转化成了一颗存在null节点的完全二叉树，反序列化时，通过完全二叉树的下标来访问节点，遇到节点值是null的就代表该节点是null。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val; </span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">serialize</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;[]&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;[&quot;</span>);</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        q.add(root);</span><br><span class="line">        ret.append(Integer.valueOf(root.val) + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">        <span class="keyword">while</span> (q.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> q.poll();</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                q.add(node.left);</span><br><span class="line">                ret.append(Integer.valueOf(node.left.val) + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                ret.append(<span class="string">&quot;null,&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                q.add(node.right);</span><br><span class="line">                ret.append(Integer.valueOf(node.right.val) + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ret.append(<span class="string">&quot;null,&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ret.deleteCharAt(ret.length()-<span class="number">1</span>);</span><br><span class="line">        ret.append(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deserialize</span><span class="params">(String data)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;[]&quot;</span>.equals(data)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String[] ss = data.substring(<span class="number">1</span>,data.length()-<span class="number">1</span>).split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(ss[<span class="number">0</span>]));</span><br><span class="line">        Queue&lt;TreeNode&gt; q = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        q.add(root);</span><br><span class="line">        <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(q.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">tmp</span> <span class="operator">=</span> q.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">leftInx</span> <span class="operator">=</span> <span class="number">2</span> * idx + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (leftInx &lt; ss.length &amp;&amp; !<span class="string">&quot;null&quot;</span>.equals(ss[leftInx])) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(ss[leftInx]));</span><br><span class="line">                tmp.left = left;</span><br><span class="line">                q.add(left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">rightInx</span> <span class="operator">=</span> <span class="number">2</span> * idx + <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (rightInx &lt; ss.length &amp;&amp; !<span class="string">&quot;null&quot;</span>.equals(ss[rightInx])) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(ss[rightInx]));</span><br><span class="line">                tmp.right = right;</span><br><span class="line">                q.add(right);</span><br><span class="line">            &#125;</span><br><span class="line">            idx++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec codec = new Codec();</span></span><br><span class="line"><span class="comment">// codec.deserialize(codec.serialize(root));</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>offer</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-V2-38-字符串的排列</title>
    <url>/2022/11/22/%E5%89%91%E6%8C%87offer-V2-38-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97/</url>
    <content><![CDATA[<h1 id="剑指offer-V2-38-字符串的排列"><a href="#剑指offer-V2-38-字符串的排列" class="headerlink" title="剑指offer-V2-38-字符串的排列"></a>剑指offer-V2-38-字符串的排列</h1><p><a href="https://leetcode.cn/problems/zi-fu-chuan-de-pai-lie-lcof/description/">原题点这里</a></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202211220955539.png" alt=""></p>
<span id="more"></span>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>递归+回溯+剪枝。每一层递归中，相当于考虑其中某一位，将该位后面的字符和当前位置进行交换，然后进入下一层，递归出来之后要回溯，也就是将之前交换的再交换回去。剪枝，因为字符串存在重复元素，所以给每一位设置一个HashMap，代表当前位置上有没有放过某个字符，如果放过，可以直接考虑下一个位置。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">permutation</span><span class="params">(s <span class="type">string</span>)</span></span> []<span class="type">string</span> &#123;</span><br><span class="line">	ret := <span class="built_in">make</span>([]<span class="type">string</span>, <span class="number">0</span>)</span><br><span class="line">	cs := []<span class="type">byte</span>(s)</span><br><span class="line">	<span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(k <span class="type">int</span>)</span></span></span><br><span class="line">	dfs = <span class="function"><span class="keyword">func</span><span class="params">(k <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> k == <span class="built_in">len</span>(s)<span class="number">-1</span> &#123;</span><br><span class="line">			ret = <span class="built_in">append</span>(ret, <span class="type">string</span>(cs))</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">byte</span>]<span class="keyword">struct</span>&#123;&#125;, <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">for</span> i := k; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">			<span class="keyword">if</span> _, exists := m[cs[i]]; exists &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			m[cs[i]] = <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line">			cs[i], cs[k] = cs[k], cs[i]</span><br><span class="line">			dfs(k + <span class="number">1</span>)</span><br><span class="line">			cs[k], cs[i] = cs[i], cs[k]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	dfs(<span class="number">0</span>)</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>offer</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-V2-39-数组中出现次数超过一半的数字</title>
    <url>/2022/11/22/%E5%89%91%E6%8C%87offer-V2-39-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E5%8D%8A%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h1 id="剑指offer-V2-39-数组中出现次数超过一半的数字"><a href="#剑指offer-V2-39-数组中出现次数超过一半的数字" class="headerlink" title="剑指offer-V2-39-数组中出现次数超过一半的数字"></a>剑指offer-V2-39-数组中出现次数超过一半的数字</h1><p><a href="https://leetcode.cn/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof/description/">原题点这里</a></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202211221013815.png" alt=""></p>
<span id="more"></span>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>摩尔投票法。设输入数组 <code>nums</code> 的众数为 x ，数组长度为 n 。</p>
<ul>
<li><p>推论一： 若记 众数 的票数为 +1 ，非众数 的票数为 −1 ，则一定有所有数字的票数和 &gt;0 。</p>
</li>
<li><p>推论二： 若数组的前 a 个数字的 票数和 =0 ，则 数组剩余 (n−a)个数字的票数和一定仍 &gt;0 ，即后(n−a) 个数字的 众数仍为x。</p>
</li>
</ul>
<p>如果出现当前票数和为0，那么数组中剩余数字的众数不变，因此可以不断缩小众数范围。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">majorityElement</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	num := nums[<span class="number">0</span>]</span><br><span class="line">	vote := <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> vote == <span class="number">0</span> &#123;</span><br><span class="line">			num = nums[i]</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> nums[i] == num &#123;</span><br><span class="line">			vote++</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			vote--</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> num</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>offer</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-V2-40-最小的k个数</title>
    <url>/2022/11/23/%E5%89%91%E6%8C%87offer-V2-40-%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0/</url>
    <content><![CDATA[<h1 id="剑指offer-V2-40-最小的k个数"><a href="#剑指offer-V2-40-最小的k个数" class="headerlink" title="剑指offer-V2-40-最小的k个数"></a>剑指offer-V2-40-最小的k个数</h1><p><a href="https://leetcode.cn/problems/zui-xiao-de-kge-shu-lcof/description/">原题点这里</a></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202211231452162.png" alt=""></p>
<span id="more"></span>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>快速排序。在快排中，每一轮可以确定一个元素的位置。如果该元素左边正好有k个元素，代表这k个元素就是数组的topK。如果该元素左边的元素数量大于k个，代表需要递归去左半边寻找。同理，如果小于k个，需要递归去右边寻找。</p>
<h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>堆排序，可以采用大根堆。最后只要保证堆中元素数量是k个，返回堆即可。可以先将arr中前k个元素直接拷贝到堆中，然后从第k+1个开始判断，如果当前元素小于堆顶元素，也就是堆中最大的元素，那么要堆顶元素出堆，接着将该元素入堆。这样遍历完数组保证了堆中共有k个元素。</p>
<p>在golang中，需要自己实现堆的接口。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getLeastNumbers</span><span class="params">(arr []<span class="type">int</span>, k <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(arr) == <span class="number">0</span> || k == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> k == <span class="built_in">len</span>(arr) &#123;</span><br><span class="line">		<span class="keyword">return</span> arr</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> partition(arr, <span class="number">0</span>, <span class="built_in">len</span>(arr)<span class="number">-1</span>, k)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">partition</span><span class="params">(arr []<span class="type">int</span>, low, high, k <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> low &gt; high &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	lastMin := low</span><br><span class="line">	<span class="keyword">for</span> i := low + <span class="number">1</span>; i &lt;= high; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> arr[i] &lt; arr[low] &#123;</span><br><span class="line">			lastMin++</span><br><span class="line">			arr[i], arr[lastMin] = arr[lastMin], arr[i]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	arr[low], arr[lastMin] = arr[lastMin], arr[low]</span><br><span class="line">	<span class="keyword">switch</span> &#123;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	<span class="keyword">case</span> lastMin == k:</span><br><span class="line">		<span class="keyword">return</span> arr[:lastMin]</span><br><span class="line">	<span class="keyword">case</span> lastMin &gt; k:</span><br><span class="line">		<span class="keyword">return</span> partition(arr, low, lastMin<span class="number">-1</span>, k)</span><br><span class="line">	<span class="keyword">case</span> lastMin &lt; k:</span><br><span class="line">		<span class="keyword">return</span> partition(arr, lastMin+<span class="number">1</span>, high, k)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> maxHeap []<span class="type">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h maxHeap)</span></span> Len() <span class="type">int</span> &#123; <span class="keyword">return</span> <span class="built_in">len</span>(h) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h maxHeap)</span></span> Swap(i, j <span class="type">int</span>) &#123; h[i], h[j] = h[j], h[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h maxHeap)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> h[i] &gt; h[j] &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *maxHeap)</span></span> Push(x <span class="keyword">interface</span>&#123;&#125;) &#123; *h = <span class="built_in">append</span>(*h, x.(<span class="type">int</span>)) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *maxHeap)</span></span> Pop() <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">	old := *h</span><br><span class="line">	n := <span class="built_in">len</span>(old)</span><br><span class="line">	x := old[n<span class="number">-1</span>]</span><br><span class="line">	*h = old[<span class="number">0</span> : n<span class="number">-1</span>]</span><br><span class="line">	<span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getLeastNumbers</span><span class="params">(arr []<span class="type">int</span>, k <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(arr) == <span class="number">0</span> || k == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> k == <span class="built_in">len</span>(arr) &#123;</span><br><span class="line">		<span class="keyword">return</span> arr</span><br><span class="line">	&#125;</span><br><span class="line">	h := <span class="built_in">make</span>(maxHeap, k)</span><br><span class="line">	hp := &amp;h</span><br><span class="line">	<span class="built_in">copy</span>(h, maxHeap(arr[:k+<span class="number">1</span>]))</span><br><span class="line">	heap.Init(hp)</span><br><span class="line">	<span class="keyword">for</span> i := k; i &lt; <span class="built_in">len</span>(arr); i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> arr[i] &lt; h[<span class="number">0</span>] &#123;</span><br><span class="line">			heap.Pop(hp)</span><br><span class="line">			heap.Push(hp, arr[i])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> h</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>offer</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>offer</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang-实现大根堆/小根堆</title>
    <url>/2022/11/23/Golang-%E5%AE%9E%E7%8E%B0%E5%A4%A7%E6%A0%B9%E5%A0%86-%E5%B0%8F%E6%A0%B9%E5%A0%86/</url>
    <content><![CDATA[<h1 id="Golang-实现大根堆-小根堆"><a href="#Golang-实现大根堆-小根堆" class="headerlink" title="Golang-实现大根堆/小根堆"></a>Golang-实现大根堆/小根堆</h1><h2 id="接口实现"><a href="#接口实现" class="headerlink" title="接口实现"></a>接口实现</h2><p>因为go中没有现成的堆可以用，只提供了heap的接口，所以需要自己实现相应的接口。<br><span id="more"></span><br>需要实现这些接口：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">    sort.Interface</span><br><span class="line">    Push(x <span class="keyword">interface</span>&#123;&#125;) <span class="comment">// add x as element Len()</span></span><br><span class="line">    Pop() <span class="keyword">interface</span>&#123;&#125;   <span class="comment">// remove and return element Len() - 1.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接口实现如下：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> IntHeap <span class="keyword">struct</span> &#123;</span><br><span class="line">	heap []<span class="type">int</span></span><br><span class="line">	<span class="comment">// 是否小根堆</span></span><br><span class="line">	isMin <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span></span> Len() <span class="type">int</span> &#123; <span class="keyword">return</span> <span class="built_in">len</span>(h.heap) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span></span> Swap(i, j <span class="type">int</span>) &#123; h.heap[i], h.heap[j] = h.heap[j], h.heap[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h IntHeap)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> h.isMin &#123;</span><br><span class="line">		<span class="keyword">return</span> h.heap[i] &lt; h.heap[j]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> h.heap[i] &gt; h.heap[j]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span></span> Push(x <span class="keyword">interface</span>&#123;&#125;) &#123; h.heap = <span class="built_in">append</span>(h.heap, x.(<span class="type">int</span>)) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span></span> Pop() <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">	x := h.heap[h.Len()<span class="number">-1</span>]</span><br><span class="line">	h.heap = h.heap[<span class="number">0</span> : h.Len()<span class="number">-1</span>]</span><br><span class="line">	<span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>调用示例：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	minHeap := IntHeap&#123;</span><br><span class="line">		heap:  []<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>&#125;,</span><br><span class="line">		isMin: <span class="literal">true</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	heap.Init(&amp;minHeap)</span><br><span class="line">	heap.Push(&amp;minHeap, <span class="number">3</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;minimum: %d\n&quot;</span>, minHeap.heap[<span class="number">0</span>])</span><br><span class="line">	<span class="keyword">for</span> minHeap.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%d &quot;</span>, heap.Pop(&amp;minHeap))</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println()</span><br><span class="line"></span><br><span class="line">	maxHeap := IntHeap&#123;</span><br><span class="line">		heap:  []<span class="type">int</span>&#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">5</span>&#125;,</span><br><span class="line">		isMin: <span class="literal">false</span>,</span><br><span class="line">	&#125;</span><br><span class="line">	heap.Init(&amp;maxHeap)</span><br><span class="line">	heap.Push(&amp;maxHeap, <span class="number">3</span>)</span><br><span class="line">	fmt.Printf(<span class="string">&quot;maximum: %d\n&quot;</span>, maxHeap.heap[<span class="number">0</span>])</span><br><span class="line">	<span class="keyword">for</span> maxHeap.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">		fmt.Printf(<span class="string">&quot;%d &quot;</span>, heap.Pop(&amp;maxHeap))</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">minimum: 1</span><br><span class="line">1 2 3 5 </span><br><span class="line">maximum: 5</span><br><span class="line">5 3 2 1 </span><br></pre></td></tr></table></figure>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Copyright 2009 The Go Authors. All rights reserved.</span></span><br><span class="line"><span class="comment">// Use of this source code is governed by a BSD-style</span></span><br><span class="line"><span class="comment">// license that can be found in the LICENSE file.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Package heap provides heap operations for any type that implements</span></span><br><span class="line"><span class="comment">// heap.Interface. A heap is a tree with the property that each node is the</span></span><br><span class="line"><span class="comment">// minimum-valued node in its subtree.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// The minimum element in the tree is the root, at index 0.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// A heap is a common way to implement a priority queue. To build a priority</span></span><br><span class="line"><span class="comment">// queue, implement the Heap interface with the (negative) priority as the</span></span><br><span class="line"><span class="comment">// ordering for the Less method, so Push adds items while Pop removes the</span></span><br><span class="line"><span class="comment">// highest-priority item from the queue. The Examples include such an</span></span><br><span class="line"><span class="comment">// implementation; the file example_pq_test.go has the complete source.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="keyword">package</span> heap</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;sort&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// The Interface type describes the requirements</span></span><br><span class="line"><span class="comment">// for a type using the routines in this package.</span></span><br><span class="line"><span class="comment">// Any type that implements it may be used as a</span></span><br><span class="line"><span class="comment">// min-heap with the following invariants (established after</span></span><br><span class="line"><span class="comment">// Init has been called or if the data is empty or sorted):</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//	!h.Less(j, i) for 0 &lt;= i &lt; h.Len() and 2*i+1 &lt;= j &lt;= 2*i+2 and j &lt; h.Len()</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Note that Push and Pop in this interface are for package heap&#x27;s</span></span><br><span class="line"><span class="comment">// implementation to call. To add and remove things from the heap,</span></span><br><span class="line"><span class="comment">// use heap.Push and heap.Pop.</span></span><br><span class="line"><span class="keyword">type</span> Interface <span class="keyword">interface</span> &#123;</span><br><span class="line">	sort.Interface</span><br><span class="line">	Push(x any) <span class="comment">// add x as element Len()</span></span><br><span class="line">	Pop() any   <span class="comment">// remove and return element Len() - 1.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Init establishes the heap invariants required by the other routines in this package.</span></span><br><span class="line"><span class="comment">// Init is idempotent with respect to the heap invariants</span></span><br><span class="line"><span class="comment">// and may be called whenever the heap invariants may have been invalidated.</span></span><br><span class="line"><span class="comment">// The complexity is O(n) where n = h.Len().</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Init</span><span class="params">(h Interface)</span></span> &#123;</span><br><span class="line">	<span class="comment">// heapify</span></span><br><span class="line">	n := h.Len()</span><br><span class="line">	<span class="keyword">for</span> i := n/<span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">		down(h, i, n)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Push pushes the element x onto the heap.</span></span><br><span class="line"><span class="comment">// The complexity is O(log n) where n = h.Len().</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Push</span><span class="params">(h Interface, x any)</span></span> &#123;</span><br><span class="line">	h.Push(x)</span><br><span class="line">	up(h, h.Len()<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pop removes and returns the minimum element (according to Less) from the heap.</span></span><br><span class="line"><span class="comment">// The complexity is O(log n) where n = h.Len().</span></span><br><span class="line"><span class="comment">// Pop is equivalent to Remove(h, 0).</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Pop</span><span class="params">(h Interface)</span></span> any &#123;</span><br><span class="line">	n := h.Len() - <span class="number">1</span></span><br><span class="line">	h.Swap(<span class="number">0</span>, n)</span><br><span class="line">	down(h, <span class="number">0</span>, n)</span><br><span class="line">	<span class="keyword">return</span> h.Pop()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Remove removes and returns the element at index i from the heap.</span></span><br><span class="line"><span class="comment">// The complexity is O(log n) where n = h.Len().</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Remove</span><span class="params">(h Interface, i <span class="type">int</span>)</span></span> any &#123;</span><br><span class="line">	n := h.Len() - <span class="number">1</span></span><br><span class="line">	<span class="keyword">if</span> n != i &#123;</span><br><span class="line">		h.Swap(i, n)</span><br><span class="line">		<span class="keyword">if</span> !down(h, i, n) &#123;</span><br><span class="line">			up(h, i)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> h.Pop()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fix re-establishes the heap ordering after the element at index i has changed its value.</span></span><br><span class="line"><span class="comment">// Changing the value of the element at index i and then calling Fix is equivalent to,</span></span><br><span class="line"><span class="comment">// but less expensive than, calling Remove(h, i) followed by a Push of the new value.</span></span><br><span class="line"><span class="comment">// The complexity is O(log n) where n = h.Len().</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Fix</span><span class="params">(h Interface, i <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> !down(h, i, h.Len()) &#123;</span><br><span class="line">		up(h, i)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">up</span><span class="params">(h Interface, j <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		i := (j - <span class="number">1</span>) / <span class="number">2</span> <span class="comment">// parent</span></span><br><span class="line">		<span class="keyword">if</span> i == j || !h.Less(j, i) &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		h.Swap(i, j)</span><br><span class="line">		j = i</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">down</span><span class="params">(h Interface, i0, n <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	i := i0</span><br><span class="line">	<span class="keyword">for</span> &#123;</span><br><span class="line">		j1 := <span class="number">2</span>*i + <span class="number">1</span></span><br><span class="line">		<span class="keyword">if</span> j1 &gt;= n || j1 &lt; <span class="number">0</span> &#123; <span class="comment">// j1 &lt; 0 after int overflow</span></span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		j := j1 <span class="comment">// left child</span></span><br><span class="line">		<span class="keyword">if</span> j2 := j1 + <span class="number">1</span>; j2 &lt; n &amp;&amp; h.Less(j2, j1) &#123;</span><br><span class="line">			j = j2 <span class="comment">// = 2*i + 2  // right child</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> !h.Less(j, i) &#123;</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		h.Swap(i, j)</span><br><span class="line">		i = j</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> i &gt; i0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Golang</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-V2-41-数据流中的中位数</title>
    <url>/2022/11/24/%E5%89%91%E6%8C%87offer-V2-41-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/</url>
    <content><![CDATA[<h1 id="剑指offer-V2-41-数据流中的中位数"><a href="#剑指offer-V2-41-数据流中的中位数" class="headerlink" title="剑指offer-V2-41-数据流中的中位数"></a>剑指offer-V2-41-数据流中的中位数</h1><p><a href="https://leetcode.cn/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof/description/?favorite=xb9nqhhg">原题点这里</a></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202211241316439.png" alt=""></p>
<span id="more"></span>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>常规思路是用一个数组保存数据，每次插入数据使用二分查找找到应该插入的位置，每次查找中位数直接返回数组中间的元素。这样做插入的时间复杂度是O(N)，包括查找位置的O(logN)和移动数组元素的O(N)。</p>
<p>我们采用另一种思路，可以将插入时间复杂度优化到O(N)。使用两个堆，小根堆minHeap和大根堆maxHeap，其中minHeap保存所有元素中较大的一半，maxHeap保存所有元素中较小的一半。假设minHeap元素个数为m个，maxHeap元素个数为n个，</p>
<p>插入元素时：</p>
<ul>
<li>如果m+n为偶数，则插入一个元素到maxHeap，做法是先插入元素到minHeap，然后将minHeap出堆的元素插入到maxHeap。</li>
<li>如果m+n为奇数，则插入一个元素到minHeap，做法是先插入元素到maxHeap，然后将maxHeap出堆的元素插入到minHeap。</li>
</ul>
<p>这么做是为了保证minHeap始终保存较大一半元素，minHeap始终保存较小一半元素。</p>
<p>返回中位数时：</p>
<ul>
<li>如果m+n为偶数，那么说明m和n均为偶数或者均为奇数，因此直接返回两个堆堆顶元素的平均值即可。</li>
<li>如果m+n为奇数，说明有一个堆是奇数，那么一定是maxHeap，因为在插入时，如果m+n是偶数我们是插入到maxHeap的，插入后整个m+n就是奇数了，也就是说maxHeap中元素数是始终大于等于minHeap中元素数的。</li>
</ul>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;container/heap&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> IntHeap <span class="keyword">struct</span> &#123;</span><br><span class="line">	heap  []<span class="type">int</span></span><br><span class="line">	isMin <span class="type">bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span></span> Len() <span class="type">int</span> &#123; <span class="keyword">return</span> <span class="built_in">len</span>(h.heap) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> h.isMin &#123;</span><br><span class="line">		<span class="keyword">return</span> h.heap[i] &lt; h.heap[j]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> h.heap[i] &gt; h.heap[j]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span></span> Swap(i, j <span class="type">int</span>) &#123; h.heap[i], h.heap[j] = h.heap[j], h.heap[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span></span> Pop() <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">	x := h.heap[h.Len()<span class="number">-1</span>]</span><br><span class="line">	h.heap = h.heap[:h.Len()<span class="number">-1</span>]</span><br><span class="line">	<span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *IntHeap)</span></span> Push(num <span class="keyword">interface</span>&#123;&#125;) &#123;</span><br><span class="line">	h.heap = <span class="built_in">append</span>(h.heap, num.(<span class="type">int</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MedianFinder <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">// 用于保存较大的一半</span></span><br><span class="line">	minHeap IntHeap</span><br><span class="line">	<span class="comment">// 用于保存较小的一半</span></span><br><span class="line">	maxHeap IntHeap</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** initialize your data structure here. */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span></span> MedianFinder &#123;</span><br><span class="line">	m := MedianFinder&#123;</span><br><span class="line">		minHeap: IntHeap&#123;</span><br><span class="line">			heap:  <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>),</span><br><span class="line">			isMin: <span class="literal">true</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">		maxHeap: IntHeap&#123;</span><br><span class="line">			heap:  <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>),</span><br><span class="line">			isMin: <span class="literal">false</span>,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line">	heap.Init(&amp;m.maxHeap)</span><br><span class="line">	heap.Init(&amp;m.minHeap)</span><br><span class="line">	<span class="keyword">return</span> m</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MedianFinder)</span></span> AddNum(num <span class="type">int</span>) &#123;</span><br><span class="line">	<span class="comment">// 如果当前总数是偶数，就插入一个元素到maxHeap，但是应当先入堆minHeap，再将其堆顶入堆maxHeap，这么做是为了保证minHeap始终保存较大一半元素，minHeap始终保存较小一半元素。</span></span><br><span class="line">	<span class="keyword">if</span> (this.maxHeap.Len()+this.minHeap.Len())%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">		heap.Push(&amp;this.minHeap, num)</span><br><span class="line">		heap.Push(&amp;this.maxHeap, heap.Pop(&amp;this.minHeap))</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// 如果是奇数，插入元素到minHeap</span></span><br><span class="line">		heap.Push(&amp;this.maxHeap, num)</span><br><span class="line">		heap.Push(&amp;this.minHeap, heap.Pop(&amp;this.maxHeap))</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MedianFinder)</span></span> FindMedian() <span class="type">float64</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (this.maxHeap.Len()+this.minHeap.Len())%<span class="number">2</span> == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="type">float64</span>(this.maxHeap.heap[<span class="number">0</span>]+this.minHeap.heap[<span class="number">0</span>]) / <span class="number">2</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="type">float64</span>(this.maxHeap.heap[<span class="number">0</span>])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MedianFinder object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * obj := Constructor();</span></span><br><span class="line"><span class="comment"> * obj.AddNum(num);</span></span><br><span class="line"><span class="comment"> * param_2 := obj.FindMedian();</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>offer</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-V2-42-连续子数组的最大和</title>
    <url>/2022/11/25/%E5%89%91%E6%8C%87offer-V2-42-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C/</url>
    <content><![CDATA[<h1 id="剑指offer-V2-42-连续子数组的最大和"><a href="#剑指offer-V2-42-连续子数组的最大和" class="headerlink" title="剑指offer-V2-42-连续子数组的最大和"></a>剑指offer-V2-42-连续子数组的最大和</h1><p><a href="https://leetcode.cn/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/description/">原题点这里</a></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202211251055280.png" alt=""></p>
<span id="more"></span>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>动态规划，使用一个长度为len(nums)的dp数组，其中dp[i]代表的是nums数组中以下标i元素结尾的连续子数组的最大和。因为本题的答案，连续子数组的最大和，一定也是以nums数组中的某一个元素结尾的，所以遍历完成dp数组，最终结果就是dp数组中的最大值。为什么是以nums中下标i结尾呢？这是为了保证数组的连续性。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSubArray</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="comment">// dp[i]代表以下标i结尾的最大连续子数组和，相当于一定包含了nums[i]这个元素，因为要保证连续性。</span></span><br><span class="line">	dp := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(nums))</span><br><span class="line">	dp[<span class="number">0</span>] = nums[<span class="number">0</span>]</span><br><span class="line">	ret := dp[<span class="number">0</span>]</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> dp[i<span class="number">-1</span>] &gt; <span class="number">0</span> &#123;</span><br><span class="line">			dp[i] = dp[i<span class="number">-1</span>] + nums[i]</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			dp[i] = nums[i]</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> dp[i] &gt; ret &#123;</span><br><span class="line">			ret = dp[i]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>offer</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-V2-43-1～n 整数中 1 出现的次数</title>
    <url>/2022/11/25/%E5%89%91%E6%8C%87offer-V2-43-1%EF%BD%9En-%E6%95%B4%E6%95%B0%E4%B8%AD-1-%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</url>
    <content><![CDATA[<h1 id="剑指offer-V2-43-1～n-整数中-1-出现的次数"><a href="#剑指offer-V2-43-1～n-整数中-1-出现的次数" class="headerlink" title="剑指offer-V2-43-1～n 整数中 1 出现的次数"></a>剑指offer-V2-43-1～n 整数中 1 出现的次数</h1><p><a href="https://leetcode.cn/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/description/">原题点这里</a></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202211251102742.png" alt=""></p>
<span id="more"></span>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>毫无思路，还是看<a href="https://leetcode.cn/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/solutions/229751/mian-shi-ti-43-1n-zheng-shu-zhong-1-chu-xian-de-2/">k神的题解</a>吧。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">countDigitOne</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	ret := <span class="number">0</span></span><br><span class="line">	digit := <span class="number">1</span></span><br><span class="line">	high, low := n/<span class="number">10</span>, <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;</span><br><span class="line">		cur := n % <span class="number">10</span></span><br><span class="line">		high = n / <span class="number">10</span></span><br><span class="line">		<span class="keyword">switch</span> cur &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">			ret += high * digit</span><br><span class="line">		<span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">			ret += high*digit + low + <span class="number">1</span></span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			ret += (high + <span class="number">1</span>) * digit</span><br><span class="line">		&#125;</span><br><span class="line">		low = cur * digit</span><br><span class="line">		digit *= <span class="number">10</span></span><br><span class="line">		n /= <span class="number">10</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>offer</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-V2-44-数字序列中某一位的数字</title>
    <url>/2022/11/28/%E5%89%91%E6%8C%87offer-V2-44-%E6%95%B0%E5%AD%97%E5%BA%8F%E5%88%97%E4%B8%AD%E6%9F%90%E4%B8%80%E4%BD%8D%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h1 id="剑指offer-V2-44-数字序列中某一位的数字"><a href="#剑指offer-V2-44-数字序列中某一位的数字" class="headerlink" title="剑指offer-V2-44-数字序列中某一位的数字"></a>剑指offer-V2-44-数字序列中某一位的数字</h1><p><a href="https://leetcode.cn/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof/description/">原题点这里</a></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202211281101773.png" alt=""></p>
<span id="more"></span>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>分三步走。</p>
<ul>
<li>第一，确定该位对应数字所在的digit</li>
</ul>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202211281104107.png" alt=""></p>
<ul>
<li>第二，确定该位数字</li>
</ul>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202211281104601.png" alt=""></p>
<ul>
<li>第三，确定该位结果</li>
</ul>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202211281106649.png" alt=""></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findNthDigit</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> n == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	digit, start, count := <span class="number">1</span>, <span class="number">1</span>, <span class="number">9</span></span><br><span class="line">	<span class="keyword">for</span> n &gt; count &#123;</span><br><span class="line">		n -= count</span><br><span class="line">		start *= <span class="number">10</span></span><br><span class="line">		digit += <span class="number">1</span></span><br><span class="line">		count = <span class="number">9</span> * start * digit</span><br><span class="line">	&#125;</span><br><span class="line">	num := start + (n<span class="number">-1</span>)/digit</span><br><span class="line">	numStr := strconv.Itoa(num)</span><br><span class="line">	<span class="keyword">return</span> <span class="type">int</span>(numStr[(n<span class="number">-1</span>)%digit] - <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>offer</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-V2-46-把数字翻译成字符串</title>
    <url>/2022/11/28/%E5%89%91%E6%8C%87offer-V2-46-%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="剑指offer-V2-46-把数字翻译成字符串"><a href="#剑指offer-V2-46-把数字翻译成字符串" class="headerlink" title="剑指offer-V2-46-把数字翻译成字符串"></a>剑指offer-V2-46-把数字翻译成字符串</h1><p><a href="">原题点这里</a></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202211281109976.png" alt=""></p>
<span id="more"></span>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>动态规划，dp[i]代表以第i位结尾的子数字有多少种可能。dp[0]=1，dp[1]取决于第1位和第0位的组合是否大于25。dp[i]取决于dp[i-1]和dp[i-2]，如果当前位和前一位组合起来小于25，那么dp[i]=dp[i-1]+dp[i-2]，dp[i-1]代表不和前一位组合，直接继承；dp[i-2]代表和前一位组合，那么此时的结果继承于dp[i-2]。如果大于25，那么只有一种可能，就是不组合直接继承dp[i-1]。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">translateNum</span><span class="params">(num <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	cs := []<span class="type">byte</span>(strconv.Itoa(num))</span><br><span class="line">	dp := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(cs))</span><br><span class="line">	dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(cs) &gt; <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> <span class="number">10</span>*<span class="type">int</span>(cs[<span class="number">0</span>]-<span class="string">&#x27;0&#x27;</span>)+<span class="type">int</span>(cs[<span class="number">1</span>]-<span class="string">&#x27;0&#x27;</span>) &lt;= <span class="number">25</span> &#123;</span><br><span class="line">			dp[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			dp[<span class="number">1</span>] = <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">2</span>; i &lt; <span class="built_in">len</span>(cs); i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> cs[i<span class="number">-1</span>] != <span class="string">&#x27;0&#x27;</span> &amp;&amp; <span class="number">10</span>*<span class="type">int</span>(cs[i<span class="number">-1</span>]-<span class="string">&#x27;0&#x27;</span>)+<span class="type">int</span>(cs[i]-<span class="string">&#x27;0&#x27;</span>) &lt;= <span class="number">25</span> &#123;</span><br><span class="line">			dp[i] = dp[i<span class="number">-1</span>] + dp[i<span class="number">-2</span>]</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			dp[i] = dp[i<span class="number">-1</span>]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[<span class="built_in">len</span>(dp)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>offer</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-V2-47-礼物的最大价值</title>
    <url>/2022/11/29/%E5%89%91%E6%8C%87offer-V2-47-%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC/</url>
    <content><![CDATA[<h1 id="剑指offer-V2-47-礼物的最大价值"><a href="#剑指offer-V2-47-礼物的最大价值" class="headerlink" title="剑指offer-V2-47-礼物的最大价值"></a>剑指offer-V2-47-礼物的最大价值</h1><p><a href="https://leetcode.cn/problems/li-wu-de-zui-da-jie-zhi-lcof/description/">原题点这里</a></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202211291022476.png" alt=""></p>
<span id="more"></span>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>动态规划，dp[i] [j]代表从位置(i, j)出发到达右下角能获得的礼物最大价值，因此需要从下往上、从右往左遍历grid，补全dp值，最后返回dp[0] [0]。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxValue</span><span class="params">(grid [][]<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(grid) == <span class="number">0</span> || <span class="built_in">len</span>(grid[<span class="number">0</span>]) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	dp := <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="built_in">len</span>(grid))</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(grid); i++ &#123;</span><br><span class="line">		dp[i] = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(grid[<span class="number">0</span>]))</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> isValid <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span></span><br><span class="line">	isValid = <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> i &gt;= <span class="number">0</span> &amp;&amp; i &lt; <span class="built_in">len</span>(grid) &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; j &lt; <span class="built_in">len</span>(grid[<span class="number">0</span>])</span><br><span class="line">	&#125;</span><br><span class="line">	dp[<span class="built_in">len</span>(grid)<span class="number">-1</span>][<span class="built_in">len</span>(grid[<span class="number">0</span>])<span class="number">-1</span>] = grid[<span class="built_in">len</span>(grid)<span class="number">-1</span>][<span class="built_in">len</span>(grid[<span class="number">0</span>])<span class="number">-1</span>]</span><br><span class="line">	<span class="keyword">for</span> i := <span class="built_in">len</span>(grid) - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">		<span class="keyword">for</span> j := <span class="built_in">len</span>(grid[<span class="number">0</span>]) - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j-- &#123;</span><br><span class="line">			<span class="keyword">if</span> j == <span class="built_in">len</span>(grid[<span class="number">0</span>])<span class="number">-1</span> &amp;&amp; i == <span class="built_in">len</span>(grid)<span class="number">-1</span> &#123;</span><br><span class="line">				<span class="keyword">continue</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 右边</span></span><br><span class="line">			<span class="keyword">if</span> isValid(i, j+<span class="number">1</span>) &#123;</span><br><span class="line">				dp[i][j] = grid[i][j] + dp[i][j+<span class="number">1</span>]</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">// 下边</span></span><br><span class="line">			<span class="keyword">if</span> isValid(i+<span class="number">1</span>, j) &#123;</span><br><span class="line">				dp[i][j] = max(dp[i][j], grid[i][j]+dp[i+<span class="number">1</span>][j])</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>offer</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-V2-48-最长不含重复字符的子字符串</title>
    <url>/2022/11/29/%E5%89%91%E6%8C%87offer-V2-48-%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="剑指offer-V2-48-最长不含重复字符的子字符串"><a href="#剑指offer-V2-48-最长不含重复字符的子字符串" class="headerlink" title="剑指offer-V2-48-最长不含重复字符的子字符串"></a>剑指offer-V2-48-最长不含重复字符的子字符串</h1><p><a href="https://leetcode.cn/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof/description/">原题点这里</a></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202211291031861.png" alt=""></p>
<span id="more"></span>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>哈希表+滑动窗口。哈希表中保存的是每一次字符上一次出现的位置，如果滑动窗口的最后一位的字符出现过，那么计算当前子串长度，并且更新滑动窗口开始位置，是该字符上一次出现位置的下一个位置。对于滑到字符串末尾需要特殊考虑。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(s) &lt; <span class="number">2</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">len</span>(s)</span><br><span class="line">	&#125;</span><br><span class="line">	ret := <span class="number">0</span></span><br><span class="line">	cs := []<span class="type">byte</span>(s)</span><br><span class="line">	m := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">byte</span>]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">	start, end := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> end &lt; <span class="built_in">len</span>(cs) &#123;</span><br><span class="line">		<span class="keyword">if</span> idx, ok := m[cs[end]]; ok &amp;&amp; idx &gt;= start &#123;</span><br><span class="line">			ret = max2(ret, end-start)</span><br><span class="line">			start = idx + <span class="number">1</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> end == <span class="built_in">len</span>(cs)<span class="number">-1</span> &#123;</span><br><span class="line">			ret = max2(ret, end-start+<span class="number">1</span>)</span><br><span class="line">			<span class="keyword">break</span></span><br><span class="line">		&#125;</span><br><span class="line">		m[cs[end]] = end</span><br><span class="line">		end++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">max2</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>offer</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-V2-49-丑数</title>
    <url>/2022/11/30/%E5%89%91%E6%8C%87offer-V2-49-%E4%B8%91%E6%95%B0/</url>
    <content><![CDATA[<h1 id="剑指offer-V2-49-丑数"><a href="#剑指offer-V2-49-丑数" class="headerlink" title="剑指offer-V2-49-丑数"></a>剑指offer-V2-49-丑数</h1><p><a href="https://leetcode.cn/problems/chou-shu-lcof/description/">原题点这里</a></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202211301328089.png" alt=""></p>
<span id="more"></span>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>动态规划，dp[i]代表第i+1个丑数。观察可以发现，排在后面的丑数一定可以由前面的丑数乘以2、3、5中的一个得到。因此，我们只需要计算整个dp数组最终返回最后一个元素即可，计算时应该按照从小到大的顺序放入dp数组。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nthUglyNumber</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	dp := <span class="built_in">make</span>([]<span class="type">int</span>, n)</span><br><span class="line">	dp[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">	a, b, c := <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; n; i++ &#123;</span><br><span class="line">		dp[i] = min(dp[a]*<span class="number">2</span>, dp[b]*<span class="number">3</span>, dp[c]*<span class="number">5</span>)</span><br><span class="line">		<span class="keyword">if</span> dp[i] == dp[a]*<span class="number">2</span> &#123;</span><br><span class="line">			a++</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> dp[i] == dp[b]*<span class="number">3</span> &#123;</span><br><span class="line">			b++</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> dp[i] == dp[c]*<span class="number">5</span> &#123;</span><br><span class="line">			c++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dp[n<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">min</span><span class="params">(a, b, c <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> a &lt;= b &amp;&amp; a &lt;= c &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> b &lt;= a &amp;&amp; b &lt;= c &#123;</span><br><span class="line">		<span class="keyword">return</span> b</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>offer</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-V2-50-第一个只出现一次的字符</title>
    <url>/2022/12/01/%E5%89%91%E6%8C%87offer-V2-50-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6/</url>
    <content><![CDATA[<h1 id="剑指offer-V2-50-第一个只出现一次的字符"><a href="#剑指offer-V2-50-第一个只出现一次的字符" class="headerlink" title="剑指offer-V2-50-第一个只出现一次的字符"></a>剑指offer-V2-50-第一个只出现一次的字符</h1><p><a href="https://leetcode.cn/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof/description/">原题点这里</a></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202212011123885.png" alt=""></p>
<span id="more"></span>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>哈希表思想， 用数组当哈希表节省存储空间。两遍遍历字符串，第一遍统计次数，第二遍从前往后如果当前字符出现次数为1那么直接返回。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">firstUniqChar</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">byte</span> &#123;</span><br><span class="line">	m := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">26</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">		m[s[i]-<span class="string">&#x27;a&#x27;</span>]++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(s); i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> m[s[i]-<span class="string">&#x27;a&#x27;</span>] == <span class="number">1</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> s[i]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&#x27; &#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>offer</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-V2-51-数组中的逆序对</title>
    <url>/2022/12/02/%E5%89%91%E6%8C%87offer-V2-51-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9/</url>
    <content><![CDATA[<h1 id="剑指offer-V2-51-数组中的逆序对"><a href="#剑指offer-V2-51-数组中的逆序对" class="headerlink" title="剑指offer-V2-51-数组中的逆序对"></a>剑指offer-V2-51-数组中的逆序对</h1><p><a href="https://leetcode.cn/problems/shu-zu-zhong-de-ni-xu-dui-lcof/description/?q=golang&amp;orderBy=most_relevant">原题点这里</a></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202212021427238.png" alt=""></p>
<span id="more"></span>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>归并排序，在合并两个数组的时候需要比较两个数组中元素的大小，如果左边数组元素大于右边元素，那么代表左边数组从当前元素开始往右均大于右边数组当前元素，那么都可以组成逆序对。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reversePairs</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	cnt := <span class="number">0</span></span><br><span class="line">	<span class="keyword">var</span> mergeSort <span class="function"><span class="keyword">func</span><span class="params">(low, high <span class="type">int</span>, arr []<span class="type">int</span>)</span></span> []<span class="type">int</span></span><br><span class="line">	mergeSort = <span class="function"><span class="keyword">func</span><span class="params">(low, high <span class="type">int</span>, arr []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> low == high &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">append</span>(<span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>), arr[low])</span><br><span class="line">		&#125;</span><br><span class="line">		mid := (low + high) / <span class="number">2</span></span><br><span class="line">		left := mergeSort(low, mid, arr)</span><br><span class="line">		right := mergeSort(mid+<span class="number">1</span>, high, arr)</span><br><span class="line">		sorted := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">		i, j := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">		<span class="keyword">for</span> i &lt; <span class="built_in">len</span>(left) &amp;&amp; j &lt; <span class="built_in">len</span>(right) &#123;</span><br><span class="line">			<span class="keyword">if</span> left[i] &lt;= right[j] &#123;</span><br><span class="line">				sorted = <span class="built_in">append</span>(sorted, left[i])</span><br><span class="line">				i++</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				sorted = <span class="built_in">append</span>(sorted, right[j])</span><br><span class="line">				cnt += <span class="built_in">len</span>(left) - i</span><br><span class="line">				j++</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> i == <span class="built_in">len</span>(left) &#123;</span><br><span class="line">			sorted = <span class="built_in">append</span>(sorted, right[j:]...)</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			sorted = <span class="built_in">append</span>(sorted, left[i:]...)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sorted</span><br><span class="line">	&#125;</span><br><span class="line">	mergeSort(<span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span>, nums)</span><br><span class="line">	<span class="keyword">return</span> cnt</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>offer</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-V2-53-1-在排序数组中查找数字 I</title>
    <url>/2022/12/04/%E5%89%91%E6%8C%87offer-V2-53-1-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97-I/</url>
    <content><![CDATA[<h1 id="剑指offer-V2-53-1-在排序数组中查找数字-I"><a href="#剑指offer-V2-53-1-在排序数组中查找数字-I" class="headerlink" title="剑指offer-V2-53-1-在排序数组中查找数字 I"></a>剑指offer-V2-53-1-在排序数组中查找数字 I</h1><p><a href="https://leetcode.cn/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof/description/">原题点这里</a></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202212041351784.png" alt=""></p>
<span id="more"></span>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>使用二分查找找到两个下标，start下标代表数组中第一个等于target的下标，end代表数组中第一个大于target的下标，二者相减代表target的个数。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">search</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// start-第一个等于target的下标；end-第一个大于target的下标</span></span><br><span class="line">	start, end := <span class="number">-1</span>, <span class="number">-1</span></span><br><span class="line">	<span class="comment">// 找到第一个等于target的下标</span></span><br><span class="line">	low, high := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">	<span class="keyword">for</span> low &lt; high &#123;</span><br><span class="line">		mid := (low + high) / <span class="number">2</span></span><br><span class="line">		<span class="keyword">if</span> nums[mid] == target &#123;</span><br><span class="line">			high = mid</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &gt; target &#123;</span><br><span class="line">			high = mid - <span class="number">1</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			low = mid + <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> nums[low] != target &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	start = low</span><br><span class="line">	<span class="comment">// 找到第一个大于target的下标</span></span><br><span class="line">	low, high = <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">	<span class="keyword">for</span> low &lt;= high &#123;</span><br><span class="line">		mid := (low + high) / <span class="number">2</span></span><br><span class="line">		<span class="keyword">if</span> nums[mid] &gt; target &#123;</span><br><span class="line">			high = mid - <span class="number">1</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			low = mid + <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	end = low</span><br><span class="line">	<span class="keyword">return</span> end - start</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>offer</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-V2-52-两个链表的第一个公共节点</title>
    <url>/2022/12/04/%E5%89%91%E6%8C%87offer-V2-52-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h1 id="剑指offer-V2-52-两个链表的第一个公共节点"><a href="#剑指offer-V2-52-两个链表的第一个公共节点" class="headerlink" title="剑指offer-V2-52-两个链表的第一个公共节点"></a>剑指offer-V2-52-两个链表的第一个公共节点</h1><p><a href="https://leetcode.cn/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof/description/">原题点这里</a></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202212041336855.png" alt=""></p>
<span id="more"></span>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202212041337455.png" alt=""></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202212041338381.png" alt=""></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>遍历两个链表两次，第一次遍历自己，自己走完之后第二次遍历另一个链表。</p>
<blockquote>
<p>“我走过我的世界，再从你的世界走一遍”<br>“你走过你的世界，再从我的世界走一遍”<br>“最终我们将相遇，可能在途中（公共节点），可能在结尾（null）”</p>
</blockquote>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getIntersectionNode</span><span class="params">(headA, headB *ListNode)</span></span> *ListNode &#123;</span><br><span class="line">	<span class="keyword">if</span> headA == <span class="literal">nil</span> || headB == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	pA, pB := headA, headB</span><br><span class="line">	<span class="keyword">for</span> pA != pB &#123;</span><br><span class="line">		<span class="keyword">if</span> pA == <span class="literal">nil</span> &#123;</span><br><span class="line">			pA = headB</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			pA = pA.Next</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> pB == <span class="literal">nil</span> &#123;</span><br><span class="line">			pB = headA</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			pB = pB.Next</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> pA</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>offer</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-V2-54-二叉搜索树的第k大节点</title>
    <url>/2022/12/05/%E5%89%91%E6%8C%87offer-V2-54-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E5%A4%A7%E8%8A%82%E7%82%B9/</url>
    <content><![CDATA[<h1 id="剑指offer-V2-54-二叉搜索树的第k大节点"><a href="#剑指offer-V2-54-二叉搜索树的第k大节点" class="headerlink" title="剑指offer-V2-54-二叉搜索树的第k大节点"></a>剑指offer-V2-54-二叉搜索树的第k大节点</h1><p><a href="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof/description/">原题点这里</a></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202212051021264.png" alt=""></p>
<span id="more"></span>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>常规思路是中序遍历二叉树得到一个递增数组，返回这个数组中len(nums)-k下标处的元素即可。但是可以采用<strong>倒中序遍历</strong>来优化，当倒中序遍历到第k个元素时提前返回。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">kthLargest</span><span class="params">(root *TreeNode, k <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	ret := root.Val</span><br><span class="line">	<span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span></span><br><span class="line">	dfs = <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		dfs(root.Right)</span><br><span class="line">		<span class="keyword">if</span> k == <span class="number">0</span> &#123;</span><br><span class="line">			<span class="keyword">return</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> k--; k == <span class="number">0</span> &#123;</span><br><span class="line">			ret = root.Val</span><br><span class="line">		&#125;</span><br><span class="line">		dfs(root.Left)</span><br><span class="line">	&#125;</span><br><span class="line">	dfs(root)</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>offer</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-V2-55-2-二叉树的深度</title>
    <url>/2022/12/06/%E5%89%91%E6%8C%87offer-V2-55-2-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6/</url>
    <content><![CDATA[<h1 id="剑指offer-V2-55-2-二叉树的深度"><a href="#剑指offer-V2-55-2-二叉树的深度" class="headerlink" title="剑指offer-V2-55-2-二叉树的深度"></a>剑指offer-V2-55-2-二叉树的深度</h1><p><a href="https://leetcode.cn/problems/er-cha-shu-de-shen-du-lcof/description/">原题点这里</a></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202212060936428.png" alt=""></p>
<span id="more"></span>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>递归</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxDepth</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	max := <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> a &gt;= b &#123;</span><br><span class="line">			<span class="keyword">return</span> a</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> b</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> dfs <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span></span><br><span class="line">	dfs = <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> max(dfs(root.Left), dfs(root.Right)) + <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> dfs(root)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>offer</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-V2-56-1-数组中数字出现的次数</title>
    <url>/2022/12/07/%E5%89%91%E6%8C%87offer-V2-56-1-%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</url>
    <content><![CDATA[<h1 id="剑指offer-V2-56-1-数组中数字出现的次数"><a href="#剑指offer-V2-56-1-数组中数字出现的次数" class="headerlink" title="剑指offer-V2-56-1-数组中数字出现的次数"></a>剑指offer-V2-56-1-数组中数字出现的次数</h1><p><a href="https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/description/">原题点这里</a></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202212070907121.png" alt=""></p>
<span id="more"></span>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>如果这道题改为除了一个数字之外，其他数字都出现了两次，那么就简单了，可以直接遍历一遍数组，求异或和，最终得到的答案就是结果。因为：a^a=1 a^0=a，相当于是两两相同的数字异或和都是0，最终剩下的那个数字和0异或结果就是本身。</p>
<p>但是这道题是除了两个数字之外，其他数字都出现了两次，那么稍微复杂一点。假设这两个数字分别是a和b，对数组遍历一遍求异或和的结果就是a^b=z。对于z的二进制表示来说，一定有一位是不为0的（反证法，如果全为0则代表a=b）。那么我们就可以借助这一位，将原数组分为两个子数组，分类方法是如果该数字的这一位是否为0，可以预见的是相同的数字一定会被分到一个子数组里，剩下的a和b一定会分到两个子数组中。这样最后只要对两个子数组分别求异或和就得到了a和b的结果。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">singleNumbers</span><span class="params">(nums []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">	x, y := <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">	z := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">		z ^= num</span><br><span class="line">	&#125;</span><br><span class="line">	m := <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> z&amp;m == <span class="number">0</span> &#123;</span><br><span class="line">		m &lt;&lt;= <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">		<span class="keyword">if</span> num&amp;m == <span class="number">0</span> &#123;</span><br><span class="line">			x ^= num</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			y ^= num</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> []<span class="type">int</span>&#123;x, y&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>offer</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-V2-55-2-平衡二叉树</title>
    <url>/2022/12/06/%E5%89%91%E6%8C%87offer-V2-55-2-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<h1 id="剑指offer-V2-55-2-平衡二叉树"><a href="#剑指offer-V2-55-2-平衡二叉树" class="headerlink" title="剑指offer-V2-55-2-平衡二叉树"></a>剑指offer-V2-55-2-平衡二叉树</h1><p><a href="https://leetcode.cn/problems/ping-heng-er-cha-shu-lcof/description/">原题点这里</a></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202212060940910.png" alt=""></p>
<span id="more"></span>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>可以采用较直接的方式，求左子树和右子树的深度，判断差绝对值是否小于2，然后递归判断左子树和右子树。第二种方式，采用剪枝，如果一棵树不是平衡二叉树返回-1。先分别判断左右子树，如果不是直接返回-1，如果是判断下深度差绝对值，同理不满足条件就返回-1，满足条件的话正常返回深度。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * type TreeNode struct &#123;</span></span><br><span class="line"><span class="comment"> *     Val int</span></span><br><span class="line"><span class="comment"> *     Left *TreeNode</span></span><br><span class="line"><span class="comment"> *     Right *TreeNode</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isBalanced</span><span class="params">(root *TreeNode)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> root == <span class="literal">nil</span> || (root.Left == <span class="literal">nil</span> &amp;&amp; root.Right == <span class="literal">nil</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">	&#125;</span><br><span class="line">	max := <span class="function"><span class="keyword">func</span><span class="params">(a, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> a &gt;= b &#123;</span><br><span class="line">			<span class="keyword">return</span> a</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> b</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> recur <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span></span><br><span class="line">	recur = <span class="function"><span class="keyword">func</span><span class="params">(root *TreeNode)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">		&#125;</span><br><span class="line">		left := recur(root.Left)</span><br><span class="line">		<span class="keyword">if</span> left == <span class="number">-1</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">		&#125;</span><br><span class="line">		right := recur(root.Right)</span><br><span class="line">		<span class="keyword">if</span> right == <span class="number">-1</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> left-right &gt;= <span class="number">2</span> || right-left &gt;= <span class="number">2</span> &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> max(left, right) + <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> recur(root) != <span class="number">-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>offer</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-V2-53-2-0～n-1中缺失的数字</title>
    <url>/2022/12/05/%E5%89%91%E6%8C%87offer-V2-53-2-0%EF%BD%9En-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h1 id="剑指offer-V2-53-2-0～n-1中缺失的数字"><a href="#剑指offer-V2-53-2-0～n-1中缺失的数字" class="headerlink" title="剑指offer-V2-53-2-0～n-1中缺失的数字"></a>剑指offer-V2-53-2-0～n-1中缺失的数字</h1><p><a href="https://leetcode.cn/problems/que-shi-de-shu-zi-lcof/description/">原题点这里</a></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202212051016478.png" alt=""></p>
<span id="more"></span>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>有序数组一般都可以采用二分查找的思想。在此题中，利用二分查找找到第一个元素不等于下标的元素下标。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">missingNumber</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="comment">// 找到第一个元素大于下标的元素下标</span></span><br><span class="line">	low, high := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">	<span class="keyword">for</span> low &lt;= high &#123;</span><br><span class="line">		mid := (low + high) / <span class="number">2</span></span><br><span class="line">		<span class="keyword">if</span> nums[mid] == mid &#123;</span><br><span class="line">			<span class="comment">// 说明mid之前的元素都没问题</span></span><br><span class="line">			low = mid + <span class="number">1</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 只有可能是nums[mid] &gt; mid</span></span><br><span class="line">			high = mid - <span class="number">1</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> low</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>offer</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-V2-56-2-数组中数字出现的次数</title>
    <url>/2022/12/08/%E5%89%91%E6%8C%87offer-V2-56-2-%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0/</url>
    <content><![CDATA[<h1 id="剑指offer-V2-56-2-数组中数字出现的次数"><a href="#剑指offer-V2-56-2-数组中数字出现的次数" class="headerlink" title="剑指offer-V2-56-2-数组中数字出现的次数"></a>剑指offer-V2-56-2-数组中数字出现的次数</h1><p><a href="https://leetcode.cn/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof/description/">原题点这里</a></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202212081014866.png" alt=""></p>
<span id="more"></span>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>在数组中所有元素的二进制表示中，统计每一位上1的个数，对结果模3，就是结果。很好理解，出现三次的数字在同一位上一定也是相同的，如果在该位上是1，那么三个数在该位上加起来一定是3，最终模3一定是0，剩下的余数就一定是只出现一次的数字导致的。</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202212081016764.png" alt=""></p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">singleNumber</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(nums) == <span class="number">1</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> nums[<span class="number">0</span>]</span><br><span class="line">	&#125;</span><br><span class="line">	digits := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">31</span>)</span><br><span class="line">	ret := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">		i := <span class="number">0</span></span><br><span class="line">		<span class="keyword">for</span> num != <span class="number">0</span> &#123;</span><br><span class="line">			digits[i] += num &amp; <span class="number">1</span></span><br><span class="line">			num &gt;&gt;= <span class="number">1</span></span><br><span class="line">			i++</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(digits); i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> digits[i] != <span class="number">0</span> &amp;&amp; digits[i]%<span class="number">3</span> != <span class="number">0</span> &#123;</span><br><span class="line">			ret += <span class="type">int</span>(math.Pow(<span class="number">2</span>, <span class="type">float64</span>(i)))</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>offer</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-V2-58-1-翻转单词顺序</title>
    <url>/2022/12/12/%E5%89%91%E6%8C%87offer-V2-58-1-%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="剑指offer-V2-58-1-翻转单词顺序"><a href="#剑指offer-V2-58-1-翻转单词顺序" class="headerlink" title="剑指offer-V2-58-1-翻转单词顺序"></a>剑指offer-V2-58-1-翻转单词顺序</h1><p><a href="https://leetcode.cn/problems/fan-zhuan-dan-ci-shun-xu-lcof/description">原题点这里</a></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202212121249324.png" alt=""></p>
<span id="more"></span>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>双指针确定每一个单词，然后将所有单词顺序反转</p>
<h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>直接用正则表达式确定所有单词，然后反转顺序</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseWords</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	s = strings.Trim(s, <span class="string">&quot; &quot;</span>)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(s) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">	&#125;</span><br><span class="line">	left, right := <span class="built_in">len</span>(s)<span class="number">-1</span>, <span class="built_in">len</span>(s)<span class="number">-1</span></span><br><span class="line">	ret := <span class="string">&quot;&quot;</span></span><br><span class="line">	<span class="keyword">for</span> left &gt;= <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">for</span> left &gt;= <span class="number">0</span> &amp;&amp; s[left] != <span class="string">&#x27; &#x27;</span> &#123;</span><br><span class="line">			left--</span><br><span class="line">		&#125;</span><br><span class="line">		ret += s[left+<span class="number">1</span> : right+<span class="number">1</span>]</span><br><span class="line">		ret += <span class="string">&quot; &quot;</span></span><br><span class="line">		<span class="keyword">for</span> left &gt;= <span class="number">0</span> &amp;&amp; s[left] == <span class="string">&#x27; &#x27;</span> &#123;</span><br><span class="line">			left--</span><br><span class="line">		&#125;</span><br><span class="line">		right = left</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret[:<span class="built_in">len</span>(ret)<span class="number">-1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseWords</span><span class="params">(s <span class="type">string</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	words := regexp.MustCompile(<span class="string">`\s+`</span>).Split(strings.Trim(s, <span class="string">&quot; &quot;</span>), <span class="number">-1</span>)</span><br><span class="line">	<span class="keyword">for</span> i, j := <span class="number">0</span>, <span class="built_in">len</span>(words)<span class="number">-1</span>; i &lt; j; i, j = i+<span class="number">1</span>, j<span class="number">-1</span> &#123;</span><br><span class="line">		words[i], words[j] = words[j], words[i]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> strings.Join(words, <span class="string">&quot; &quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>offer</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-V2-57-和为s的两个数字</title>
    <url>/2022/12/09/%E5%89%91%E6%8C%87offer-V2-57-%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h1 id="剑指offer-V2-57-和为s的两个数字"><a href="#剑指offer-V2-57-和为s的两个数字" class="headerlink" title="剑指offer-V2-57-和为s的两个数字"></a>剑指offer-V2-57-和为s的两个数字</h1><p><a href="https://leetcode.cn/problems/he-wei-sde-liang-ge-shu-zi-lcof/description/">原题点这里</a></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202212091142757.png" alt=""></p>
<span id="more"></span>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>双指针方法。因为数组是递增数组，所以可以通过两个指针的方式逐渐逼近这个target，双指针从一头一尾开始，和如果大于target那就移动high，和如果小于target那就移动low，最终一定能逼近到target。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">twoSum</span><span class="params">(nums []<span class="type">int</span>, target <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">	low, high := <span class="number">0</span>, <span class="built_in">len</span>(nums)<span class="number">-1</span></span><br><span class="line">	<span class="keyword">for</span> low &lt; high &#123;</span><br><span class="line">		<span class="keyword">if</span> nums[low]+nums[high] == target &#123;</span><br><span class="line">			<span class="keyword">return</span> []<span class="type">int</span>&#123;nums[low], nums[high]&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[low]+nums[high] &lt; target &#123;</span><br><span class="line">			low++</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			high--</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>offer</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-V2-57-2-和为s的连续正数序列</title>
    <url>/2022/12/09/%E5%89%91%E6%8C%87offer-V2-57-2-%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97/</url>
    <content><![CDATA[<h1 id="剑指offer-V2-57-2-和为s的连续正数序列"><a href="#剑指offer-V2-57-2-和为s的连续正数序列" class="headerlink" title="剑指offer-V2-57-2-和为s的连续正数序列"></a>剑指offer-V2-57-2-和为s的连续正数序列</h1><p><a href="https://leetcode.cn/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof/description/">原题点这里</a></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202212091149748.png" alt=""></p>
<span id="more"></span>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>双指针，设置low和high，如果从low到high的和等于target，那么加入结果；如果小于，那么先移动high++，再把当前high加入到和中；如果大于，说明从当前这个low开始已经不合适啦，再往后扫只会越来越大，所以当前和减去low的值，low++，high不动继续扫描。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">findContinuousSequence</span><span class="params">(target <span class="type">int</span>)</span></span> [][]<span class="type">int</span> &#123;</span><br><span class="line">	res := <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">	l, r, sum := <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span><br><span class="line">	<span class="keyword">for</span> l &lt; r &#123;</span><br><span class="line">		<span class="keyword">if</span> sum == target &#123;</span><br><span class="line">			t := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">for</span> i := l; i &lt;= r; i++ &#123;</span><br><span class="line">				t = <span class="built_in">append</span>(t, i)</span><br><span class="line">			&#125;</span><br><span class="line">			res = <span class="built_in">append</span>(res, t)</span><br><span class="line">			sum -= l</span><br><span class="line">			l++</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> sum &gt; target &#123;</span><br><span class="line">			sum -= l</span><br><span class="line">			l++</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			r++</span><br><span class="line">			sum += r</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>offer</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>offer</tag>
      </tags>
  </entry>
  <entry>
    <title>🐑新冠应对指南</title>
    <url>/2022/12/12/%F0%9F%90%91%E6%96%B0%E5%86%A0%E5%BA%94%E5%AF%B9%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h1 id="🐑新冠应对指南"><a href="#🐑新冠应对指南" class="headerlink" title="🐑新冠应对指南"></a>🐑新冠应对指南</h1><h2 id="💊用药篇"><a href="#💊用药篇" class="headerlink" title="💊用药篇"></a>💊用药篇</h2><h3 id="发烧"><a href="#发烧" class="headerlink" title="发烧"></a>发烧</h3><ol>
<li>体温38.5度以下不建议用药</li>
<li>如果超过38.5，用发烧药。下面三种药只能同时用一种：</li>
</ol>
<ul>
<li>布洛芬：冠心病、消化性溃疡（胃溃疡、十二指肠溃疡、上消化道大出血）、用抗凝，抗血小板药物的、肾功能不全的患者不能用。</li>
<li>萘普生</li>
<li>对乙酰氨基酚：肝功能损伤者不能用。每天用量不超过2g，每次不超过0.5g，用药间隔4-6小时。</li>
</ul>
<p>如果吃的感冒药中含有退烧药成分，比如氨酚烷胺、感冒灵、VC银翘片，配料表中有对乙酰氨基酚，吃了这些对不要另外再吃对乙酰氨基酚。</p>
<h3 id="身体疼"><a href="#身体疼" class="headerlink" title="身体疼"></a>身体疼</h3><ul>
<li>疼和发烧有关系，基本上用布洛芬和对乙酰氨基酚都有效。</li>
<li>如果已经退烧了还疼或者效果不好，用羟基氯喹+阿奇霉素。</li>
</ul>
<h3 id="咳嗽"><a href="#咳嗽" class="headerlink" title="咳嗽"></a>咳嗽</h3><ul>
<li>不建议上来就用中枢性的镇咳药，如右美沙芬、咳必清。</li>
<li>先用化痰止咳的药物，如急支糖浆、甘草片、强力枇杷露、川贝枇杷膏，痰多可以用氨溴索，这些只能同时用一种。</li>
</ul>
<h3 id="嗓子哑、疼"><a href="#嗓子哑、疼" class="headerlink" title="嗓子哑、疼"></a>嗓子哑、疼</h3><ul>
<li>含片类，如金嗓子喉宝、西瓜霜润喉片、西地碘含片</li>
<li>熬点大蒜水加点柠檬、红糖。</li>
</ul>
<h3 id="鼻涕鼻塞"><a href="#鼻涕鼻塞" class="headerlink" title="鼻涕鼻塞"></a>鼻涕鼻塞</h3><ul>
<li>用抗阻胺的药物，如扑尔敏（马来酸氯苯那敏）、氯雷他定、西替利嗪、左西替利嗪，只能同时用一种。</li>
<li>维C、葡萄糖酸钙</li>
</ul>
<hr>
<blockquote>
<p>可以准备点中药的颗粒，如小柴胡颗粒、荆防颗粒、藿香正气之类的，一起用效果更佳</p>
</blockquote>
<h2 id="🏥去医院篇"><a href="#🏥去医院篇" class="headerlink" title="🏥去医院篇"></a>🏥去医院篇</h2><p>不要一发烧就去医院，哪些人需要去医院：</p>
<ol>
<li>发烧38.5以上，用了退烧药体温下不去， 持续48小时以上。</li>
<li>发烧39以上，用了退烧药体温下不去， 持续24小时以上。</li>
</ol>
<p>体温下不去指的是：吃了退烧药体温一直下不去，那种下去了又上来的不算。</p>
<ol>
<li>癌症病人，发烧38以上。</li>
<li>拉肚子，呕吐，又吐又拉，持续48小时以上。</li>
<li>24周以后的孕妇，孩子胎动减少。</li>
<li>体温低于35，迷糊不醒。</li>
</ol>
<hr>
<h2 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h2><p>吃好喝好睡好心情好：</p>
<ul>
<li>吃好：高蛋白、高膳食纤维、瓜果蔬菜、鱼肉蛋白奶</li>
<li>喝好：多喝水</li>
<li>睡好：保持充足睡眠，睡觉时细胞会自我修复。</li>
<li>心情好：不要焦虑，病死率是很低的。</li>
</ul>
<hr>
<p>原视频：<a href="https://www.bilibili.com/video/BV1e84y1t7G6/?spm_id_from=333.337.search-card.all.click&amp;vd_source=cc0ec0ffcba65cc37e9d0b7da55a1b5a">https://www.bilibili.com/video/BV1e84y1t7G6/?spm_id_from=333.337.search-card.all.click&amp;vd_source=cc0ec0ffcba65cc37e9d0b7da55a1b5a</a></p>
]]></content>
      <categories>
        <category>新冠😷</category>
      </categories>
      <tags>
        <tag>新冠😷</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-V2-59-1-滑动窗口的最大值</title>
    <url>/2022/12/14/%E5%89%91%E6%8C%87offer-V2-59-1-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
    <content><![CDATA[<h1 id="剑指offer-V2-59-1-滑动窗口的最大值"><a href="#剑指offer-V2-59-1-滑动窗口的最大值" class="headerlink" title="剑指offer-V2-59-1-滑动窗口的最大值"></a>剑指offer-V2-59-1-滑动窗口的最大值</h1><p><a href="https://leetcode.cn/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/description/">原题点这里</a></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202212141711919.png" alt=""></p>
<span id="more"></span>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>维护一个最大堆，将每一个元素加入堆中，此时堆顶为最大元素。但是堆顶元素有可能不在滑动窗口中，因此加入当前元素后，判断一下堆顶元素是否在滑动窗口中，如果不在出堆，循环直到堆顶元素是在滑动窗口中的。如何判断堆顶是否在滑动窗口？可以通过下标来判断。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> data <span class="keyword">struct</span> &#123;</span><br><span class="line">	num   <span class="type">int</span></span><br><span class="line">	index <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> MaxHeap <span class="keyword">struct</span> &#123;</span><br><span class="line">	heap []data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *MaxHeap)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123; <span class="keyword">return</span> h.heap[i].num &gt; h.heap[j].num &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *MaxHeap)</span></span> Swap(i, j <span class="type">int</span>) &#123; h.heap[i], h.heap[j] = h.heap[j], h.heap[i] &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *MaxHeap)</span></span> Len() <span class="type">int</span> &#123; <span class="keyword">return</span> <span class="built_in">len</span>(h.heap) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *MaxHeap)</span></span> Push(x <span class="keyword">interface</span>&#123;&#125;) &#123; h.heap = <span class="built_in">append</span>(h.heap, x.(data)) &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *MaxHeap)</span></span> Pop() <span class="keyword">interface</span>&#123;&#125; &#123;</span><br><span class="line">	x := h.heap[h.Len()<span class="number">-1</span>]</span><br><span class="line">	h.heap = h.heap[:h.Len()<span class="number">-1</span>]</span><br><span class="line">	<span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxSlidingWindow</span><span class="params">(nums []<span class="type">int</span>, k <span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">	ret := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>)</span><br><span class="line">	maxHeap := &amp;MaxHeap&#123;<span class="built_in">make</span>([]data, <span class="number">0</span>)&#125;</span><br><span class="line">	heap.Init(maxHeap)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; k; i++ &#123;</span><br><span class="line">		heap.Push(maxHeap, data&#123;num: nums[i], index: i&#125;)</span><br><span class="line">	&#125;</span><br><span class="line">	ret = <span class="built_in">append</span>(ret, maxHeap.heap[<span class="number">0</span>].num)</span><br><span class="line">	<span class="keyword">for</span> i := k; i &lt; <span class="built_in">len</span>(nums); i++ &#123;</span><br><span class="line">		heap.Push(maxHeap, data&#123;num: nums[i], index: i&#125;)</span><br><span class="line">		<span class="keyword">for</span> i-maxHeap.heap[<span class="number">0</span>].index &gt;= k &#123;</span><br><span class="line">			heap.Pop(maxHeap)</span><br><span class="line">		&#125;</span><br><span class="line">		ret = <span class="built_in">append</span>(ret, maxHeap.heap[<span class="number">0</span>].num)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>offer</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-V2-58-2-左旋转字符串</title>
    <url>/2022/12/13/%E5%89%91%E6%8C%87offer-V2-58-2-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<h1 id="剑指offer-V2-58-2-左旋转字符串"><a href="#剑指offer-V2-58-2-左旋转字符串" class="headerlink" title="剑指offer-V2-58-2-左旋转字符串"></a>剑指offer-V2-58-2-左旋转字符串</h1><p><a href="https://leetcode.cn/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof/description/">原题点这里</a></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202212131028553.png" alt=""></p>
<span id="more"></span>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="思路1"><a href="#思路1" class="headerlink" title="思路1"></a>思路1</h3><p>切片函数直接拼接</p>
<h3 id="思路2"><a href="#思路2" class="headerlink" title="思路2"></a>思路2</h3><p>遍历拼接</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="代码1"><a href="#代码1" class="headerlink" title="代码1"></a>代码1</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseLeftWords</span><span class="params">(s <span class="type">string</span>, n <span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> s[n:] + s[:n+<span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="代码2"><a href="#代码2" class="headerlink" title="代码2"></a>代码2</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseLeftWords</span><span class="params">(s <span class="type">string</span>, n <span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	cs := <span class="built_in">make</span>([]<span class="type">byte</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> i := n; i &lt; <span class="built_in">len</span>(s)+n; i++ &#123;</span><br><span class="line">		cs = <span class="built_in">append</span>(cs, s[i%<span class="built_in">len</span>(s)])</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="type">string</span>(cs)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>offer</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-V2-60-n个骰子的点数</title>
    <url>/2022/12/15/%E5%89%91%E6%8C%87offer-V2-60-n%E4%B8%AA%E9%AA%B0%E5%AD%90%E7%9A%84%E7%82%B9%E6%95%B0/</url>
    <content><![CDATA[<h1 id="剑指offer-V2-60-n个骰子的点数"><a href="#剑指offer-V2-60-n个骰子的点数" class="headerlink" title="剑指offer-V2-60-n个骰子的点数"></a>剑指offer-V2-60-n个骰子的点数</h1><p><a href="https://leetcode.cn/problems/nge-tou-zi-de-dian-shu-lcof/description/">原题点这里</a></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202212151528398.png" alt=""></p>
<span id="more"></span>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>动态规划，用二维数组，dp[i] [j]代表在投掷i枚骰子的情况下，点数和为j的频数。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">dicesProbability</span><span class="params">(n <span class="type">int</span>)</span></span> []<span class="type">float64</span> &#123;</span><br><span class="line">	dp := <span class="built_in">make</span>([][]<span class="type">int</span>, <span class="number">13</span>)</span><br><span class="line">	dp[<span class="number">1</span>] = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">70</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++ &#123;</span><br><span class="line">		dp[<span class="number">1</span>][i] = <span class="number">1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">2</span>; i &lt;= n; i++ &#123;</span><br><span class="line">		dp[i] = <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">70</span>)</span><br><span class="line">		<span class="keyword">for</span> j := i; j &lt;= i*<span class="number">6</span>; j++ &#123;</span><br><span class="line">			<span class="keyword">for</span> k := <span class="number">1</span>; k &lt;= <span class="number">6</span>; k++ &#123;</span><br><span class="line">				<span class="keyword">if</span> j-k &lt;= <span class="number">0</span> &#123;</span><br><span class="line">					<span class="keyword">break</span></span><br><span class="line">				&#125;</span><br><span class="line">				dp[i][j] += dp[i<span class="number">-1</span>][j-k]</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	all := math.Pow(<span class="number">6.0</span>, <span class="type">float64</span>(n))</span><br><span class="line">	ret := <span class="built_in">make</span>([]<span class="type">float64</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">for</span> i := n; i &lt;= n*<span class="number">6</span>; i++ &#123;</span><br><span class="line">		ret = <span class="built_in">append</span>(ret, <span class="type">float64</span>(dp[n][i])/all)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>offer</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-V2-62-圆圈中最后剩下的数字</title>
    <url>/2022/12/16/%E5%89%91%E6%8C%87offer-V2-62-%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h1 id="剑指offer-V2-62-圆圈中最后剩下的数字"><a href="#剑指offer-V2-62-圆圈中最后剩下的数字" class="headerlink" title="剑指offer-V2-62-圆圈中最后剩下的数字"></a>剑指offer-V2-62-圆圈中最后剩下的数字</h1><p><a href="https://leetcode.cn/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/description/">原题点这里</a></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202212160952098.png" alt=""></p>
<span id="more"></span>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>约瑟夫环，直接模拟会超时，采用数学解法。从最后一轮开始，最后一轮只剩下一个元素a，也就是结果，下标为0。那么倒数第二轮有两个元素，并且可以计算出a在这个数组中的下标：(a+m)%2。同理可以一直反推到数组中剩余n个元素，也就是初始状态，得到该状态下a的下标，也就是a的值（因为数组元素从0开始）。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lastRemaining</span><span class="params">(n <span class="type">int</span>, m <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	ret := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">2</span>; i &lt;= n; i++ &#123;</span><br><span class="line">		ret = (ret + m) % i</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>offer</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-V2-63-股票的最大利润</title>
    <url>/2022/12/16/%E5%89%91%E6%8C%87offer-V2-63-%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6/</url>
    <content><![CDATA[<h1 id="剑指offer-V2-63-股票的最大利润"><a href="#剑指offer-V2-63-股票的最大利润" class="headerlink" title="剑指offer-V2-63-股票的最大利润"></a>剑指offer-V2-63-股票的最大利润</h1><p><a href="https://leetcode.cn/problems/gu-piao-de-zui-da-li-run-lcof/description/">原题点这里</a></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202212161010422.png" alt=""></p>
<span id="more"></span>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>动态规划，dp[i]代表从当前天数之前的最小价格买入，在第i天卖出的利润。但是可以设置一个变量从而免去dp数组。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">maxProfit</span><span class="params">(prices []<span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(prices) &lt; <span class="number">2</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	minPrice := prices[<span class="number">0</span>]</span><br><span class="line">	ret :=<span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(prices); i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> prices[i]-minPrice &gt; ret &#123;</span><br><span class="line">			ret = prices[i] - minPrice</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> prices[i] &lt; minPrice &#123;</span><br><span class="line">			minPrice = prices[i]</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>offer</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-V2-64-求1+2+…+n</title>
    <url>/2022/12/17/%E5%89%91%E6%8C%87offer-V2-64-%E6%B1%821-2-%E2%80%A6-n/</url>
    <content><![CDATA[<h1 id="剑指offer-V2-64-求1-2-…-n"><a href="#剑指offer-V2-64-求1-2-…-n" class="headerlink" title="剑指offer-V2-64-求1+2+…+n"></a>剑指offer-V2-64-求1+2+…+n</h1><p><a href="https://leetcode.cn/problems/qiu-12n-lcof/description/">原题点这里</a></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202212171217784.png" alt=""></p>
<span id="more"></span>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>可以使用递归，但是不能用常规的判断来做递归终止条件。可以利用逻辑运算符&amp;&amp;的特性，如果&amp;&amp;左边的判断条件不成立就不执行又变的判断，借助这个特性完成递归终止条件。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sumNums</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	ret := <span class="number">0</span></span><br><span class="line">	<span class="keyword">var</span> recur <span class="function"><span class="keyword">func</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span></span><br><span class="line">	recur = <span class="function"><span class="keyword">func</span><span class="params">(n <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">		_ = n &gt; <span class="number">1</span> &amp;&amp; recur(n<span class="number">-1</span>) &gt; <span class="number">0</span></span><br><span class="line">		ret += n</span><br><span class="line">		<span class="keyword">return</span> ret</span><br><span class="line">	&#125;</span><br><span class="line">	recur(n)</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>offer</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-V2-65-不用加减乘除做加法</title>
    <url>/2022/12/17/%E5%89%91%E6%8C%87offer-V2-65-%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95/</url>
    <content><![CDATA[<h1 id="剑指offer-V2-65-不用加减乘除做加法"><a href="#剑指offer-V2-65-不用加减乘除做加法" class="headerlink" title="剑指offer-V2-65-不用加减乘除做加法"></a>剑指offer-V2-65-不用加减乘除做加法</h1><p><a href="https://leetcode.cn/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof/description/">原题点这里</a></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202212171222568.png" alt=""></p>
<span id="more"></span>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>位运算。观察二进制求和以及进位的特点：</p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202212171224301.png" style="zoom:50%;" /></p>
<p>观察发现，无进位和的运算特点满足异或运算：<code>^</code>，进位的特点满足与运算：<code>&amp;</code>（然后左移）。因此只需要循环计算无进位和和进位相加直到没有进位。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a <span class="type">int</span>, b <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> b == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> a</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> add(a^b, (a&amp;b)&lt;&lt;<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>offer</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-V2-66-构建乘积数组</title>
    <url>/2022/12/18/%E5%89%91%E6%8C%87offer-V2-66-%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<h1 id="剑指offer-V2-66-构建乘积数组"><a href="#剑指offer-V2-66-构建乘积数组" class="headerlink" title="剑指offer-V2-66-构建乘积数组"></a>剑指offer-V2-66-构建乘积数组</h1><p><a href="https://leetcode.cn/problems/gou-jian-cheng-ji-shu-zu-lcof/description/?favorite=xb9nqhhg">原题点这里</a></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202212181021917.png" alt=""></p>
<span id="more"></span>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>维护两个dp数组left和right，其中left[i]的值是数组a中下标i对应元素左边的所有元素的乘积，right[i]是数组a中下标i对应元素右边的所有元素的乘积。最终的结果是将left和right对应元素相乘。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">constructArr</span><span class="params">(a []<span class="type">int</span>)</span></span> []<span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(a) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	ret := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(a))</span><br><span class="line">	left, right := <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(a)), <span class="built_in">make</span>([]<span class="type">int</span>, <span class="built_in">len</span>(a))</span><br><span class="line">	left[<span class="number">0</span>], right[<span class="built_in">len</span>(right)<span class="number">-1</span>] = <span class="number">1</span>, <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">1</span>; i &lt; <span class="built_in">len</span>(a); i++ &#123;</span><br><span class="line">		left[i] = left[i<span class="number">-1</span>] * a[i<span class="number">-1</span>]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="built_in">len</span>(a) - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i-- &#123;</span><br><span class="line">		right[i] = right[i+<span class="number">1</span>] * a[i+<span class="number">1</span>]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(ret); i++ &#123;</span><br><span class="line">		ret[i] = left[i] * right[i]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>offer</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-V2-68-1-二叉搜索树的最近公共祖先</title>
    <url>/2022/12/18/%E5%89%91%E6%8C%87offer-V2-68-1-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    <content><![CDATA[<h1 id="剑指offer-V2-68-1-二叉搜索树的最近公共祖先"><a href="#剑指offer-V2-68-1-二叉搜索树的最近公共祖先" class="headerlink" title="剑指offer-V2-68-1-二叉搜索树的最近公共祖先"></a>剑指offer-V2-68-1-二叉搜索树的最近公共祖先</h1><p><a href="https://leetcode.cn/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/description">原题点这里</a></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202212181032203.png" alt=""></p>
<span id="more"></span>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202212181032523.png" alt=""></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>递归，因为所有节点的值都是唯一的，所以如果p或者q的值等于root，那么p或者q就是结果。如果p、q的值分布在root两侧，说明root是结果。如果分布在同侧，那么递归去这一侧查找。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p.val == root.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(q.val == root.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> q;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>((p.val &lt; root.val &amp;&amp; q.val &gt; root.val) || (p.val &gt; root.val &amp;&amp; q.val &lt; root.val)) &#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p.val &lt; root.val)&#123;</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>offer</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-V2-13-机器人的运动范围</title>
    <url>/2022/12/20/%E5%89%91%E6%8C%87offer-V2-13-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/</url>
    <content><![CDATA[<h1 id="剑指offer-V2-13-机器人的运动范围"><a href="#剑指offer-V2-13-机器人的运动范围" class="headerlink" title="剑指offer-V2-13-机器人的运动范围"></a>剑指offer-V2-13-机器人的运动范围</h1><p><a href="https://leetcode.cn/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/description/">原题点这里</a></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202212201106313.png" alt=""></p>
<span id="more"></span>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>深度优先搜索</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">movingCount</span><span class="params">(m <span class="type">int</span>, n <span class="type">int</span>, k <span class="type">int</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	ret := <span class="number">0</span></span><br><span class="line">	visited := <span class="built_in">make</span>([][]<span class="type">bool</span>, m)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; m; i++ &#123;</span><br><span class="line">		visited[i] = <span class="built_in">make</span>([]<span class="type">bool</span>, n)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> valid <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span></span><br><span class="line">	valid = <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">		sum := <span class="number">0</span></span><br><span class="line">		<span class="keyword">for</span> i &gt; <span class="number">0</span> &#123;</span><br><span class="line">			sum += i % <span class="number">10</span></span><br><span class="line">			i /= <span class="number">10</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> j &gt; <span class="number">0</span> &#123;</span><br><span class="line">			sum += j % <span class="number">10</span></span><br><span class="line">			j /= <span class="number">10</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> sum &lt;= k</span><br><span class="line">	&#125;</span><br><span class="line">	dirs := [][]<span class="type">int</span>&#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;&#125;</span><br><span class="line">	<span class="keyword">var</span> recur <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span></span><br><span class="line">	recur = <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">		visited[i][j] = <span class="literal">true</span></span><br><span class="line">		ret++</span><br><span class="line">		<span class="keyword">for</span> _, dir := <span class="keyword">range</span> dirs &#123;</span><br><span class="line">			nextI := i + dir[<span class="number">0</span>]</span><br><span class="line">			nextJ := j + dir[<span class="number">1</span>]</span><br><span class="line">			<span class="keyword">if</span> nextI &gt;= <span class="number">0</span> &amp;&amp; nextI &lt; m &amp;&amp; nextJ &gt;= <span class="number">0</span> &amp;&amp; nextJ &lt; n &amp;&amp; !visited[nextI][nextJ] &amp;&amp; valid(nextI, nextJ) &#123;</span><br><span class="line">				recur(nextI, nextJ)</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	recur(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>offer</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-V2-45-把数组排成最小的数</title>
    <url>/2022/12/20/%E5%89%91%E6%8C%87offer-V2-45-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0/</url>
    <content><![CDATA[<h1 id="剑指offer-V2-45-把数组排成最小的数"><a href="#剑指offer-V2-45-把数组排成最小的数" class="headerlink" title="剑指offer-V2-45-把数组排成最小的数"></a>剑指offer-V2-45-把数组排成最小的数</h1><p><a href="https://leetcode.cn/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/description/">原题点这里</a></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202212201111966.png" alt=""></p>
<span id="more"></span>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>贪心+自定义排序.对于两个数字x和y,如果xy&lt;yx,那么就认为x小于y.将数组进行自定义排序,然后贪心从最小的元素开始拼接结果.</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">minNumber</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line">	ret := <span class="string">&quot;&quot;</span></span><br><span class="line">	sort.Slice(nums, <span class="function"><span class="keyword">func</span><span class="params">(i, j <span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">		ij, _ := strconv.Atoi(strconv.Itoa(nums[i]) + strconv.Itoa(nums[j]))</span><br><span class="line">		ji, _ := strconv.Atoi(strconv.Itoa(nums[j]) + strconv.Itoa(nums[i]))</span><br><span class="line">		<span class="keyword">return</span> ij &lt; ji</span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">for</span> _, num := <span class="keyword">range</span> nums &#123;</span><br><span class="line">		ret += strconv.Itoa(num)</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>offer</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-V2-68-2-二叉树的最近公共祖先</title>
    <url>/2022/12/19/%E5%89%91%E6%8C%87offer-V2-68-2-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88/</url>
    <content><![CDATA[<h1 id="剑指offer-V2-68-2-二叉树的最近公共祖先"><a href="#剑指offer-V2-68-2-二叉树的最近公共祖先" class="headerlink" title="剑指offer-V2-68-2-二叉树的最近公共祖先"></a>剑指offer-V2-68-2-二叉树的最近公共祖先</h1><p><a href="https://leetcode.cn/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/description/">原题点这里</a></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202212191302341.png" alt=""></p>
<span id="more"></span>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>递归，如果left和right都不为空代表p、q分布在root两边。如果left空，代表p、q分布在右侧，那么返回right，反之亦然。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lowestCommonAncestor</span><span class="params">(root, p, q *TreeNode)</span></span> *TreeNode &#123;</span><br><span class="line">	<span class="keyword">if</span> root == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> root.Val == q.Val &#123;</span><br><span class="line">		<span class="keyword">return</span> q</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> root.Val == p.Val &#123;</span><br><span class="line">		<span class="keyword">return</span> p</span><br><span class="line">	&#125;</span><br><span class="line">	left := lowestCommonAncestor(root.Left, p, q)</span><br><span class="line">	right := lowestCommonAncestor(root.Right, p, q)</span><br><span class="line">	<span class="keyword">if</span> left != <span class="literal">nil</span> &amp;&amp; right != <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> root</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> right == <span class="literal">nil</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> left</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> right</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>offer</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-V2-59-2队列的最大值</title>
    <url>/2022/12/21/%E5%89%91%E6%8C%87offer-V2-59-2%E9%98%9F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
    <content><![CDATA[<h1 id="剑指offer-V2-59-2队列的最大值"><a href="#剑指offer-V2-59-2队列的最大值" class="headerlink" title="剑指offer-V2-59-2队列的最大值"></a>剑指offer-V2-59-2队列的最大值</h1><p><a href="https://leetcode.cn/problems/dui-lie-de-zui-da-zhi-lcof/?favorite=xb9nqhhg">原题点这里</a></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202212211048529.png" alt=""></p>
<span id="more"></span>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>一个正常队列+一个双端队列。双端队列用来保存和最大值相关的信息，当入队一个元素是，正常队列正常入队，双端队列则需要将队尾中小于入队元素的元素全部出队，再入队该元素。出队时，如果出队元素正好等于双端队列的队首也就是队列最大值，那么双端队列也需要出队。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> MaxQueue <span class="keyword">struct</span> &#123;</span><br><span class="line">	queue   []<span class="type">int</span></span><br><span class="line">	deQueue []<span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Constructor</span><span class="params">()</span></span> MaxQueue &#123;</span><br><span class="line">	<span class="keyword">return</span> MaxQueue&#123;</span><br><span class="line">		queue:   <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>),</span><br><span class="line">		deQueue: <span class="built_in">make</span>([]<span class="type">int</span>, <span class="number">0</span>),</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MaxQueue)</span></span> Max_value() <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(this.deQueue) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> this.deQueue[<span class="number">0</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MaxQueue)</span></span> Push_back(value <span class="type">int</span>) &#123;</span><br><span class="line">	this.queue = <span class="built_in">append</span>(this.queue, value)</span><br><span class="line">	i := <span class="built_in">len</span>(this.deQueue) - <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> i &gt;= <span class="number">0</span> &amp;&amp; this.deQueue[i] &lt; value &#123;</span><br><span class="line">		i--</span><br><span class="line">	&#125;</span><br><span class="line">	this.deQueue = this.deQueue[:i+<span class="number">1</span>]</span><br><span class="line">	this.deQueue = <span class="built_in">append</span>(this.deQueue, value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(this *MaxQueue)</span></span> Pop_front() <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(this.queue) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">	&#125;</span><br><span class="line">	num := this.queue[<span class="number">0</span>]</span><br><span class="line">	this.queue = this.queue[<span class="number">1</span>:]</span><br><span class="line">	<span class="keyword">if</span> num == this.deQueue[<span class="number">0</span>] &#123;</span><br><span class="line">		this.deQueue = this.deQueue[<span class="number">1</span>:]</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> num</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MaxQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * obj := Constructor();</span></span><br><span class="line"><span class="comment"> * param_1 := obj.Max_value();</span></span><br><span class="line"><span class="comment"> * obj.Push_back(value);</span></span><br><span class="line"><span class="comment"> * param_3 := obj.Pop_front();</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>offer</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-V2-61-扑克牌中的顺子</title>
    <url>/2022/12/21/%E5%89%91%E6%8C%87offer-V2-61-%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90/</url>
    <content><![CDATA[<h1 id="剑指offer-V2-61-扑克牌中的顺子"><a href="#剑指offer-V2-61-扑克牌中的顺子" class="headerlink" title="剑指offer-V2-61-扑克牌中的顺子"></a>剑指offer-V2-61-扑克牌中的顺子</h1><p><a href="https://leetcode.cn/problems/bu-ke-pai-zhong-de-shun-zi-lcof/description/">原题点这里</a></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202212211052442.png" alt=""></p>
<span id="more"></span>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>先排序，接着顺子的充分条件：1.两两元素不重复。2.除了0之外，最大值和最小值的差小于5。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">isStraight</span><span class="params">(nums []<span class="type">int</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">	sort.Ints(nums)</span><br><span class="line">	zeroCount := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(nums)<span class="number">-1</span>; i++ &#123;</span><br><span class="line">		<span class="keyword">if</span> nums[i] == <span class="number">0</span> &#123;</span><br><span class="line">			zeroCount++</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> nums[i+<span class="number">1</span>] == nums[i] &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> nums[<span class="number">4</span>]-nums[zeroCount] &lt; <span class="number">5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>offer</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>offer</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指offer-V2-67-把字符串转换成整数</title>
    <url>/2022/12/22/%E5%89%91%E6%8C%87offer-V2-67-%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0/</url>
    <content><![CDATA[<h1 id="剑指offer-V2-67-把字符串转换成整数"><a href="#剑指offer-V2-67-把字符串转换成整数" class="headerlink" title="剑指offer-V2-67-把字符串转换成整数"></a>剑指offer-V2-67-把字符串转换成整数</h1><p><a href="https://leetcode.cn/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof/description/">原题点这里</a></p>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202212221049238.png" alt=""></p>
<span id="more"></span>
<p><img src="https://foursevenlove.oss-cn-hongkong.aliyuncs.com/pics/202212221049379.png" alt=""></p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>先找到第一个非空字符，判断是否是符号或者数字。接着截取数字部分，舍去字符串末尾，关键在于最后计算结果，注意判断范围。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">strToInt</span><span class="params">(str <span class="type">string</span>)</span></span> <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(str) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> isDigit <span class="function"><span class="keyword">func</span><span class="params">(c <span class="type">byte</span>)</span></span> <span class="type">bool</span></span><br><span class="line">	isDigit = <span class="function"><span class="keyword">func</span><span class="params">(c <span class="type">byte</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> c &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;9&#x27;</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> isSign <span class="function"><span class="keyword">func</span><span class="params">(c <span class="type">byte</span>)</span></span> <span class="type">bool</span></span><br><span class="line">	isSign = <span class="function"><span class="keyword">func</span><span class="params">(c <span class="type">byte</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> c == <span class="string">&#x27;-&#x27;</span> || c == <span class="string">&#x27;+&#x27;</span></span><br><span class="line">	&#125;</span><br><span class="line">	start := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> start &lt; <span class="built_in">len</span>(str) &amp;&amp; str[start] == <span class="string">&#x27; &#x27;</span> &#123;</span><br><span class="line">		start++</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> start &gt;= <span class="built_in">len</span>(str) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> !isDigit(str[start]) &amp;&amp; !isSign(str[start]) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">	&#125;</span><br><span class="line">	negative := str[start] == <span class="string">&#x27;-&#x27;</span></span><br><span class="line">	<span class="keyword">if</span> isSign(str[start]) &#123;</span><br><span class="line">		start++</span><br><span class="line">	&#125;</span><br><span class="line">	end := start</span><br><span class="line">	<span class="keyword">for</span> end &lt; <span class="built_in">len</span>(str) &amp;&amp; isDigit(str[end]) &#123;</span><br><span class="line">		end++</span><br><span class="line">	&#125;</span><br><span class="line">	num := str[start:end]</span><br><span class="line">	ret := <span class="number">0</span></span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="built_in">len</span>(num); i++ &#123;</span><br><span class="line">		ret = ret*<span class="number">10</span> + <span class="type">int</span>(num[i]-<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">		<span class="keyword">if</span> ret &gt; math.MaxInt32 &#123;</span><br><span class="line">			<span class="keyword">if</span> negative &#123;</span><br><span class="line">				<span class="keyword">return</span> math.MinInt32</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> math.MaxInt32</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> negative &#123;</span><br><span class="line">		<span class="keyword">return</span> -ret</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>leetcode</category>
        <category>offer</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>offer</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker必会知识点</title>
    <url>/2023/01/03/Docker%E5%BF%85%E4%BC%9A%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h1 id="Docker必会知识点"><a href="#Docker必会知识点" class="headerlink" title="Docker必会知识点"></a>Docker必会知识点</h1><h2 id="1-常用命令"><a href="#1-常用命令" class="headerlink" title="1.常用命令"></a>1.常用命令</h2><h3 id="1-1-服务"><a href="#1-1-服务" class="headerlink" title="1.1 服务"></a>1.1 服务</h3><ul>
<li>查看Docker版本信息</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker version</span><br></pre></td></tr></table></figure>
<ul>
<li>查看docker简要信息</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker -v</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<ul>
<li>启动Docker</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl start docker</span><br></pre></td></tr></table></figure>
<ul>
<li>关闭docker</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl stop docker</span><br></pre></td></tr></table></figure>
<ul>
<li>设置开机启动</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure>
<ul>
<li>重启docker服务</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service docker restart</span><br></pre></td></tr></table></figure>
<ul>
<li>关闭docker服务</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service docker stop</span><br></pre></td></tr></table></figure>
<h3 id="1-2-镜像"><a href="#1-2-镜像" class="headerlink" title="1.2 镜像"></a>1.2 镜像</h3><ul>
<li>检索镜像</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker search 关键字</span><br></pre></td></tr></table></figure>
<ul>
<li>拉取镜像</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</span><br></pre></td></tr></table></figure>
<ul>
<li>列出镜像</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker image ls</span><br><span class="line">docker images</span><br></pre></td></tr></table></figure>
<ul>
<li>删除镜像</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rmi &lt;镜像Id&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>导出镜像</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker save</span><br></pre></td></tr></table></figure>
<ul>
<li>导入镜像</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker load</span><br></pre></td></tr></table></figure>
<ul>
<li><p>Dockerfile常见指令</p>
<p>FROM：指定基础镜像 </p>
<p>RUN：执行命令 </p>
<p>COPY：复制文件 </p>
<p>ADD：更高级的复制文件 </p>
<p>CMD：容器启动命令 </p>
<p>ENV：设置环境变量 </p>
<p>EXPOSE：暴露端口 </p>
</li>
</ul>
<p>其它的指令还有ENTRYPOINT、ARG、VOLUME、WORKDIR、USER、HEALTHCHECK、ONBUILD、LABEL等等。</p>
<p>以下是一个Dockerfile实例：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">FROM java:8</span><br><span class="line">MAINTAINER &quot;jinshw&quot;&lt;jinshw@qq.com&gt;</span><br><span class="line">ADD mapcharts-0.0.1-SNAPSHOT.jar mapcharts.jar</span><br><span class="line">EXPOSE 8080</span><br><span class="line">CMD java -jar mapcharts.jar</span><br></pre></td></tr></table></figure>
<ul>
<li>镜像构建</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker build</span><br></pre></td></tr></table></figure>
<h3 id="1-3-容器"><a href="#1-3-容器" class="headerlink" title="1.3 容器"></a>1.3 容器</h3><h4 id="1-3-1-容器生命周期"><a href="#1-3-1-容器生命周期" class="headerlink" title="1.3.1 容器生命周期"></a>1.3.1 容器生命周期</h4><ul>
<li>启动：启动容器有两种方式，一种是基于镜像新建一个容器并启动，另外一个是将在终止状态（stopped）的容器重新启动。</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新建并启动</span></span><br><span class="line">docker run [镜像名/镜像ID]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动已终止容器</span></span><br><span class="line">docker start [容器ID]</span><br></pre></td></tr></table></figure>
<ul>
<li>查看容器</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出本机运行的容器</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker ps</span> </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">列出本机所有的容器（包括停止和运行）</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker ps -a</span></span><br></pre></td></tr></table></figure>
<ul>
<li>停止容器</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">停止运行的容器</span></span><br><span class="line">docker stop [容器ID]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">杀死容器进程</span></span><br><span class="line">docker  kill [容器ID] </span><br></pre></td></tr></table></figure>
<ul>
<li>重启容器</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker restart [容器ID] </span><br></pre></td></tr></table></figure>
<ul>
<li>删除容器</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker  rm [容器ID]</span><br></pre></td></tr></table></figure>
<h4 id="1-3-2-进入容器"><a href="#1-3-2-进入容器" class="headerlink" title="1.3.2 进入容器"></a>1.3.2 进入容器</h4><p>进入容器有两种方式：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果从这个 stdin 中 <span class="built_in">exit</span>，会导致容器的停止</span></span><br><span class="line">docker attach [容器ID]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">交互式进入容器</span></span><br><span class="line">docker exec [容器ID]</span><br></pre></td></tr></table></figure>
<p>进入容器通常使用第二种方式，<code>docker exec</code>后面跟的常见参数如下：</p>
<p>-d, —detach 在容器中后台执行命令； － i, —interactive=true I false ：打开标准输入接受用户输入命令；-t :分配一个伪终端</p>
<h4 id="1-3-3-导出和导入"><a href="#1-3-3-导出和导入" class="headerlink" title="1.3.3 导出和导入"></a>1.3.3 导出和导入</h4><ul>
<li>导出容器</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">导出一个已经创建的容器到一个文件</span></span><br><span class="line">docker export [容器ID]</span><br></pre></td></tr></table></figure>
<ul>
<li>导入容器</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">导出的容器快照文件可以再导入为镜像</span></span><br><span class="line">docker import [路径]</span><br></pre></td></tr></table></figure>
<h3 id="1-4-其它"><a href="#1-4-其它" class="headerlink" title="1.4 其它"></a>1.4 其它</h3><ul>
<li>查看日志</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker logs [容器ID]</span><br></pre></td></tr></table></figure>
<p>这个命令有以下常用参数 -f : 跟踪日志输出</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">--since :显示某个开始时间的所有日志</span><br><span class="line"></span><br><span class="line">-t : 显示时间戳</span><br><span class="line"></span><br><span class="line">--tail :仅列出最新N条容器日志</span><br></pre></td></tr></table></figure>
<ul>
<li>复制文件</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从主机复制到容器</span></span><br><span class="line">sudo docker cp host_path containerID:container_path </span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">从容器复制到主机</span></span><br><span class="line">sudo docker cp containerID:container_path host_path</span><br></pre></td></tr></table></figure>
<h2 id="2-容器技术"><a href="#2-容器技术" class="headerlink" title="2. 容器技术"></a>2. 容器技术</h2><h3 id="2-1-从进程说起"><a href="#2-1-从进程说起" class="headerlink" title="2.1 从进程说起"></a>2.1 从进程说起</h3><p><strong>什么是进程？</strong></p>
<p>从OS的层面来说，进程就是程序的运行时，代码和数据静态的保存在磁盘上的时候就是程序，一旦这个程序真正运行起来了，那么就成了进程。</p>
<p>而容器技术的核心就是通过<strong>约束和修改进程的动态表现</strong>，为其创造一个“边界”。对于Docker这种Linux容器来说，通过CGroup技术来制造约束，通过Namespace来修改进程视图。</p>
<p>从一个例子看一下Namespace可以完成什么事情：</p>
<p>先创建一个容器：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it busybox /bin/sh</span><br><span class="line">/ #</span><br></pre></td></tr></table></figure>
<p>现在在容器中执行ps命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/ # ps</span><br><span class="line">PID   USER     TIME  COMMAND</span><br><span class="line">    1 root      0:00 /bin/sh</span><br><span class="line">    7 root      0:00 ps</span><br></pre></td></tr></table></figure>
<p>可以看到进程号是从pid=1开始的，并且只有两个进程，这跟在宿主机上的结果一定是不一样的。事实上在宿主机中/bin/sh这条命令一定不是pid=1的，但是Docker通过障眼法让该进程看不到在它之前的进程，这就是利用了Namespace技术。</p>
<p>Namaspace其实只是Linux创建新进程的一个可选参数。在Linux中创建进程通过clone()：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> pid = <span class="built_in">clone</span>(main_functino, stack_size, SIGCHID, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<p>这样系统调用就会为我们创建一个进程并且返回pid，如果我们指定CLONE_NEWPID参数：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> pid = <span class="built_in">clone</span>(main_functino, stack_size, CLONE_NEWPID ｜ SIGCHID, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<p>这样一来该进程就被骗了，它将看到一个船新版本的进程空间，在这个进程空间中它的pid是1，但是在宿主机中它的pid有可能是100。这就是简单的Namespace的使用，用来修改进程视图。当然，Linux还提供了其他的namespace参数选项：MOUNT、UTS、IPC、Network和User，用来做各种障眼法。比如MOUNT用来让当前进程看到当前Namespace的挂载点信息，Network用来来进程只看到当前Namespace的网络设备和配置。</p>
<p>实际上对于Docker来说，用于做容器隔离的手段其实就是在创建容器进程的时候，指定了该进程启动所需要的一组Namespace参数。这样一来，该容器就只能看到当前Namespace下的资源、文件、设备、状态或者配置。</p>
<p>所以么，容器这个高大上的概念的本质其实还是进程。</p>
<h3 id="2-2-隔离与限制"><a href="#2-2-隔离与限制" class="headerlink" title="2.2 隔离与限制"></a>2.2 隔离与限制</h3><p>Linux的Namespace技术相对于虚拟化技术其实还是有缺陷的，最主要的问题就是：隔离的不彻底。 既然容器只是一种特殊的进程，那么实际上多个容器之间使用的还是同一个宿主机的操作系统内核，也就是说在windows上运行Linux容器是不现实的。其次，在Linux内核中，有很多资源和对象是不能被Namespace化的，最典型的：时间。比如，如果在容器中调用settimeofday(2)系统调用修改了时间，那么整个宿主机的时间就会被改变，这是不符合预期的。</p>
<p>说完了隔离，下面来说说限制。</p>
<p>虽然容器内的第1号进程可能实际上是宿主机上的第100号进程，并且只能看到容器内的进程空间，但是该进程作为宿主机上的第100号进程与其他进程之间依然是平等的竞争关系。也就是，第100号进程所能用到的资源（比如cpu、内存），可以随时被宿主机上的其他进程或其他容器占用。当然，第100号进程也有可能自己用光宿主机上的所有资源。这些显然都不是一个容器的合理行为。</p>
<p>而Linux Cgoupgs(Linux control groups)就是Linux内核中为进程设置资源限制的一种技术。其最主要的功能就是限制一个进程组能够使用的资源上限，包括CPU、内存、磁盘、网络带宽等等。此外，Cgroup还能对进程进行优先级设置、审计，以及将进程挂起和恢复等操作。这里我们主要说说它的限制功能。</p>
<p>在Linux中，Cgroups向用户暴露出来的操作接口是文件系统，即它以文件和目录的方式组织在操作系统的/sys/fs/cgroups路径下。可以用mount命令将其显示：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mount -t cgroup</span><br><span class="line">cgroup on /sys/fs/cgroup/systemd type cgroup (rw,nosuid,nodev,noexec,relatime,xattr,release_agent=/usr/lib/systemd/systemd-cgroups-agent,name=systemd)</span><br><span class="line">cgroup on /sys/fs/cgroup/pids type cgroup (rw,nosuid,nodev,noexec,relatime,pids)</span><br><span class="line">cgroup on /sys/fs/cgroup/devices type cgroup (rw,nosuid,nodev,noexec,relatime,devices)</span><br><span class="line">cgroup on /sys/fs/cgroup/net_cls,net_prio type cgroup (rw,nosuid,nodev,noexec,relatime,net_prio,net_cls)</span><br><span class="line">cgroup on /sys/fs/cgroup/blkio type cgroup (rw,nosuid,nodev,noexec,relatime,blkio)</span><br><span class="line">cgroup on /sys/fs/cgroup/cpu,cpuacct type cgroup (rw,nosuid,nodev,noexec,relatime,cpuacct,cpu)</span><br><span class="line">cgroup on /sys/fs/cgroup/memory type cgroup (rw,nosuid,nodev,noexec,relatime,memory)</span><br><span class="line">cgroup on /sys/fs/cgroup/freezer type cgroup (rw,nosuid,nodev,noexec,relatime,freezer)</span><br><span class="line">cgroup on /sys/fs/cgroup/hugetlb type cgroup (rw,nosuid,nodev,noexec,relatime,hugetlb)</span><br><span class="line">cgroup on /sys/fs/cgroup/perf_event type cgroup (rw,nosuid,nodev,noexec,relatime,perf_event)</span><br><span class="line">cgroup on /sys/fs/cgroup/cpuset type cgroup (rw,nosuid,nodev,noexec,relatime,cpuset)</span><br></pre></td></tr></table></figure>
<p>在/sys/fs/cgrouops目录下的子目录，比如cpu、cpuset、memory，也叫子系统。这些是当前机器可以被Cgroups限制的资源种类。在子系统对应的资源种类下，可以看到这类资源具体可以被限制的方法。</p>
<p>查看cpu目录下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">ls</span> /sys/fs/cgroup/cpu</span></span><br><span class="line">aegis   cgroup.clone_children  cgroup.procs          cpuacct.stat   cpuacct.usage_percpu  cpu.cfs_quota_us  cpu.rt_runtime_us  cpu.stat  kubepods           release_agent  tasks</span><br><span class="line">assist  cgroup.event_control   cgroup.sane_behavior  cpuacct.usage  cpu.cfs_period_us     cpu.rt_period_us  cpu.shares         docker    notify_on_release  system.slice   user.slice</span><br></pre></td></tr></table></figure>
<p>其中有两个文件cpu.cfs_period_us和cpu.cfs_quota_us，用来限制进程在cpu.cfs_period_us的一段时间内，只能被分配到总量为cpu.cfs_quota_us的cpu时间。</p>
<p>那么要如何使用这样的配置文件呢？只需要在对应的子系统下面创建一个目录，比如在/sys/fs/cgroup/cpu创建一个test文件夹：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir test</span><br><span class="line">cd test/</span><br><span class="line">ll</span><br><span class="line">总用量 0</span><br><span class="line">-rw-r--r-- 1 root root 0 12月  6 17:30 cgroup.clone_children</span><br><span class="line">--w--w--w- 1 root root 0 12月  6 17:30 cgroup.event_control</span><br><span class="line">-rw-r--r-- 1 root root 0 12月  6 17:30 cgroup.procs</span><br><span class="line">-r--r--r-- 1 root root 0 12月  6 17:30 cpuacct.stat</span><br><span class="line">-rw-r--r-- 1 root root 0 12月  6 17:30 cpuacct.usage</span><br><span class="line">-r--r--r-- 1 root root 0 12月  6 17:30 cpuacct.usage_percpu</span><br><span class="line">-rw-r--r-- 1 root root 0 12月  6 17:30 cpu.cfs_period_us</span><br><span class="line">-rw-r--r-- 1 root root 0 12月  6 17:30 cpu.cfs_quota_us</span><br><span class="line">-rw-r--r-- 1 root root 0 12月  6 17:30 cpu.rt_period_us</span><br><span class="line">-rw-r--r-- 1 root root 0 12月  6 17:30 cpu.rt_runtime_us</span><br><span class="line">-rw-r--r-- 1 root root 0 12月  6 17:30 cpu.shares</span><br><span class="line">-r--r--r-- 1 root root 0 12月  6 17:30 cpu.stat</span><br><span class="line">-rw-r--r-- 1 root root 0 12月  6 17:30 notify_on_release</span><br><span class="line">-rw-r--r-- 1 root root 0 12月  6 17:30 tasks</span><br></pre></td></tr></table></figure>
<p>这样一个目录称为一个“控制组”，可以看到系统自动在该文件夹下创建了一堆对应资源限制的文件。cpu.cfs_quota_us为-1代表没有限制。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat cpu.cfs_quota_us</span><br><span class="line">-1</span><br><span class="line">cat cpu.cfs_period_us</span><br><span class="line">100000</span><br></pre></td></tr></table></figure>
<p>现在后台执行脚本启动一个死循环：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">while : ; do : ; done &amp;</span><br><span class="line">[1] 20600</span><br></pre></td></tr></table></figure>
<p>使用top命令查看该进程：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">top</span><br><span class="line">top - 17:38:50 up 46 days, 17:38,  3 users,  load average: 0.82, 0.32, 0.14</span><br><span class="line">Tasks: 187 total,   2 running, 185 sleeping,   0 stopped,   0 zombie</span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">Cpu(s): 13.1 us,  0.3 sy,  0.0 ni, 86.6 <span class="built_in">id</span>,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span></span><br><span class="line">KiB Mem : 32245888 total, 12814256 free,  3753912 used, 15677720 buff/cache</span><br><span class="line">KiB Swap:        0 total,        0 free,        0 used. 28089768 avail Mem</span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class="line">20600 root      20   0  115680    708    160 R  99.7  0.0   1:37.50 bash</span><br></pre></td></tr></table></figure>
<p>可以看到该进程的cpu使用率是100%，假如现在想要限制改进程的cpu使用率怎么办？</p>
<p>现在写入文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo 20000 &gt; /sys/fs/cgroup/cpu/test/cpu.cfs_quota_us</span><br><span class="line">cat cpu.cfs_quota_us</span><br><span class="line">20000</span><br></pre></td></tr></table></figure>
<p>这样一来就可以限制某个进程最多只能使用20%的cpu。但是还没有对改进程生效，要将此限制和进程绑定一下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">echo 20600 &gt; /sys/fs/cgroup/cpu/test/task</span><br><span class="line">top</span><br><span class="line">top - 17:40:59 up 46 days, 17:40,  3 users,  load average: 0.90, 0.54, 0.25</span><br><span class="line">Tasks: 187 total,   2 running, 185 sleeping,   0 stopped,   0 zombie</span><br><span class="line"><span class="meta prompt_">%</span><span class="language-bash">Cpu(s):  3.0 us,  0.2 sy,  0.0 ni, 96.8 <span class="built_in">id</span>,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span></span><br><span class="line">KiB Mem : 32245888 total, 12814508 free,  3753508 used, 15677872 buff/cache</span><br><span class="line">KiB Swap:        0 total,        0 free,        0 used. 28090172 avail Mem</span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND</span><br><span class="line">20600 root      20   0  115680    708    160 R  19.9  0.0   3:42.78 bash</span><br></pre></td></tr></table></figure>
<p>再次查看该进程会发现cpu使用率只有20%。</p>
<p>除了cpu子系统之外，Cgroups的每一项子系统都有其独有的资源限制能力，比如：</p>
<ul>
<li>blkio，为块设备设定I/O限制，一般用于磁盘等设备。</li>
<li>cpuset， 为进程分配单独的cpu核和对应的内存节点。</li>
<li>memory，为进程设定内存的使用限制。</li>
</ul>
<p>Cgroups使用总结：一个子系统目录加上一组资源限制文件的组合。对于Docker等Linux容器，只需要在每个子系统下面为每个容器创建一个资源组（创建一个新目录），然后在启动容器进程之后，把这个进程的PID填写到对应控制组的tasks文件中即可。</p>
<p>其实用户在使用docker容器的使用想要限制资源非常简单：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it --cpu-period=100000 --cpu-quota=20000 ubuntu /bin/bash</span><br></pre></td></tr></table></figure>
<p>查看对应的资源限制文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /sys/fs/cgroup/cpu/docker/b95b0a18ae7eaadcd395a32379aeeeec717ff0b1bdeb5c26697b6566e8ca8e</span><br><span class="line">cat cpu.cfs_quota_us</span><br><span class="line">20000</span><br><span class="line">cat cpu.cfs_period_us</span><br><span class="line">100000</span><br></pre></td></tr></table></figure>
<h3 id="2-3-容器镜像"><a href="#2-3-容器镜像" class="headerlink" title="2.3 容器镜像"></a>2.3 容器镜像</h3><p>通过Namespace做隔离，通过Cgroups做限制，那么一个容器进程看到的文件系统是怎么样的？你可能会说，如果创建进程时指定了Mount参数，那么就可以让容器进程看到一个新的文件系统。但事实是，即便开启了Mount参数，容器看到的文件系统也和宿主机的文件系统一致，这是为什么？因为Mount Namespace和其他Namespace不一样，它对容器进程视图的改变一定要伴随着挂载操作才能生效。因此，在容器进程启动之前要重新挂载整个根目录”/“，这样一来容器内的挂载对宿主机不可见，因此容器进程可以在里面随便折腾。</p>
<p>在Linux中，可以通过<code>chroot</code>命令来执行挂载操作，顾名思义：“change  root file system”，改变进程的根路径到任何地方。</p>
<p>为了让容器的根目录看起来更加真实，一般会在容器的根目录下挂载我一个完整操作系统的文件系统，比如Ubuntu16.04的ISO。这样在容器启动以后，在容器里执行ls /命令看到的就是Ubuntu 16.04的所有目录和文件。这个挂载在容器根目录上用来为容器进程提供隔离后执行环境的文件系统，就是“容器镜像”。它还有一个更专业的名字叫：rootfs(根文件系统)。</p>
<p>至此，Docker的核心原理全部都出来了：</p>
<ul>
<li>Linux Namespace</li>
<li>Cgroups</li>
<li>change root</li>
</ul>
<p>由于rootfs的存在，容器就有了一个十分重要的特性：一致性。有个rootfs之后，应用打包的不只是应用，而是整个操作系统的文件和目录，这就意味着，应用以及它所需要运行的所有依赖都被封装到一起了。也就是说，有了容器镜像，不管在本地还是云端还是任何一台机器，只要解压打包好的容器镜像，应用以及所需的执行环境就能被重现。</p>
<p>在制作一个rootfs的时候，为了简化制作、不需要重复制作，rootfs是基于增量修改的。这也就是Docker镜像中<strong>层（layer）</strong>的概念。也就是说，用户制作镜像的每一步操作都会生成一个层，也就是一个增量rootfs。这里主要用到了<strong>UnionFS（联合文件系统）</strong>的能力，其最主要的功能是将不同位置的目录<strong>联合挂载（union mount</strong>）到同一个目录下。</p>
<p>假设文件结构如下：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">tree</span><br><span class="line">.</span><br><span class="line">├── A</span><br><span class="line">│   ├── a</span><br><span class="line">│   └── x</span><br><span class="line">└── B</span><br><span class="line">    ├── b</span><br><span class="line">    └── x</span><br><span class="line"></span><br><span class="line">2 directories, 4 files</span><br></pre></td></tr></table></figure>
<p>通过联合挂载的方式将这两个目录挂载到一个公共得分目录C上(Centos 7)：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir</span><br><span class="line">mount -t overlay overlay -o lowerdir=A:B ~/test2/C</span><br><span class="line">tree ./C</span><br><span class="line">./C</span><br><span class="line">├── a</span><br><span class="line">├── b</span><br><span class="line">└── x</span><br><span class="line"></span><br><span class="line">0 directories, 3 files</span><br></pre></td></tr></table></figure>
<p>此时C文件夹下就能看到A和B文件夹的文件被合并到了一起。并且如果修改C文件夹中的文件，原本文件夹中的文件也会相应修改。</p>
<p>下面以Ubuntu16.04和Docker CE18.05来说明Docker是如何使用这种UnionFS的，在这个环境配置下使用的是Another UnionFS，后来叫Alternative UnionFS，再后来叫Advanced UnionFS。对AuFS来说，最关键的目录结构在/var/lib/docker路径下的diff目录：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/var/lib/docker/aufs/diff/&lt;layer_id&gt;</span><br></pre></td></tr></table></figure>
<p>启动一个容器：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -d ubuntu:latest sleep 3600</span><br></pre></td></tr></table></figure>
<p>查看镜像：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker inspect image ubuntu:latest</span><br></pre></td></tr></table></figure>
<p>会发现这个镜像由5个层组成，这5层就是5个增量rootfs，每一层都是Ubuntu操作系统文件与目录的一部分；而在使用的时候，Docker会把这些增量联合挂载到一个统一的挂载点上（相当于之前的C目录）。这个挂载点就是/var/lib/docker/aufs/mnt/<ID>。</p>
<p>容器的rootfs一般由3部分组成：可读可写层（rw）、Init层（ro+wh）、只读层（ro+wh）。</p>
<ol>
<li>只读层</li>
</ol>
<p>对应原本镜像的层数，比如ubuntu这个镜像的5层 ，readonly+whiteout。</p>
<ol>
<li>可读可写层</li>
</ol>
<p>Read write，这是rootfs中最上面的一层，在写入文件之前这个文件夹是空的，一旦在容器中进行了写操作，修改的内容就会以增量的方式出现在该层中。如果想执行删除只读层里的一个文件，就会在可读可写层先创建一个whiteout文件，把只读层里的文件遮挡住。比如想删除只读层中一个foo文件，就会现在可读可写层中创建一个foo.whiteout文件，这样当两个层被联合挂载之后，foo文件就被foo.white遮挡住。所以对一个容器中文件的增删改查都只会在可读可写层中操作，并不会影响到原有的镜像只读层。</p>
<ol>
<li>Init层</li>
</ol>
<p>这一层是专门以-init结尾的层，夹在只读层和可读可写层之间，是docker单独生成的一个内部层，专门用来存放/etc/hosts、/etc/resolv.conf等信息。需要这一层的原因是，用户在启动容器时需要写入一些指定值比如hostname，所以需要在可读可写层修改，但是这些修改仅对当前容器生效，在docker commit的时候并不希望连同这些信息一起提交。所以docker修改了这些内容后单独挂载到Init层中，这样在docker commit的时候就不会提交这一层，只会提交可读可写层。</p>
<p>最终这三部分下的layer都被联合挂载到/var/lib/docker/aufs/mnt目录下，表现为一个完整的Ubuntu操作系统目录。</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>科研实用网站</title>
    <url>/2023/01/07/%E7%A7%91%E7%A0%94%E5%AE%9E%E7%94%A8%E7%BD%91%E7%AB%99/</url>
    <content><![CDATA[<h1 id="科研实用网站"><a href="#科研实用网站" class="headerlink" title="科研实用网站"></a>科研实用网站</h1><h2 id="论文发现"><a href="#论文发现" class="headerlink" title="论文发现"></a>论文发现</h2><p>用于相似论文发现，快速找到某关键词下的文章。</p>
<ul>
<li>researchrabbit <a href="https://researchrabbitapp.com/home">https://researchrabbitapp.com/home</a></li>
<li>Connected papers <a href="https://www.connectedpapers.com/">https://www.connectedpapers.com/</a></li>
<li>Paper digest <a href="https://www.paperdigest.org/review/">https://www.paperdigest.org/review/</a></li>
<li>research paper <a href="https://www.researcher-app.com/feed/all">https://www.researcher-app.com/feed/all</a><span id="more"></span>
</li>
</ul>
<h2 id="文章代码"><a href="#文章代码" class="headerlink" title="文章代码"></a>文章代码</h2><p>用于查找文章的代码。</p>
<ul>
<li>paper digest <a href="https://www.paperdigest.org/search/">https://www.paperdigest.org/search/</a></li>
<li>cs paper with code <a href="https://cs.paperswithcode.com/">https://cs.paperswithcode.com/</a></li>
<li>paper with code <a href="https://paperswithcode.com/">https://paperswithcode.com/</a></li>
</ul>
<h2 id="论文写作"><a href="#论文写作" class="headerlink" title="论文写作"></a>论文写作</h2><p>论文写作工具，比如latex、翻译、润色论文等。</p>
<ul>
<li>overleaf <a href="https://www.overleaf.com/">https://www.overleaf.com/</a></li>
<li>DeepL <a href="https://www.deepl.com/translator">https://www.deepl.com/translator</a></li>
<li>phrasebank <a href="https://www.phrasebank.manchester.ac.uk/">https://www.phrasebank.manchester.ac.uk/</a></li>
</ul>
<h2 id="会议-期刊检索"><a href="#会议-期刊检索" class="headerlink" title="会议/期刊检索"></a>会议/期刊检索</h2><p>用于检索会议和期刊。</p>
<ul>
<li>ccf <a href="https://www.ccf.org.cn/Academic_Evaluation/By_category/">https://www.ccf.org.cn/Academic_Evaluation/By_category/</a></li>
<li>huiban <a href="https://www.myhuiban.com/">https://www.myhuiban.com/</a></li>
<li>Call4paper <a href="http://123.57.137.208/C4PREST/index.html">http://123.57.137.208/C4PREST/index.html</a></li>
<li>Ccf ddl <a href="https://ccfddl.github.io/">https://ccfddl.github.io/</a></li>
</ul>
<h2 id="快速理解"><a href="#快速理解" class="headerlink" title="快速理解"></a>快速理解</h2><p>用于帮助快速理解某篇论文。</p>
<ul>
<li>paper digest <a href="https://www.paper-digest.com/">https://www.paper-digest.com/</a></li>
<li>Read paper <a href="https://readpaper.com/">https://readpaper.com/</a></li>
</ul>
<h2 id="万能类"><a href="#万能类" class="headerlink" title="万能类"></a>万能类</h2><ul>
<li>chatGPT <a href="https://chat.openai.com/">https://chat.openai.com/</a></li>
</ul>
]]></content>
      <categories>
        <category>Paper</category>
      </categories>
      <tags>
        <tag>Paper</tag>
      </tags>
  </entry>
  <entry>
    <title>Golang-数组的自定义排序</title>
    <url>/2023/01/29/Golang-%E6%95%B0%E7%BB%84%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8E%92%E5%BA%8F/</url>
    <content><![CDATA[<p>在Golang中有sort包有排序函数，比如sort.Ints可以对整数数组进行升序排序。但是遇到多维数组或者字符串数组的时候，需要采用自定义排序。Golang的自定义排序需要对一种数据结构实现三种方法：Swap(), Less(), Len()，具体方法如下：<br><span id="more"></span><br><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 有时候，我们可能想根据自然顺序以外的方式来对集合进行排序。</span></span><br><span class="line"><span class="comment">// 例如，假设我们要按字符串的长度而不是按字母顺序对它们进行排序。</span></span><br><span class="line"><span class="comment">// 这儿有一个在 Go 中自定义排序的示例。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">	<span class="string">&quot;sort&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为了在 Go 中使用自定义函数进行排序，我们需要一个对应的类型。</span></span><br><span class="line"><span class="comment">// 我们在这里创建了一个 `byLength` 类型，它只是内建类型 `[]string` 的别名。</span></span><br><span class="line"><span class="keyword">type</span> byLength []<span class="type">string</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我们为该类型实现了 `sort.Interface` 接口的 `Len`、`Less` 和 `Swap` 方法，</span></span><br><span class="line"><span class="comment">// 这样我们就可以使用 `sort` 包的通用 `Sort` 方法了，</span></span><br><span class="line"><span class="comment">// `Len` 和 `Swap` 在各个类型中的实现都差不多，</span></span><br><span class="line"><span class="comment">// `Less` 将控制实际的自定义排序逻辑。</span></span><br><span class="line"><span class="comment">// 在这个的例子中，我们想按字符串长度递增的顺序来排序，</span></span><br><span class="line"><span class="comment">// 所以这里使用了 `len(s[i])` 和 `len(s[j])` 来实现 `Less`。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s byLength)</span></span> Len() <span class="type">int</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(s)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s byLength)</span></span> Swap(i, j <span class="type">int</span>) &#123;</span><br><span class="line">	s[i], s[j] = s[j], s[i]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s byLength)</span></span> Less(i, j <span class="type">int</span>) <span class="type">bool</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">len</span>(s[i]) &lt; <span class="built_in">len</span>(s[j])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一切准备就绪后，我们就可以通过将切片 `fruits` 强转为 `byLength` 类型的切片，</span></span><br><span class="line"><span class="comment">// 然后对该切片使用 `sort.Sort` 来实现自定义排序。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	fruits := []<span class="type">string</span>&#123;<span class="string">&quot;peach&quot;</span>, <span class="string">&quot;banana&quot;</span>, <span class="string">&quot;kiwi&quot;</span>&#125;</span><br><span class="line">	sort.Sort(byLength(fruits))</span><br><span class="line">	fmt.Println(fruits)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
]]></content>
  </entry>
</search>
